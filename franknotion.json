[{"pageContent":"This is a complete quick reference or “cheat sheet” for Notion formulas. On this page you’ll find one or more example formulas for every constant, operator, and function available in the Notion formula editor. This cheat sheet is meant to be a quick, easy-to-use bookmark. It is a companion to my complete Notion Formula Reference. There, you’ll find comprehensive technical documentation on Notion formulas, including: Full explanations for every constant, operator, and function Detailed tutorials for creating formula properties and working in the formula editor A full breakdown of Notion formula syntax Advanced guides on Notion regular expressions, formula errors, data type conversion, and more You may also want to check out my Formula Examples Database in Notion itself; there, you’ll find more than 80 example databases demonstrating how to use every formula component listed here. Notion Formula Terms Here are some of the most common terms you’ll run across when working with Notion formulas. Each link here will take you to a full page in the Formula Reference where you can learn more. Property – other properties that exist in your Notion database. Constant – mathematical constants e and π, plus the Boolean values true and false. Operator – symbols that perform operations on 1-3 operands. Includes mathematical operators (such as add), Boolean operators (such as not), and the ternary operator (if). Function – pre-defined formulas that you can use to accomplish complex things quickly. Examples include concat (combines strings) and dateAdd (adds x units of time to a date). Arguments are the accepted pieces of data used within functions: // function_name(argument_1, argument_2) divide(10,2) // Output: 5 // Note that spaces between arguments are optional, but // commas are required. concat(\"My\", \" \", \"Chemical\", \" \",\"Romance\") // Output: My Chemical Romance Notion formulas support four distinct data types: String – text content Number – numeric characters, on which mathematical operations can be performed Boolean/Checkbox – true/false values Date – date objects Good to know: A Notion formula can only return data of a single type. When working with multiple data types, make sure to use type conversion to convert everything to a single type in order to avoid errors. Constants e The mathematical constant e is known as Euler’s Number, and approximately equals 2.718281828459045. Full reference: e e // Output: 2.718281828459 500 * e ^ (.3 * 10) // Output: 10042.768461593832 pi The mathematical constant pi (π) equals (roughly) 3.1415926559. Full reference: pi pi // Output: 3.14159265359 pi * 10^2 // Output: 314.159265358979 true The true constant represents the Boolean output true. Its opposite is false. Full reference: true true // Output: true (checked checkbox) true ? \"😀\" : \"😭\" // Output: 😀 false The false constant represents the Boolean output false. Its opposite is true. Full reference: false false // Output: false (unchecked checkbox) false ? \"😀\" : \"😭\" // Output: 😭 Operators if The if() operator allows you to write if-then statements within a Notion formula. Full reference: if // if() syntax if(prop(\"Type\")==\"Mammal\",true,false) // Output: true // ternary syntax prop(\"Type\")==\"Mammal\" ? true : false // Output: true // Nested if statement if( prop(\"Age\") < 13, \"Child\", if( prop(\"Age\") < 19, \"Teenager\", \"Adult\" ) ) add The add (+) operator allows you to: Perform addition on numbers Concatenate strings – i.e. combine them (also doable with concat()) Full reference: add Usage: + or add() 2 + 5 // Output: 7 \"Monkey D.\" + \" Luffy\" // Output: Monkey D. Luffy add(4,7) // Output: 11 add(\"Monkey D.\",\" Luffy\") // Output: Monkey D. Luffy subtract The subtract (-) operator allows you to subtract two numbers and return their difference. Full reference: subtract Usage: - or subtract() 12 - 5 // Output: 7 subtract(5,12) // Output: -7 multiply The multiply (*) operator allows you to multiply two numbers together and get their product. Full reference: multiply Usage: * or multiply() 12 * 4 // Output: 48 multiply(12,-4) // Output: -48 divide The divide (/) operator allows you to divide two numbers and get their quotient. Full reference: divide Usage: / or divide() 12 / 4 // Output: 3 divide(12,-4) // Output: -3 pow The power (^) operator (also known as the exponentiation operator) allows you to raise a number to a higher power. Full reference: pow Usage: ^ or pow() 3 ^ 4 // Output: 81 pow(4,3) // Output: 64 2 ^ 2 ^ 3 // Output: 256 - evaluates as 2 ^ (2 ^ 3) mod The remainder (%) operator allows you to get the remainder after dividing the first operand with the second operand. Full reference: mod Usage: % or mod() 19 % 12 // Output: 7 19 mod 12 // Output: 7 mod(-19,12) // Output: -7 unaryMinus The unaryMinus (-) operator negates a number. Full reference: unaryMinus Usage: - or unaryMinus() -42 // Output: -42 -(-42) // Output: 42 unaryMinus(42) // Output: -42 unaryPlus The unaryPlus (+) operator is used to convert Booleans and numeric strings to numbers. Full reference: unaryPlus Usage: + or unaryPlus() +\"42\" // Output: 42 +true // Output: 1 +false // Output: 0 unaryPlus(\"42\") // Output: 42 20 + + \"30\" // Output: 50 -+\"30\" // Output: -30 20 + - + \"30\" // Output? -10 [Notion will rewrite this to 20 + -(+\"30\")] not The not operator inverts the truth value of a Boolean/Checkbox value in a Notion formula. Another way of thinking about it is that it returns true only if its operand is false. It accepts Boolean operands. Full reference: not not true // Output: false not(true) // Output: false not empty(\"Hello\") // Output: true not if(50>40,true,false) // Output: false and The and operator returns true if and only if both of its operands have a true Boolean value. Otherwise, it will return false. It accepts Boolean operands. Full reference: and true and true // Output: true true and false // Output: false and(1>0,0<4) // Output: true if(true and true, \"Happy\", \"Sad\") // Output: \"Happy\" if(true and false, \"Happy\", \"Sad\") // Output: \"Sad\" if(5>4 and 1<3, true, false) // Output: true if(length(\"Monkey D. Luffy\") > 5 and length(\"Monkey D. Luffy\") < 100, true, false) // Output: true 4>2 and 3<4 and 7==7 ? true : false // Output: true or The or operator returns true if either one of its operands is true. It accepts Boolean operands. Full reference: or true or false // Output: true false or true // Output: true false or false // Output: false 10 > 20 or \"Cat\" == \"Cat\" // Output: true 10 > 20 or \"Cat\" == \"Dog\" or true // Output: true equal The equality (==) operator returns true if its operands are equal. It accepts operands of all data types – strings, numbers, Booleans, and dates. Full reference: equal 1 == 1 // Output: True equal(1,1) // Output: True 1 == 2 // Output: False \"1\" == 1 // Type mismatch error +\"1\" == 1 // Output: True (uses the unaryPlus operator to convert \"1\" to a number 2^2 == 4 // Output: True length(\"Monkey D. Luffy\") == 15 // Output: True unequal The inequality (!=) operator returns true if its operands are not equal. It accepts operands of all data types – strings, numbers, Booleans, and dates. Full reference: unequal 1 != 2 // Output: True 1 != 1 // Output: False unequal(\"Cat\",\"Dog\") // Output: True \"1\" != 2 // Type mismatch error 2^3 != 10 // Output: True larger The larger (>) operator returns true if its left operand is greater than its right operand. It accepts numeric, date, and Boolean operands. Full reference: larger 2 > 1 // Output: true 42 > 50 // Output: false // Boolean values equate to 1 (true) and 0 (false). true > false // Output: true true > true // Output: false // For dates, \"less than\" equates to \"before\". now() > dateSubtract(now(), 1, \"days\") // Output: true largerEq The larger or equal (>=) operator returns true if its left operand is greater than or equal to its right operand. It accepts numeric, date, and Boolean operands. Full reference: largerEq 2 >= 1 // Output: true 42 >= 42 // Output: true // Boolean values equate to 1 (true) and 0 (false). true >= false // Output: true true >= true // Output: true // For dates, \"less than\" equates to \"before\". now() >= now() // Output: true smaller The smaller (<) operator returns true if its left operand is less than its right operand. It accepts numeric, date, and Boolean operands. Full reference: smaller 2 < 1 // Output: false 42 < 50 // Output: true // Boolean values equate to 1 (true) and 0 (false). false < true // Output: true true < true // Output: false // For dates, \"less than\" equates to \"before\". now() < dateAdd(now(), 1, \"months\") // Output: true smallerEq The smaller or equal (<=) operator returns true if its left operand is less than or equal to its right operand. It accepts numeric, date, and Boolean operands. Full reference: smallerEq 2 <= 3 // Output: true 42 <= 42 // Output: true // Boolean values equate to 1 (true) and 0 (false). false <= true // Output: true true <= true // Output: true // For dates, \"less than\" equates to \"before\". now() <= now() // Output: true Functions concat The concat() function concatenates (aka combines) its arguments. It accepts one or more string arguments, and outputs a single combined string. Full reference: concat concat(\"Roronoa \",\"Zoro\") // Output: Roronoa Zoro \"Roronoa \" + \"Zoro\" // Output: Roronoa Zoro concat(\"Chopper\") // Output: Chopper (this is pointless, but it works) concat(\"Monkey\", \" D.\", \"Luffy\", \" will \", \"be\", \" King of the Pirates\") // Output: Monkey D. Luffy will be King of the Pirates // use \"\\n\" to create line breaks concat(\"Luffy \\n\", \"Zoro \\n\", \"Sanji \\n\", \"Nami \\n\") // Output: // Luffy // Zoro // Sanji // Nami join The join() function takes its first argument and inserts it in between each of its additional arguments. It accepts only string arguments. Full reference: join join(\", \",\"Luffy\",\"Zoro\",\"Nami\",\"Chopper\") // Output: Luffy, Zoro, Nami, Chopper // Use \"\\n\" to add line breaks join(\"\\n\",\"Luffy\",\"Zoro\",\"Nami\",\"Chopper\") // Output: // Luffy // Zoro // Nami // Chopper slice The slice() function allows you to “slice” up a string and output a smaller piece of it. Full reference: slice slice(\"Dangerfield\",0,6) // Output: Danger slice(\"Monkey D. Luffy\",0,6) // Output: Monkey slice(\"Monkey D. Luffy\", 10, 15) // Ouput: Luffy slice(\"●●●●●●●●●●\",0,6) + slice(\"○○○○○○○○○○\",0,6) // Output: ●●●●●○○○○○ length The length() function outputs a number that corresponds to the length of a string. Full reference: length length(\"Monkey D. Luffy\") // Output: 15 length(\"Supercalifragilisticexpialidocious\") // Output: 34 length(\"Doctor Doom\") // Output: 11 format The format() function formats its argument as a string. It accepts all data types, including dates, Booleans, numbers, and even strings. Full reference: format format(4) // Output: 4 (as a string) format(5+5) // Output: 10 (as a string) format(true) // Output: true (as a string) format(5>4) // Output: true (as a string) format(now()) // Output: June 20, 2022 2:23 PM (changes with now()'s value) \"There are \" + format(10) + \" Straw Hat members.\" // Output: There are 10 Straw Hat members. toNumber The toNumber() function converts its argument to a number if it can do so. It is useful for converting strings, Booleans, and dates to numbers. Full reference: toNumber toNumber(\"42\") // Output: 42 (number) toNumber(true) // Output: 1 toNumber(false) // Output: 0 toNumber(5>3) // Output: 1 toNumber(now()) // Output: 1655757000000 (changes with now()'s value) contains The contains() function tests whether the first argument contains the second argument. It only accepts strings (or nested functions that output strings). Full reference: contains contains(\"Monkey D. Luffy\", \"Luffy\") // Output: true contains(\"Monkey D. Luffy\", \"keyLuf\") // Output: false // Invalid contains(true, \"true\") // Error: Type mismatch true is not a Text. replace The replace() function searches a string for a pattern (which can be a regular expression), and replaces the first match it finds with another string. For replace(), replaceAll(), and test(), you may also want to refer to my full guide on using regular expressions in Notion. Full reference: replace replace(\"Pogo\",\"Po\",\"Dog\") // Output: Doggo // Matches the first occurrance, unless otherwise specified replace(\"Dogs Dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats Dogs Dogs // $ tells the regex engine \"start from end of line and work backwards\" replace(\"Dogs Dogs Dogs\",\"Dogs$\",\"Cats\") // Output: Dogs Dogs Cats // Matches are case-sensitive replace(\"thomas\",\"t\",\"T\") // Output: Thomas // You can use brackets [] to create a set of characters, // any of which will be matched replaceAll(\"thomas\", \"[Tt]homas\", \"Megatron\") // Output: Megatron // You can also create a group with () and then use the | (OR) operator replaceAll(\"thomas\", \"(T|t)homas\", \"Megatron\") // Megatron // Accepts regex metacharacters, such as \"\\\\b\" which denotes \"word boundary\". // Without \\\\b, this would output \"Thwas is Sparta\" replace(\"This is Sparta\",\"\\\\bis\\\\b\",\"was\") // Output: This was Sparta replaceAll The replaceAll() function searches a string for a pattern (which can be a regular expression), and replaces ALL matches it finds with another string. Full reference: replaceAll replaceAll(\"Dogs Dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats Cats Cats // Matches are case-sensitive replaceAll(\"Dogs dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats dogs Cats // You can use brackets [] to create a set of characters, // any of which will be matched replaceAll(\"Dogs dogs Dogs\", \"[Dd]ogs\", \"Cats\") // Output: Cats Cats Cats // You can also create a group with () and then use the | (OR) operator replaceAll(\"Dogs dogs Dogs\", \"(D|d)ogs\", \"Cats\") // Cats Cats Cats // Accepts regex metacharacters, such as \"\\\\b\" which denotes \"word boundary\". // Without \\\\b, this would output \"Thwas was Sparta\" replaceAll(\"This is Sparta\",\"\\\\bis\\\\b\",\"was\") // Output: This was Sparta // replaceAll() is a great way to count elements in a string. // Do this by using a regular expression to remove all characters // except the commas that separate the elements (see the example // database below for an in-depth look at this) replaceAll(\"Dog, Cat, Monkey, Bat, Gorilla\",\"[^,]\",\"\") // Output: ,,,, // Apply length() + 1 to get the count! test The test() function allows you to test whether a string contains a substring, the latter of which can be a regular expression. If it does, the function returns true. Full reference: test test(\"Monkey D. Luffy\", \"Luffy\") // Output: true // test() is case-sensitive test(\"Monkey D. Luffy\", \"luffy\") // Output: false // You can use brackets [] to create a set of characters, // any of which will be matched test(\"Monkey D. luffy\", \"[Ll]uffy\") // Output: true // You can also create a group with () and then use the | (OR) operator test(\"Monkey D. luffy\", \"(L|l)uffy\") // Output: true empty The empty() function returns true if its argument is empty, or has a value that equates to empty – including 0 and false. Full reference: empty empty(\"\") // Output: true empty(0) // Output: true empty(false) // Output: true // Assume a row where the Name property is currently blank empty(prop(\"Name\")) // Output: true // Assume a row where the Name property contains text not empty(prop(\"Name\")) // Output: true // The same result can be accomplished with conditional operators // (Assume the Name property contains text in this row) empty(prop(\"Name\")) ? false : true // Output: true abs The abs() function calculates the absolute value of a number. Full reference: abs abs(-42) // Output: 42 abs(42) // Output: 42 cbrt The cbrt() function returns the cube root of its argument. cbrt() accepts only numbers. Full reference: cbrt cbrt(8) // Output: 2 cbrt(64) // Output: 4 // Total surface area of cube with Volume 300m³ // using formula 6a², where a = edge length 6 * cbrt(300)^2 // Output: 268.88428479343 ceil The ceil() function returns the smallest integer that is greater than or equal to its argument. Full reference: ceil ceil(4.2) // Output: 5 ceil(3.845) // Output: 4 ceil(4) // Output: 4 // Calculate the donated change in a round-up donation // Assume prop(\"Subtotal\") is $5.34 ceil(prop(\"Subtotal\")) - prop(\"Subtotal\") // Output: $0.66 exp The exp() function allows you to raise Euler’s Number e (the base of the natural logarithm) to a higher power and get the output, where the argument is the exponent of e. Full reference: exp exp(2) // Output: 7.389056098931 exp(5) // Output: 148.413159102577 e^5 // Output: 148.413159102577 exp(ln(5)) // Output: 5 ln(exp(5)) // Output 5 floor The floor() function returns the largest integer that is less than or equal to its argument. Full reference: floor floor(4.2) // Output: 4 floor(3.845) // Output: 3 floor(4) // Output: 4 ln The ln() function returns the natural logarithm of a number. Full reference: ln ln(20) // Output: 2.995732273554 ln(e) // Output: 1 log10 The log10() function returns the base-10 logarithm of a number. Full reference: log10 log10(1000) // Output: 3 log10(10) // Output: 1 log2 The log2() function returns the base-2 logarithm of a number. Full reference: log2 log2(64) // Output: 6 log2(2) // Output: 1 max The max() function returns the greatest of one or more numbers. max() accepts only numbers or properties that output numbers (it will not auto-convert Booleans). Full reference: max max(3,5,4) // Output: 5 // Assume prop(\"Num\") contains 20 max(prop(\"Num\"),13,5) // Output: 20 // Other data types must be converted to number max(1,+true,+\"3\",9) // Output: 9 // Here, the + operator (unaryPlus) is used to convert // true and \"3\" to numbers. min The min() function returns the smallest of one or more numbers. min() accepts only numbers or properties that output numbers (it will not auto-convert Booleans). Full reference: min min(4,1,9,-3) // Output: -3 // Assume prop(\"Num\") contains 3 max(prop(\"Num\"),13,5) // Output: 3 // Other data types must be converted to number min(3,8,+false) // Output: 0 // Here, the + operator (unaryPlus) is used to convert // false to a number (0) round The round() function rounds its argument to the nearest integer (whole number). Full reference: round round(4.5) // Output: 5 round(4.49) // Output: 4 round(-4.49) // Output: -4 round(-4.5) // Output: -4 round(-4.51) // Output: -5 // Round to two decimal places round(4.158015*100)/100 // Output: 4.16 // Round to three decimal places round(5145.018394*10000)/10000 // Output: 5145.0184 sign The sign() function returns the sign of its argument. It indicates whether its argument is positive, negative, or zero. Full reference: sign sign(-5) // -1 sign(5) // 1 sign(0) // 0 sign(+\"-1\") // -1 sqrt The sqrt() function returns the square root of its argument. sqrt() accepts only numbers. Full reference: sqrt sqrt(16) // Output: 4 sqrt(100) // Output: 10 sqrt(73-3^2) // Output: 8 start The start() function returns the start date from a date range. It accepts a single date argument. Full reference: start // Assume a property \"Date\" exists, with // a row value of June 23, 2022 → June 27, 2022 start(prop(\"Date\")) // Outpuut: June 23, 2022 end The end() function returns the end date from a date range. It accepts a single date argument. Full reference: end // Assume a property \"Date\" exists, with // a row value of June 23, 2022 → June 27, 2022 end(prop(\"Date\")) // Outpuut: June 27, 2022 now The now() function returns the current date and time in your local timezone. now() accepts no arguments. Full reference: now now() // Output: June 23, 2022 12:30 PM (at time of writing) timestamp The timestamp() function converts a date argument into its corresponding Unix timestamp (also known as Unix Time or Epoch Time), which is a number. Full reference: timestamp timestamp(now()) // Output: 1656012120000 (will change with the value of now() fromTimestamp The fromTimestamp() function converts a Unix timestamp into a date. Full reference: fromTimestamp // Notion will express this date in your local time zone, so it // may look different if you try this formula out.hin fromTimestamp(1656012840000) // Output: June 23, 2022 7:34 PM (UTC) dateAdd The dateAdd() function accepts a date argument and adds to it, returning a new date. It requires three arguments in the following order: A date (must be an actual date data type) A number A unit Accepted units include: “years” “quarters” “months” “weeks” “days” “hours” “minutes” “seconds” “milliseconds” Full reference: dateAdd // Assume a property called \"Date\" with a current row value // of June 1, 2022 dateAdd(prop(\"Date\"),3,\"months\") // Output: September 1, 2022 dateAdd(prop(\"Date\"),5,\"days\") // Output: June 6, 2022 dateSubtract The dateSubtract() function accepts a date argument and subtracts from it, returning a new date. It requires three arguments in the following order: A date (must be an actual date data type) A number A unit Accepted units include: “years” “quarters” “months” “weeks” “days” “hours” “minutes” “seconds” “milliseconds” Full reference: dateSubtract // Assume a property called \"Date\" with a current row value // of June 1, 2022 dateSubtract(prop(\"Date\"),3,\"months\") // Output: March 1, 2022 dateSubtract(prop(\"Date\"),5,\"days\") // Output: May 27, 2022 dateBetween The dateBetween() function returns the amount of time between two dates, based on a specified unit of time. The function returns a number, and requires three arguments in the following order: Date 1 (must be a date data type) Date 2 (must be a date data type) A unit Accepted units include: “years” “quarters” “months” “weeks” “days” “hours” “minutes” “seconds” “milliseconds” Full reference: dateBetween // Assume now() == June 23, 2022 and Date == June 1, 2022 dateBetween(now(),prop(\"Date\"),\"days\") // Output: 22 // Assume now() == June 23, 2022 and Date == June 30, 2022 dateBetween(now(),prop(\"Date\"),\"days\") // Output: -6 // Assume now() == June 23, 2022 and Date == December 25, 2022 dateBetween(now(),prop(\"Date\"),\"months\") // Output: -6 formatDate The formatDate() function formats a date as a string using the Moment standard time format. Full reference: formatDate formatDate(now(), \"MMMM DD YYYY\") // Output: June 24 2022 formatDate(now(), \"dddd, MMMM DD, YYYY hh:mm A zz\") // Output: Friday, June 24, 2022 10:45 AM MDT formatDate(now(), \"[Month of] MMMM, YYYY\") // Output: Month of June, 2022 Good to know: formatDate() uses Moment.js for date formatting. minute The minute() function returns an integer (number) between 0 and 59 that corresponds to the minute of its date argument. Full reference: minute minute(now()) // Output: 25 (When current time was 11:25 AM) // Assume a propety called Date with a current date of June 24, 2022 11:29 AM minute(prop(\"Date\")) // Output: 29 hour The hour() function returns an integer (number) between 0 and 23 that corresponds to the hour of its date argument. Full reference: hour hour(now()) // Output: 11 (When current time was 11:25 AM) // Assume a propety called Date with a current date of June 24, 2022 11:29 AM hour(prop(\"Date\")) // Output: 11 day The day() function returns an integer (number) between 0 and 6 that corresponds to the day of the week of its date argument: 0 = Sunday 1 = Monday 2 = Tuesday 3 = Wednesdy 4 = Thursday 5 = Friday 6 = Saturday Full reference: day day(now()) // Output: 5 (when now() = June 24, 2022) // Assume a propety called Date with a current date of June 1, 2022 day(prop(\"Date\")) // Output: 3 date The date() function returns an integer (number) between 1 and 31 that corresponds to the day of the month of its date argument. Full reference: date date(now()) // Output: 24 (when now() = June 24, 2022) // Assume a propety called Date with a current date of June 1, 2022 11:29 AM date(prop(\"Date\")) // Output: 1 month The month() function returns an integer (number) between 0 and 11 that corresponds to the month of its date argument. Full reference: month month(now()) // Output: 5 (when now() = June 24, 2022) // Assume a propety called Date with a current date of Jan 1, 2022 month(prop(\"Date\")) // Output: 0 year The year() function returns an integer (number) that corresponds to the year of its date argument. Full reference: year year(now()) // Output: 2022 (When now() = June 24, 2022) // Assume a propety called Date with a current date of June 24, 2022 year(prop(\"Date\")) // Output: 2022 id The id() function returns the current row’s page ID, which is a unique string. id() accepts no arguments. Full reference: id // Page URL: <https://www.notion.so/thomasfrank/id-c5d67d15854744869cc4a062fb7b1377> id() // Output: c5d67d15854744869cc4a062fb7b1377 Formula Tips Here a few useful tips for working more effectively with formulas: Write Formulas in a Text Editor Full reference: Writing Complex Formulas in VS Code You can write formulas in a text editor like VS Code; this will allow you to use indentation, multiple lines, and comments. When you need to compress your formula for pasting into Notion, simply do a search-and-replace. Search for the following regular expression: (\\n[ ]{2,}|\\n|[/]{2}[^\\n]*) Copy and paste your formula. We’ll compress one of the copies, leaving the other as an easy-to-read reference. Open the find and replace window with Ctrl/⌘ + F and paste the expression into the find field. Paste in the expression above. Click the Use Regular Expression button. Select the entirety of your formula (just one of the copies) Click the Find in Selection button. Ensure the Replace field is blank. Click the Replace All button. Return Empty/Null Values in Notion Formulas Full reference: Return Null/Empty Values in Formulas To return an empty string: \"\" To return an empty number: toNumber(\"\") To return an empty date: fromTimestamp(toNumber(\"\")) There is no possible null/empty state for Booleans/Checkboxes. However, you can convert Booleans to strings with format in order to create a setup where true/false/empty is possible: // Assume \"Checkbox\" is a Boolean/Checkbox property. // Invalid; will throw a Type Mismatch error: if( 1 > 2, prop(\"Checkbox\"), \"\") // Valid. Will output \"true\", \"false\", or an empty value. if( 1 > 2, format(prop(\"Checkbox\")), \"\") If you find this cheat sheet useful, you’ll also love my Notion Tips newsletter! Join to get notified whenever I publish new tutorials, guides, and templates:","metadata":{"source":"https://thomasjfrank.com/notion-formula-cheat-sheet","title":"Notion Formulas: The Ultimate Cheat Sheet (2023)","date":"2022-09-12T19:56:09+00:00","contentLength":4157}},{"pageContent":"The most powerful and flexible tool in Notion is its database feature. Within your Notion workspace, you can create databases that can store almost any kind of data, including text, numbers, file attachments, and more. Databases can be used to create: Task managers (such as Ultimate Tasks) Calendars Note-taking systems CRMs Custom dashboards for sales and performance data …and much more. Once you understand how to work with databases, you’ll unlock a whole new level of capability inside of Notion. In this Notion Fundamentals lesson, I’ll guide you through all the basics of creating and using databases. Note: This guide is massive, and is intended to be a truly complete tutorial for Notion databases. I encourage you to use the table of contents to jump around! In the video version of this lesson, we’ll be using everything we learn to create a useful example database – a simple task manager, which you could include in the personal dashboard that we’ve been building throughout the other lessons in this series. One thing I’ll note before we get started is that I’ve created a completely free task management template called Ultimate Tasks, which has a lot more capabilities than the example we’ll be building here – such as sub-tasks, recurring tasks, progress bars for projects, and more. If you’re looking for a capable task manager for Notion, check it out! The Ultimate Task and Project Management Template for Notion Use this template to move ALL of your task and project management into Notion. Get it Free How to Create a Notion Database The best way to learn is by doing – by trying things out, experimenting, and getting your hands dirty. So let’s start this guide out by covering how to actually create a Notion database. Doing so is simple; just type /database on any Notion page, and you’ll see a list of database options. You can start out by choosing Database – Inline, which will create a brand-new database right on that page. Here’s a very simple example database that lists some of my favorite movies: By default, your new database will be displayed as a table. Notion offers other database layouts, but a table is a great starting point. There are a couple of alternative ways to create a database as well. First, you can create a blank page (see my lesson on creating pages), and then select one of the database options: You can also use the / command to create a database with the specific layout you want. The options include: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view If you create a database block using a layout command, Notion will give you the option to either create a Linked Database (which links to an existing source database), or to create a new database. There are later sections in this guide for both (click to jump to them): Database Layouts Linked Databases For now, it’s just useful to know the ways you can create new databases. Notion Databases at a Glance Databases store rows (sometimes known as records). And in Notion, those rows are actually Notion pages themselves. The Table layout in Notion displays a database’s rows as they’re actually stored in the database (since Notion uses a table-style database structure with rows and columns). In this example, each movie is a row in the database. However, I can open up any one of them and get a Notion page that works just like any other: These pages can hold any type of content you want – text, images, and even other Notion databases. Databases also have properties. You can see these at the top of the Hot Fuzz page above, or as columns in the Table view. Properties hold structured information within a database, and typically they’re set on a per-row basis. Here in the movies database, I have two: Genre – a Multi-Select property, which allows one or more tags to be applied to each record Seen Recently – a simple Checkbox property Properties have several uses, but their greatest use is in filtering and sorting your data. Here’s another view of our Movies table, filtered to show only the movies that we haven’t seen recently: Note how this is a different view of the same database. Our original Table tab doesn’t contain the same filter. By looking at the same database through different views with unique filters, we can look at the same database in many different ways. This is immensely powerful. Consider a Notes database containing all the notes in your life. That might be thousands of notes! Without any filters, this data would be hard to sift through. But by applying properties, sorts, and filters, you could create all sorts of useful views: All notes created in the last month Notes tagged with “Fitness” All notes, sorted by Date Last Updated Notes related to the Vacation project in your Project Database Notes with a Review Date that falls within the next week Without a database, these types of filters and sorts aren’t possible in Notion – which means you may eventually end up with long lists of pages that can only be sorted by dragging-and-dropping. Hopefully, this introduction has shown you just how powerful databases can be. From here, the rest of this guide is a choose-your-own-adventure: You can scroll up to the video tutorial above, where we’ll create a simple task manager using some slightly more advanced database techniques. Or, you can keep reading this written guide, which will detail all the important Notion database features – filters, sorts, grouping, properties, relations, linked databases, and more. What Is a Database? Now that you’ve had a proper introduction to how Notion databases work, I’d like to touch a bit on what databases actually are before we get into the details of their individual features within Notion. In general, a database is defined as an: “…organized collection of data stored and accessed electronically.” Nearly every program and web app you use relies heavily on databases. If you’ve ever used a digital calendar app like Google Calendar, then you’ve benefited from a database. Behind the scenes, every event on your Google Calendar is a row in a database. These rows have properties, just like the ones you saw in this guide’s introduction. Some of these include: Event date Location Calendar (Work, Personal, etc.) Google Calendar uses the values stored for these properties in each row to intelligently display your calendar, showing you each event on its correct day slot, displaying the event’s location, and color-coding each event based on its Calendar. Notion works in much the same way, but it gives you a lot more control over your databases. You can create your own properties, customize them, and set up database views that display your data based on filters, sorts, and more. Here’s an example: What if I just wanted to see events on my Work calendar in the month of August? In Google Calendar, I’d toggle all my other calendars to their “off” state, and navigate to the correct month: In Notion, I could achieve the same result by first ensuring that I have properties in my Events database for Date and Calendar. Then, I could simply create a view with two filters: Where Calendar contains Work Where Date is within August 1 ➡ August 31 Of course, Notion also includes a Calendar layout, so the date filter might not be necessary. I just wanted to show you how you’d directly interact with your database properties to create unique, filtered views. Databases vs. Spreadsheets You might have looked at all our example table views in the screenshots and thought, “Hey, those look like spreadsheets!” Indeed, they do look like spreadsheets – but they’re not. There’s a fundamental difference between spreadsheets and databases. On a spreadsheet, data is contained within cells that have specific X:Y coordinates on a grid, such as B2 or D5. This means that formulas can reference specific cells, like B2+D5 – this simple formula will add the values of B2 and D5. Conversely, databases don’t really have “cells” with X:Y coordinates. Rather, each record has the same number of properties, each of which can be set to a unique value per record. Technically, since most databases are relational and store data in a table with rows and columns, you could feasibly target coordinates on the table. But since databases are built to be flexible, the vast majority of database tools don’t provide spreadsheet-like cell coordinates for row:property pairs. We can display a database in a grid-like table, but it’s not actually a grid of cells that we can target. This means we can easily visualize the information in our database in other ways besides a classic table – such as a Kanban-style board, where the columns are based on the Assignee property: Spreadsheets and databases do have quite a bit of overlap, though. In a spreadsheet, we can simulate properties by creating a two-dimensional table. And apps like Excel even allow us to sort of treat a spreadsheet like a database through pivot tables and other functions. Likewise, an app such as Notion can let us view a database’s table structure, which looks like a spreadsheet. The most important thing to know as a Notion user, however, is that we can’t target individual row:property combinations as if they were cells on a grid. Here on my task table, I couldn’t write a formula that specifically targets the “cell” with “April 6” in it. In Excel, you might think of that location as B3, but there’s no B3 in Notion. Instead, there’s a row – the “Test Web Parachute” row – and its Due Date property is set to April 6. It’s also worth noting that “Test Web Parachute” is itself a specific value in the Name property. In Notion, new databases get a default property called Name, which can’t be hidden or deleted. But it is still a property – just a special property. Its type is “Title”, and you can actually open it up to see a brand-new Notion sub-page within your database. If you want to get even nerdier about spreadsheets and databases, check out this article comparing them. With this high degree of control and flexibility, you can use databases to create all sorts of different tools and applications inside of Notion. After all, many software tools are just collections of filtered database views! Consider: Your phone’s contacts app Task managers like Todoist Websites like IMDB Each of these simply gives you tools to work with one or more databases. As a result, you can create replacements for all of these tools inside of Notion. You can also create hyper-personalized tools that fit the exact information and processes you use for your work. That’s Notion’s superpower. It allows you to build tools that don’t yet exist, tailored to your exact needs. Notion Database Examples Book Tracker Contact Manager Simple Task Manager As we dig into all the particulars of Notion’s database tools, you might want some example databases to play around with. Here are a few, which will also serve to show you some of the tools you can build within Notion. Simple Task Manager Contact Manager Book Tracker Each of these databases is available as a free template, which means you can duplicate them into your Notion workspace and make changes to the duplicated copy. Learning happens fastest when you take action, so experiment and make some changes! Add some stuff! Let your cat walk on your keyboard for a minute and then try to fix everything that broke! There are 3 ways to make progress in anything:1. Buy new gear.2. Learn academically through books, courses, etc.3. Spend time in deliberate practice.In order of importance:Practice > Learning >>>>> Gear— Thomas Frank (@TomFrankly) May 29, 2022 I’ll also note that these are very simple example templates. They purposely lack a lot of features so that they’re easy to understand and edit. I’ve also designed several more robust templates with advanced features. These templates are completely ready to rock, and will instantly upgrade your Notion workspace with useful tools. Check them out on my Notion Templates page. We’re now ready to start digging into all of the features that Notion databases offer. From here, you may want to use the Table of Contents to the left (or at the top of this article if you’re on mobile) in order to find the topic you most want to learn about. Database Views A database view is a specific combination of layout, filters, sorts, etc. Note that a database block can contain multiple views. When it does, you’ll see them all listed across the top as tabs: Each of these views pulls from the same database, but each shows a unique set of data based on a combo of sorting, filtering, and layout. You can also add a new view to a database block using the Add view button: For each view, you can access a View Options menu, where you’ll be able to change nearly any setting related to that database view: Here, you’ll have access to nearly every setting inside your database, including: Database name Layout – Table, Board, Calendar, etc. Property settings – show/hide properties on the current view Filter options Sort options Group options Load Limit – sets the max number of rows that will be loaded automatically (you can load additional rows using the Load More button at the bottom of any view) Lock Database/Lock Views – On a source database, this will lock the entire database. On a Linked Database, you’ll see Lock Views, which merely locks the Linked Database’s views from being changed. (Learn more about locking databases) Copy Link to View – copies the link to the current database view to your clipboard Duplicate View – duplicates the specific view you’re currently on Delete View – deletes the specific view you’re currently on Layout Types Notion databases can be viewed in several ways. You’ve already seen the Table layout in our examples above, but that’s just one of six available layouts: Table – a traditional, spreadsheet-like view Board – a Trello-style “Kanban” view Timeline – a Gantt chart view Calendar – a no-frills Calendar view List – a responsive, mobile-friendly Table alternative Gallery – an aesthetic view that’s great for showcasing images Each one of these layout types gives you a different way of displaying the same information from your database. They each have their own advantages, disadvantages, and features, so try them all out! Add New Pages to a Database You have a few different options for adding new pages to your database. First, you can hit the +New button within your database view. In a Table view, you’ll find it at the bottom of the table: It’s worth noting that this is the only way to add a row that will conform to the view’s filters automatically. Example: If the view above had a filter that said “Genre is Action”, then your new row would automatically be tagged with Action. This is called a forcing function. Click here to jump to the section of the guide on forcing functions. You can also hit the blue New button in the top-right corner of any database view. This will open up a modal window with a blank record in the database. Additionally, you can create new rows in a specific database from anywhere in your Notion workspace by using the + link syntax, then choosing the “New page in…” command. For example, I could add a new row to my Movies database from anywhere by typing +Ghost in the Shell, choosing New page in…, and then selecting the Movies database as the destination. Learn more about this in my guide on linking Notion pages together. Finally, you can add new rows to a Notion database through external tools. For example, the official Notion web clipper and the Save to Notion extension can both clip web pages into your Notion workspace. If you want to get more advanced, you can even use the Notion API to add new database rows using thousands of other tools. Database Properties Properties are the columns in a database’s table structure, and they’re useful for holding structured information about each row. They let you add dates, checkboxes, tags, numbers, and a lot more to your databases. In a Table view, you’ll see your database’s properties as columns: In other layouts, you’ll see property values listed on the cards for each row: You can show/hide individual properties on any given view by going to View Options → Properties: By opening up a row as a page, you’ll be able to see all of the properties in that row’s database. You can also easily add new properties here. Notion comes with many different types of properties. Some are writable, meaning you can edit the information they hold on each row. Others are read-only, meaning they hold information that can’t be edited. Here’s a table showing all of Notion’s property types: Property Description R/W Text Holds text, which can be formatted. Writable Number Holds numbers. Can be formatted as a progress bar. Writable Select Holds singular “tags”. Writable Multi-Select Can hold multiple “tags”. Writable Status Indicates project/task status. Always has a default value. Can show as text or a checkbox. Writable Date Holds dates, which can be displayed absolutely (e.g. “03/25/22”) or relatively (e.g. “Tomorrow”). Writable Person Holds members or guests of the workspace. Writable Files & Media Holds file attachments, including images, audio files, video, etc. Writable Checkbox Holds a simple checkbox. Writable URL Holds a URL, which is clickable. Writable Email Holds an email address. Writable Phone Holds a phone number, which can be called on supported devices. Writable Formula Holds formulas that can process and output data in many ways. Read-Only Relation Relates the row to other rows in the same database or another database. Writable Rollup Pulls in property information from Related rows. Read-Only Created time Holds the date and time of the row’s creation. Read-Only Created by Holds the workspace user who created the row. Read-Only Last edited time Holds the date and time of the row’s last edit. Read-Only Last edited by Holds the workspace user who last edited the row. Read-Only One last useful thing to know about properties is that they can be deleted and restored. If you accidentally delete a property, just head to View Options → Properties → Deleted Properties to find it and restore it (or permanently delete it if you want): Sorting You can sort a database view by any property, in either ascending or descending order. To create a sort: Hit the Sort button at the top of your database block. Select the property by which you’d like to sort your view. Choose ascending or descending order. Add additional sort criteria if you want. By adding additional properties, you can create even more granular sorts in your database views. In these cases, the database will be sorted by each property in top-to-bottom order. Drag properties around to change the sort order. Here, you can see that I have this shot list database sorted first by Type, then by B-Roll Description. P.S. – This shot list database is part of Creator’s Companion, my all-in-one Notion template for content creators. Check it out if you make videos, blog posts, or social media content. If you create a sort within a database that is shared with others (Team Members or Guests), your sort will initially only be visible to you on your current device. You’ll notice a Save for Everyone button after creating the sort; click it if you want to apply the sort to the database for everyone. You can also click Reset to remove any changes you’ve made, or simply leave things as-is if you want to keep the sort for your eyes only. If you’re working on a database that’s private, you won’t see these options; they only come up on shared databases. Filters Databases often contain huge amounts of data, but you rarely need to see all of it at once. Typically, you just need to see the rows that are relevant to a specific context, like: Tasks that are due today Subscribers who are less than 30 days away from their renewal date Movies in the Action genre This is where filters come in. Filters allow you to limit the rows a view displays, and they’re among the most useful tools you’ll find in Notion. Just like a sort, you can create a filter by hitting the Filter button at the top of your database block: There are two types of filters in Notion: Simple Filter – a singular filter that targets one property Advanced Filter – a set of filters or filter groups Simple Filters Simple filters are quick to create and target a single property. To create one, hit the Filter button and then select the property you’d like to filter by. Filters follow this convention: Property Name → [Criteria] → Value Here, you can see that I’m filtering my view by the Genre property, which has the Multi-Select property type: Your criteria options will change depending on the property’s type. Here, I have four options: Contains Does Not Contain Is Empty Is Not Empty Finally, I can choose one or more values. My completed filter reads: Genre Contains Action, which means my view will only show rows that have Action in their Genre property. Since Genre is a Multi-Select property, rows can also contain other genres. You can add multiple simple filters to a database view, and you’ll see them displayed in a row across the top of your database view when the Filter bar is open. Advanced Filters An Advanced filter is a set of one or more filters that show up in a single dialogue box. Using an advanced filter, you can do something that’s incredibly useful; you can mix AND/OR operators when working with multiple filters. When you create multiple simple filters, you’re always using the AND operator between them. For example: “Genre contains Action” AND “Seen Recently is Checked”. By creating an advanced filter, you could instead set up this filter combo: “Genre contains Action” OR “Seen Recently is Checked”. Note how this drastically changes the rows that show up in this view! Now, a row only has to fit one of the filter criteria. Advanced filters also let you create filter groups. Within an advanced filter, click the Add Filter Rule dropdown and then select Add Filter Group to create one: Filter groups let you mix your AND/OR operators. Normally, once you’ve chosen either AND or OR, you’re locked into that choice when you add more rules to the filter. However, a filter group gives you a nested box where you can select a new operator. How is this useful? Here’s an example problem: Say I’m a movie buff. I want to watch a movie every night, and I have these preferences: I’m an action movie nut, so I might want to watch an action movie even if I have seen it recently. For other genres, I only want to watch a movie if I haven’t seen it recently. Using a filter group, I can create a view that fits both of these preferences. In my Movies database, I’ve created the following set of filters: If a row contains the Action genre, it’ll always show up. If it doesn’t contain the Action genre, it’ll only show up if Seen Recently isn’t checked. Here’s another example from my Ultimate Brain template: Ultimate Brain has a robust note-organization structure (modeled on Tiago Forte’s P.A.R.A. method) with: Higher-level Areas Lower-level Resources Areas can contain Resources, and Notes can exist in Areas or Resources. This means that within an Area, we’d want to show Notes that exist directly in that Area, or that exist within any Resources underneath that Area. We also want to make sure those Notes aren’t archived. Using a filter group, I’ve created a combo of AND and OR operators to meet these criteria. This example is more complex than the previous one, but I hope that it illustrates how filters can allow you to create truly useful tools directly within Notion! P.S. – If you’d like to use Notion as a true Second Brain, check out my Ultimate Brain template. It seamlessly combines tasks, notes, projects, goals, and whole-life organization, and it’s what I use as my own productivity system. Saving Filters As with sorts, filters created in shared databases will initially only affect your account and device. When you create a new filter or change/delete current filters, you’ll see a Save for Everyone button pop up: You can click that to apply the filter for everyone who has access to the database, hit Reset to erase your changes, or just leave things as they are if you want the filter to only affect you. Forcing Functions When you set up a filter in a database view, new rows created in that view must conform to that filter. As a result, creating a new row in a view with filters will automatically set default property values. Here’s an example: In this view of the Movies database, I’ve created the following filter: Seen Recently is Checked. Note how the new row I’ve added automatically has its Seen Recently checkbox property checked. When filters are used in this way, I call them forcing functions. You can use these in all sorts of ways – here are just a few ideas: Add tasks to a task view with a due date set to Today Add notes to a filtered notebook view with a specific tag, such as Lecture or Book Add tasks to a shared task database with a specific Assignee (person property) I’ve made an entire video explaining how these work (and how to use them to your advantage) in a lot more detail: Grouping Notion lets you group rows in a database view based on common values in nearly any property type. Here, I’ve grouped my Movies database view by the Genre property. Now my movie rows are grouped by genre: You can add Grouping to any view layout (except for Calendar) by going to View Options → Grouping. From there, you’ll be able to select the property you’d like to use for grouping: You’ll also find a few other options, such as Hide Empty Groups. Sub-Grouping Notion’s Board layout has a unique feature: In addition to Grouping, it can have Sub-Grouping as well. Normally, a Board view will display its groups as columns. This is the classic “Kanban” style of grouping that has its origins in Japanese manufacturing, and which was popularized in the U.S. by apps like Trello. By adding sub-grouping, you can group a board view into distinct rows. In this case, the rows aren’t actual database rows (as in a Table view); they’re sub-groups based on another property. In the screenshot above, I’ve grouped the Board view by Genre, and then sub-grouped it by a new Select property called Rating. Movies are grouped by their ratings – PG, PG-13, R, etc. You can add sub-grouping to a Board view in nearly the same way you’d add grouping – simply navigate to View Options → Sub-Group. Relations The Relation property type allows you to relate database rows to each other. These relations can be created: Between rows in the same database Between rows in separate databases This concept can take a bit of time to fully grok, so let me start out with an example. Example 1: Parent and Child Tasks Task managers often have a sub-tasks feature, which lets you nest sub-tasks underneath a top-level “parent” task. Here’s a task with a couple of sub-tasks in Todoist: When you open the Parent Task 1’s window as in the image above, how does Todoist know to show you two sub-tasks – and not show you any other tasks? Behind the scenes, there’s a Relation set up in Todoist’s database. This Relation consists of two properties, which you could think of as columns in a table: Parent Task Sub-Tasks The Parent Task 1 database row has its Sub-Tasks Relation property filled with links to two other database rows: Child Task 1 Child Task 2 Likewise, each Child Task has its Parent Task Relation property filled with a link to the Parent Task 1 row. In this way, Parent Task 1 is related to the two Child Tasks. With this Relation set up, Todoist can simply use a filter (also behind the scenes) to display the correct Child Tasks. Essentially, that filter would read: Where Parent Task contains “Parent Task 1” This filter ensures that only the two Child Tasks show up. If that makes sense so far, let’s create it in Notion! How to Create a Single-Database Relation A Relation is a type of property, so you can add one to your database by: Adding a new property Selecting the Relation type Selecting the Database you’d like your Relation property to point towards Choosing whether the Relation should have separate properties Since I’m creating a Parent Task ⬌ Sub-Tasks relation, I want to make sure I choose the same database that I’m currently working with – in this case, My Tasks. Next, I’ll choose whether or not I want to create Separate Properties. If I don’t, I’ll just get a single Relation property called Sub-Tasks. If I do turn it on, I’ll get a second property. Since I do want a second property called Parent Task, I’ll turn on the Separate Properties option and give my second property the correct name: Now that I have my Relation properties, I can model Parent Tasks and Sub-Tasks just like we did earlier with Todoist. Here, I’ve clicked into the Sub-Tasks property within the “Take Grocery Boxes…” row, and set two other rows as sub-tasks: Build grocery boxes Get rain covers Note how “Take Grocery Boxes…” automatically shows up in the Parent Task property for each of these sub-tasks. Now that we have these Relations set up, we can do some useful stuff! Here’s a basic example. I’ve set up a simple filter that says: Where Parent Task contains “Take Grocery Boxes…” With this filter in place, I can only see the two sub-tasks I created earlier. In the Linked Databases section of this guide, I’ll show you how to set up this same filtered view inside the Parent Task’s page. This is far more useful, and it models the Todoist example above perfectly. For now, let’s take Relations one step further by relating two separate databases together. Example 2: Tasks and Projects Task managers also tend to have Projects or Lists that are useful for grouping multiple tasks together. You can see this in Todoist: If we think about the databases that run everything behind the scenes, we realize that there are actually two main databases: Tasks Lists These databases are related to one another. This means that a single row in the Lists database can be related to many rows in the Tasks database. Then, using filters, Todoist can show you a tidy view of the tasks in a specific list, such as House. Guess what? You can do the exact same thing in Notion by creating a multi-database Relation! How to Create a Multi-Database Relation To create a multi-database Relation, we’ll first need two databases to work with. Fortunately, the Simple Task Manager example template already has two: My Tasks My Projects I can create my Relation in either database, but I’m going to create it in My Tasks. Adding a new Property, I’ll: Name it Project Select the Relation property type Select the My Projects database for the database connection Toggle Show on My Projects to the On position Name my Related Property with the My Projects database as “Tasks” Note how the Relation builder also gives you a preview of what your Relation looks like. Here, you can see that two properties are being created: “Project” within the My Tasks database – which points to the My Projects database “Tasks” within the My Projects database – which points to the My Tasks database These two properties are reciprocal, meaning that setting a related row in one will affect the other. In My Projects, the Suit Redesign project contains two related rows from My Tasks: Going over to My Tasks, we can see that both of these rows – Design new web shooters and Test web parachute – contain Suit Redesign in their Project property. With this Relation set up, I can do some very useful things. For example, I can group this view by my Project property. I can also set up a database view within a Project’s page that shows only its related tasks. To do that, I’ll need to use a Linked Database. Linked Databases Linked Databases allow you to create a database block that pulls data from an existing source database, which can live elsewhere in your Notion workspace. For example, the main All Tasks database inside my Ultimate Brain template lives inside the Archive: On Ultimate Brain’s Quick Capture page, there’s a Linked Database block that uses All Tasks as its source: This means that any rows I add to this linked database view will end up in the All Tasks database. Essentially, you can think of Linked Databases as collections of Views for a database that can live elsewhere in your Notion workspace. Linked Databases are immensely useful. They allow you to create pages and dashboards in Notion that are driven by source databases, but that serve specific contexts. The Quick Capture page shown above is just one example of a context-specific page. Here’s another one – this page only shows tasks that are due on or before tomorrow: Note that this Linked Database view has the source database hidden; this is an option you can turn off or on. How to Create a Linked Database You can create a Linked Database in Notion either by typing /Linked view of a database or by typing any of the following options: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view I’ll go with /Linked view... inside the Suit Redesign project in the My Projects database. That way, I’ll be able to get a view of all the tasks related to this project. The first thing I have to do is select a data source. This is the source database that I want to pull from. In this case, I want to select My Tasks: Next, I’ll be given the option to either copy an existing view from the source database or to create a new empty view. I’ll do the latter so I can completely customize it: From here, I can customize my view just like I would with a normal view inside the source database. All of the options are exactly the same. The only difference is that the Linked Database view comes with the option to show or hide the source database title. Here, I’ve hidden it in order to make my database view look cleaner: The last thing I’ll do here is add a filter to my linked view: Project contains Suit Redesign This will ensure that only tasks related to my Suit Redesign project show up. It also creates a forcing function, ensuring that new rows I add to this view will automatically be related to the Suit Redesign project! With this simple filter in place, my Project page works just like a List in Todoist (or any other task management app). Database Templates Pages inside a Notion database act just like normal Notion pages – they give you a blank canvas on which you can add any combination of blocks. But you won’t always want to start from scratch; sometimes, you’ll want to have a common starting point for certain pages in a database. That’s where database templates come in. By creating templates in your database, you can automatically generate any page content you want with just one click. Templates can be as simple or as complex as you want them to be. Here’s a very simple template within my Movies database: …and here’s the comprehensive Content Project Template that I use for all of my YouTube videos. In one click, it generates a task list, shot list, script page, research area, multiple checklists, and more: Note how it also sets default values on some of my database’s properties – including the Status, Channel, and #No properties. If you’re a content creator, you can get access to this template – along with a whole suite of dashboards and tools to aid your creation process – in my Creator’s Companion template. It’s the exact system I use to run my YouTube channels and blogs (including this one). When you have a template created within a database, you’ll see an option to use it whenever you create a new page in that database and open and open it: You can also create a page from an existing template by clicking the arrow next to the blue New button in your database’s top-right corner, then selecting a template: How to Create a Database Template You can create a new template by clicking the arrow next to the blue New button in the top-right corner of your database, then clicking New Template. From there, you can add any content you want to the template. You can also set default values in properties, which will be applied to any new page that you generate from the template. Default Templates After you’ve create a database template, you can choose to have that template automatically applied to any new pages you create. You can do this in two different ways: Set the template to be applied only on new pages in the current database view Set the template to be applied on pages created in all views of the database To set a template as a default, click the blue arrow next to the New button and find your template. Then click the ••• menu next to the template and choose Set as Default. Once done, you’ll see the options I mentioned above: Choose “For all views” if you want the template to be applied in all views of the database (i.e. it will always be applied). Choose “Only on…” if you want the template to only be applied on the current view of the database. Self-Referential Filters One of the most useful things you can do with a database template is to combine it with a Linked Database and set up what’s called a self-referential filter. If you wanted to create a database template inside a Projects database, which shows all the tasks related to the current project, you’d use a self-referential filter for that. Note: Self-referential filters are tools for Notion power users. You should be familiar with Relations and Linked Databases before worrying about them. A self-referential filter is a filter inside a database template that updates itself when you create a new page from that database template. Specifically, a self-referential filter: Is set on a Linked Database that is placed within a database template. Filters a Relation property, which targets the database that contains the database template. Targets the database template itself. Essentially, a self-referential filter helps you filter a linked database view so that it only shows rows that are related to the page that contains that linked database. When you set it up in a database template, you set it to target the template itself – but when you create a page from that template, the filter updates itself! Here’s a look at one in action. Here, I’m editing the Project Template in the My Projects database. I’ve created a linked database, which points to the My Tasks source database. In the filters, I’ve set up a filter that states: Project contains Project Template This means that only rows with Project Template set in their Project Relation would show up here. Of course, filtering for Project Template wouldn’t be very helpful. It’s a template, not an actual project. But watch what happens when I create a new project – Suit Redesign – and generate its page content from the Project Template: As you can see, my filter has automatically updated itself! Now it reads: Project contains Suit Redesign Crucially, I didn’t have to edit the filter myself. That’s the beauty of a self-referential filter; it auto-updates so that it targets your current database page instead of the database template. Rollups The Rollup property type allows you to pull property information from any rows that are connected to your current row through a Relation. You can also perform calculations on that information. To create a Rollup, add a new property just as you’d do for all other property types. Then set the Relation, Property, and Calculate options (explained below). Here, I have a Rollup called Undone Count in the My Projects database. It’s configured to show the state of the Done property for each of the rows that are related to my Suit Redesign row: See how the Rollup essentially allows me to pull information about the properties in these related rows? Not only that, but it collects this information in a single area; in other words, the information is “rolled up”! Rollups have three configuration options: Relation – the Relation property in your current database that you’d like to “reach through” Property – the Property in the database where the other side of the Relation exists (e.g. my Tasks Relation points to the My Tasks database, so it’s targeting the Done property of the rows there) Calculate – the way in which you’d like to display the information By default, Rollups will use the Show Original setting within the Calculate dropdown. However, you’ll find lots of other choices depending on the property type that you’re rolling up. If I set Calculate to Unchecked, I get a count totaling all the unchecked rows related to this project. In this case, both of the related tasks have been done, so the count is 0. Formulas Learn even more about formulas in my comprehensive Notion formula reference guide. Or, if you’re short on time, check out my one-page Notion formula cheat sheet. The Formula property type allows you to write formulas that can: Pull in data from other properties Format and change data Do complex calculations Run if-then scenarios with multiple potential outcomes Notion’s formula property is by far its most complex, and there’s essentially no limit to what you can do with it. Fun fact: My Ultimate Brain template contains a 10,000-character formula that does complex recurring-date calculations directly in Notion! You can create a formula property in Notion in the same way that you’d create any other property. From there, you can click the property’s content area to open up an editor where you can write formula code: Underneath the editor, you’ll find a list of properties, functions, and more that you can use to create your formula. These include: Properties – includes all the properties in your current database Constants – such as e, pi, true, false Operators – if, add, subtract, greater than, less than, etc. Functions – join, slice, format, toNumber, etc. Since this is an overall guide to Notion databases, I won’t delve too deeply into how to write formulas here – check out the full formula reference guide for that. For this post, I’ll share two example formulas and explanations that will help you get started with writing your own formulas. Both of these can be found in the Simple Task Manager example template! Formula Example 1: Combine Numbers and Text The first formula we’ll cover can be found in the My Projects database within the Simple Task Manager template. The property is called Meta, and it simply takes the number from the Undone Count property and formats it to look nicer. Here’s the “compact” version of the formula that you can easily paste into Notion: format(prop(\"Undone Count\")) + \" Tasks Left\" Note: If you paste this formula into a brand-new Notion database, you’ll need the Undone Count property to exist first. Otherwise, you’ll get a Property Not Found error. I prefer to write my formulas in a code editor (such as VS Code) and then make them compact using this Excel Formula Beautifier (which can either “beautify” code or compress it). As the name implies, it’s meant for Excel formulas – but it works perfectly on Notion formulas as well. In fact, Notion’s formula syntax is extremely similar to Excel’s formula syntax. Here’s a version of the formula that’s easier to read: format( prop(\"Undone Count\") ) + \" Tasks Left\" The first part of this formula is: format(prop(\"Undone Count\")). It uses the prop() function to pull in the value of the Undone Count property, which is a Rollup (see the Rollup section above to learn more about those). I’m wrapping prop(\"Undone Count\") within the format() function in order to turn it into a String (which is basically just text). Notion formulas can output four different data types: String (plain text) Number Date Boolean (true/false, shown as a checkbox) However, a single formula can only output one data type. In other words, you can’t mix data types. Instead, you need to convert data types so that all of your output has the same type. The Undone Count Rollup property outputs a number, but ultimately my formula needs to output a string – e.g. “3 Tasks Left”. To achieve that, I use format() to transform that number into a string. It still displays as a number, but since it’s a plain-text string now, it can no longer be used in calculations (addition, multiplication, etc). Finally, I use the + operator to add my formatted number to this string: Tasks Left. Put them together, and you achieve a data-driven final output, such as: 3 Tasks Left! Formula Example 2: If-Then Statement Next, let’s look at how you can create variable output in a formula by using an If-Then statement. In the My Tasks database within the Simple Task Manager, I’ve created a formula property called State. This property outputs a different symbol based on the status of the task: ⏰ = task is overdue 😁 = task is done 🟢 = task is due today or later Here’s the compressed formula code, which you can easily paste into Notion: if(prop(\"Done\") == true, \"😁\", if(dateBetween(now(), prop(\"Due\"), \"days\") > 0, \"⏰\", \"🟢\")) Note: If you paste this formula into a brand-new Notion database, you’ll need the Done and Due properties to exist first. Otherwise, you’ll get a Property Not Found error. And here’s an expanded version of the formula that’s easier to read: if( prop(\"Done\") == true, \"😁\", if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"⏰\", \"🟢\" ) ) This formula has an if-then statement with another if-then statement nested inside it. By nesting if-then statements, we can create a formula that has more than two possible outcomes. To help you fully understand this formula, let’s first break down how if-then statements work. The basic syntax for an if-then statement in Notion is: if([test condition],[outcome if true],[outcome if false]) Essentially, we run a test, then define what do to if that test passes, and what do to if it fails. Here’s a bare-bones example: if(prop(\"Done\") == true,\"😁\",\"😡\") The == operator is testing whether the two pieces of information on either side of it are the same. Done is a checkbox property (with the data type boolean), so it outputs true or false. If the output of Done matches true, then the first option will be output: 😁. If not, Notion will output the second: 😡. Here’s where things get interesting – either of the output paths in an if-then statement can contain additional functions. This can include more if-then statements! So let’s walk through the nested if-then statement from our example above: if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"⏰\", \"🟢\" ) This statement will only be evaluated if the outermost if-then statement – if(prop(\"Done\") == true – returned false. This inner if-then statement tests to see whether the task is overdue or not. To do that, it uses the dateBetween() function, which finds the amount of time between two dates. I’m passing three arguments to this function: The now() function, which is built into Notion and returns the current date and time prop(\"Due\"), which returns the task’s due date \"days\", which simply specifies the unit of time dateBetween() should count by Finally, I check if the output of dateBetween() is greater than (>) zero. If it is, then the task is overdue and my formula outputs the ⏰ symbol. If not, the task is not overdue and the formula outputs the 🟢 symbol. As you can see, Notion formulas are extremely flexible and powerful. It’s also worth noting that practicing with Notion formulas is a good first step into actual programming if that’s something that interests you! Locking Databases Databases can take a long time to configure, and chaos can ensue if someone accidentally deletes a property, changes the settings of a view, or messes with a formula. Fortunately, Notion allows you to lock your databases in order to prevent these kinds of changes. To lock a database, first navigate to its original location. Open up the View Options menu and click Lock Database: When a database is locked, you won’t be able to make changes to its structure. You’ll still be able to create new rows and set property values, but you won’t be able to: Add new properties Delete properties Change property settings (e.g. change a formula) Add/edit/delete options from a Select or Multi-Select property Fortunately, if you need to make a change, you can easily unlock the database by clicking the Locked button at the top. Note that you’ll need to navigate to the original database to find this Locked button; you won’t see it on Linked Databases. Wrapping Up Whew – we’re done. In this guide, we’ve covered every main feature you’ll find within Notion databases. You’re now ready to go out and start creating your own databases. Using the features we’ve covered here, you’ll be able to create useful tools that fit your individual workflows and tasks like a glove – rather than relying on old-school productivity tools that don’t quite match the way you want to work. To learn even more about Notion, head to the Notion Fundamentals home page to check out all the lessons in this free series. You can also check out my Notion Templates, which can give you a head start and equip your workspace with an advanced task manager, note-taking system, habit tracker, and more. If you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-databases-the-ultimate-beginners-guide","title":"Notion Databases: The Ultimate Beginner’s Guide","date":"2022-06-03T16:37:44+00:00","contentLength":8787}},{"pageContent":"If you plan your YouTube content in Notion, you might be wondering if you can bring the stats from your published videos back into Notion. Wouldn’t it be cool if you could display your live view counts, likes, and other data right on your Notion dashboard? What if you could pull in your thumbnails and use them as your page covers in Notion? What if you could do it without writing any code? Well, wonder no more – all of this is possible! In this tutorial, I’ll show you exactly how you can automatically bring YouTube data into Notion, just like this: Here you can see my list of published videos on my Thomas Frank Explains channel (within my copy of Creator’s Companion). For each video, I have an updated count for views, likes, and comments – pulled directly from YouTube. My page covers are also set using my actual YouTube thumbnails. In this tutorial, I’ll show you the exact, step-by-step instructions for pulling YouTube data into Notion yourself and achieving this exact result. Specifically, we’ll be pulling the following data from YouTube (per-video): Views Likes Comments Publish Date Thumbnail Best of all, you can build this automation for free, for a limited number of videos (see the section on cost considerations for full details). Additionally, you can do it without any coding. This is a 100% no-code tutorial. Choose your adventure: The video above shows this entire process step-by-step, as does the written version below! What You’ll Need to Get Started To successfully finish this tutorial, you’ll need three things (I’ll show you how to get all of these, step-by-step): A Make.com account – this is the automation builder we’ll be using to accomplish everything without writing code. A Google Cloud account – you’ll use this to interact with the YouTube Data API. A Notion database that contains YouTube video URLs If you already have a Notion database with your own video URLs, you can use that. However, if you’d like a sample database that you can use for practice, you can use this sample template. Just duplicate it into your workspace and you’ll be ready to go. Before we move on, I’ll note that if you are a serious creator and want a complete Notion system for tracking all of your content, you should check out Creator’s Companion: Recommended Creator's Companion: The Ultimate Creator Template Want a complete system for all of your channels, blogs, and social media accounts? Creator's Companion is the exact system my team and I use to manager our entire content creation process across all of our channels. Learn More This is the exact template that my team and I use to manage all of our content creation efforts across my YouTube channels and blogs. It allows you to manage the entire creation process, and includes dashboards for: Content calendar (across all channels and mediums) Idea capture Research and scripting B-roll and shot lists Publishing checklist The template also includes access to an active support community, so you can get help with any technical questions you have. I’ve updated our own copy of Creator’s Companion to pull in live YouTube stats, which allows us to compare our predictions with actual video performance. If you do have Creator’s Companion, you’ll be able to use this tutorial to do the same thing with your YouTube stats! What You’ll Learn in This Tutorial While this tutorial is primarily intended to help you send YouTube data to Notion, it will also help you learn more about some useful concepts and tools: Notion databases APIs JSON Make.com and no-code automation Once you’ve worked your way through this tutorial, you’ll be able to use these tools and concepts to do a lot more. You’ll understand how to make countless different apps and services talk to each other, enabling you to build tools that don’t exist yet (without coding). Note: I don’t assume any prior knowledge of JSON, APIs, or Make.com in this tutorial. If you can follow instructions, you’ll be able to complete this tutorial. I do, however, assume some prior knowledge of Notion databases. If you need a refresher on those, check out my full beginner’s guide to Notion databases. If you do have prior experience with JSON, APIs, or Make.com, then you can go ahead and skip to the next section and start building right away. If not, fear not! I’m going to briefly explain each of these concepts here in this section, and I’ll also link you to some useful resources you can use to learn more about each. What is JSON? JSON is a super-flexible, super-useful format for transmitting data between computers. It also happens to be the most important technology that powers Notion. In fact, if you’re ever hanging out with me and we’ve had enough drinks, you’ll probably hear me call Notion a “fancy graphical wrapper for JSON”, because that’s basically what it is. But JSON doesn’t just power Notion; it’s also the data storage format that nearly every API in the world uses. It’s flexible, widely-used, and easy to understand. JSON stands for JavaScript Object Notation. Here’s an example piece of JSON data (which is real data returned by the YouTube Data API): { \"statistics\": { \"viewCount\": \"158907\", \"likeCount\": \"5947\", \"favoriteCount\": \"0\", \"commentCount\": \"241\" } } JSON is built on key:value pairs. An example from the snippet above would be \"viewCount\": \"158907\". \"viewCount\" is the key, and \"158907\" is the value that it points to (which is a string; more on that below the next code example). All JSON data is contained within objects, which are represented by the curly braces ({}). An object is simply an unordered set of key:value pairs. As you can probably tell, the value that corresponds to a key can actually be an object itself! The statistics key corresponds to an object, which itself contains more key:value pairs. Let’s look at a slightly more complex example, which also comes directly from the YouTube Data API: { \"snippet\": { \"publishedAt\": \"2022-08-12T22:27:41Z\", \"channelId\": \"UCd_WBvzBg1UbHE8j8MIL5Ng\", \"title\": \"10 New Notion Features You Need to Know About!\", \"thumbnails\": { \"default\": { \"url\": \"https://i.ytimg.com/vi/61a1Edq4iBo/default.jpg\", \"width\": 120, \"height\": 90 }, \"medium\": { \"url\": \"https://i.ytimg.com/vi/61a1Edq4iBo/mqdefault.jpg\", \"width\": 320, \"height\": 180 }, \"high\": { \"url\": \"https://i.ytimg.com/vi/61a1Edq4iBo/hqdefault.jpg\", \"width\": 480, \"height\": 360 } }, \"channelTitle\": \"Thomas Frank Explains\", \"tags\": [ \"notion\", \"notionhq\", \"notion app\" ], \"categoryId\": \"27\" } } This block might look intimidating, but in reality it’s just more of the same thing I shared above. There are more nested levels, and there a couple new elements in the mix. Let’s first talk about data types. Check out this line: \"title\": \"10 New Notion Features You Need to Know About!\" Since the \"title\" key’s value is in quotation marks, we know that the value has the string data type. JSON values have one of six different data types: string number Boolean (true/false) empty/null object array We can see another key:value pair in the JSON snippet above: \"width\": 120. This value has the number data type. Boolean values must either contain true or false, without quotation marks. Empty/null values must contain null without quotation marks. We already covered objects, so that just leaves arrays. An array is an ordered list of values. Array values are stored within brackets ([]), and each element is given a number based its position in the array. The number is essentially the key for each value, but it is not explicitly written into the array. It is implied based on the ordering of the elements in the array. We can see an array within the YouTube snippet above: \"tags\": [ \"notion\", \"notionhq\", \"notion app\" ] This array contains strings, but an array can contain data of any type – numbers, objects, even nested arrays. Array numbering starts at 0; this is called zero-based indexing. So the string \"notion\" has an index of 0, the string \"notionhq\" has an index of 1, and so on. This introduction is all you’ll really need to understand the JSON we’ll be looking at in this tutorial. However, if you’d like to learn more, I recommend watching this video: What is an API? An API is essentially a set of tools that let web applications talk to each other. APIs are what allow: Social media scheduling tools like Buffer to post tweets to Twitter Notion to integrate with other tools like Github and Slack Connector tools like Make.com and Zapier to let you build custom connections between web apps API stands for Application Programming Interface. When a web app publishes an API, it is basically providing outside entities with a set of tools they can use to read and/or manipulate data stored on that web app. If you’re not a coder, you almost never have to think about APIs. They just do their thing in the background, shuttling data back and forth between apps that you use. Even if you use tools like Make.com, Zapier, IFTTT, etc. – usually the guts of the APIs you’re working with are hidden from you. These tools have built integrations that are set up to work with the APIs of the web apps they support, so usually all you need to do is set the options you want. However, in this tutorial, we’ll be working directly with the YouTube Data API. For that reason, it will be helpful if you understand a few key concepts about APIs and how they work. Note: This is a non-comprehensive, purposefully simplified explanation of APIs intended for non-coders. I’m probably leaving a lot out, but I’ll link to more comprehensive resources at the end of this section. You typically work with APIs by making HTTP requests. This means that your application (in the case of this tutorial, the Make.com automation we’ll be building), accesses a particular URL – much like you’d do in your web browser when you want to visit a website! Note: You may have a conversation in the future about APIs with a nerd who will stress that you access URIs, not URLs. The distinction really does not matter here, but here’s an article on their differences if you’re curious. Your request typically needs four pieces of data: The endpoint to be accessed The method to be used A query string containing the details of your request An API key for authentication Let’s look at an example. The YouTube Data API features many different endpoints (e.g. sets of tools) for working with YouTube data. Note: Remember that this section is a primer; follow the actual tutorial to see all of these concepts in action! One of those endpoints is called Videos: list. It contains a set of methods meant for getting information about one or more videos – including view counts, upload date, and more. If you read the JSON summary above, the JSON code snippets you saw were returned by Videos: list. Looking at the Videos: list reference page, we can see a Request section which specifies the HTTP request needed to access this endpoint: GET https://www.googleapis.com/youtube/v3/videos This means that your application has to make a request to https://www.googleapis.com/youtube/v3/videos in order to access information about YouTube videos using this endpoint. The section also specifies the method that must be used to interact with this endpoint: GET. There are five common methods we use to interact with API endpoints: GET – used for reading data from the application. It is read-only, so it has no risk of modifying any data. POST – sends data to the application to create something new. PUT – sends data to the application to update an existing resource. Contains a full updated copy of the resource. PATCH – also updates an existing resource, but only contains the changes to be made instead of the entire updated resource. DELETE – sends an instruction to the application to delete an existing resource. Videos: list is an endpoint that relays information about existing videos, so it makes sense that it requires the GET method. One cool thing about endpoints that use GET – you can usually call them directly from your browser! And when doing so, you don’t even need to specify “GET” – you can just call the endpoint URL itself. I’ve done this in the screenshot below, using Videos: list to pull information about this video. The YouTube Data API’s response (in JSON) when I called Videos: list to get information about my video. The blurred section of the URL contains my private API key. Here you can see a JSON response that looks very similar to the one shown above in the JSON primer. Calling this method in the browser is mainly only useful for demonstration and learning purposes; typically, you’d want to call it from within an application that will then manipulate the data (as we’ll do later in this tutorial). What I’d like to point out here, though, is the URL itself: https://youtube.googleapis.com/youtube/v3/videos?part=snippet&id=61a1Edq4iBo&key=[MY_API_KEY] This URL contains the two components we haven’t covered yet: The query string and the API key. I’ve removed my API key for security purposes. API keys should always be kept private. Anyone with access to your API key could access an API essentially posing as you, accessing information that should be only available to you or taking actions on your behalf. Let’s cover the query string first. This is essentially a set of instructions that tells the endpoint what we want. In this case, our query string is as follows: part=snippet&id=61a1Edq4iBo&key=[MY_API_KEY] This query string contains three details: part=snippet – this tells Videos: list that we want the snippet for this video (which contains things like the publish date, title, description, etc.) id=61a1Edq4iBo – this is the id of the video we want information about. The id can be found in the video’s URL: https://www.youtube.com/watch?v=61a1Edq4iBo key=[MY_API_KEY] – this passes my API key as part of the request. Without a valid API key, I’ll get a “permission denied” error instead of the information I want. Error response from the YouTube Data API after I pass it a query string where the key value is “nothing”. So how do I know what to put in my query string? Simple: I check the API documentation. Nearly every API you’ll encounter has documentation you can reference, which specifies the endpoints, methods, and more. Google’s API docs are particularly helpful becuase they feature a “Try This Method” tool for each method. Check out the Videos: list page to try it for yourself! After expanding the “Try This Method” box so it takes up more of the screen, I get this screen: See how this actually helps me to build my query string? In the part field, I specify that I want the snippet. The available options are listed in the method’s documentation. In the id field, I specify the id of the video I want information about. After executing the request, I can see the actually HTTP request in the HTTP tab. Finally, I can see the JSON response, along with the code 200, which indicates a successful response (400 would indicate failure). Of course, for this API request to be successful, I have to provide an API key. The “Try This Method” box makes this easy; when you click Execute, the Google API Explorer will ask you to log in with your YouTube account. It will then execute the request without you needing to specify your own specific API key – it provides one behind the scenes. This makes trying out API methods very easy. When you’re actually building automations, you’ll need to provide your own API key or otherwise authenticate yourself. This will be handled differently depending on the API you’re trying to access. Some APIs will give you a single key; others may provide both a client ID and a secret key. Some applications will also require you to work through the OAuth protocol instead of merely providing an API key. Each API will typically provide details on authentication in its documentation. Here are a couple of examples: YouTube API authentication documentation Notion API authentication documentation Note: When working with no-code automation tools like Make.com, typically the automation builder will handle all of this authentication for you. However, when you need to work with an unsupported tool (such as the YouTube API), you’ll need to use the generic HTTP Request modules they provide – and at that point, you’ll need to provide your API key manually. I believe I’ve provided enough of an introduction here to serve the purposes of this tutorial and other no-code use cases you may have. However, if you’d like to learn more about APIs, check out these resources. First, Fireship has a great (and quick) intro video on APIs: If you want to go even deeper, freeCodeCamp has a wonderfully comprehensive video that will guide you through an entire code-based project: As a non-coder, I’ve always been intimidated by APIs because most tutorials that cover them do so while assuming a certain level of coding knowledge. It actually wasn’t until I started working with them through no-code tools like Make.com that I started to truly understand how they work. So if you’re a non-coder and want to understand APIs more deeply, let’s continue on with this YouTube-to-Notion automation project! What is Make.com? Make.com is what I call an automation builder. It’s a web app that gives you a visual interface for connecting other web apps together in order to build custom workflows. There are many other automation builders: Zapier IFTTT n8n NoCodeAPI Bardeen I prefer Make.com simply because I’ve found that it has a good combination of power, supported apps, ease-of-use, and price. Best for No-Coders Make.com My favorite no-code automation builder that can create workflows between hundreds of apps. Has a bit of a learning curve, but it significantly more powerful (and cheaper) than Zapier. Has a great free tier too. Sign Up for Free I'll earn a commission if you sign up through this link and upgrade to a paid account (at no extra cost to you). Here’s a look at Make’s visual builder interface. In this simple automation, new tasks created in Todoist are sent to a Notion database: When working with Make’s supported apps, you’ll get pre-made fields that you can use to easily customize your workflows: This makes creating complex automations very easy! Without tools like Make, you’d have to code your own web application, connect to both APIs (Todoist and Notion) manually, and run the app on a server constantly. Automations can also be significantly more complex than the example above. They can have branching paths, filters, and loops. They can work with complex data, like arrays. Best of all, Make gives you a general-purpose HTTP module (shown above), which you can use to connect to APIs that aren’t already supported by Make. The best way to learn Make (and any other automation builder) is to build something with it, so let’s continue with the tutorial! If you feel confident, let’s start building this automation! Tutorial Summary & Overview Before we dive straight into the details, let’s take a look at the process from a bird’s eye view so you know what you’re working towards. The Goal: Create a no-code automation that brings views, likes, and comments from your YouTube videos into a Notion database on a regular basis. Additionally, pull data from YouTube to set each video’s publish date and page cover (using the video’s thumbnail). To accomplish this, we’ll work through the following steps: Set up a Notion database with video URLs and video IDs (the latter generated using a simple formula). Obtain an API key from Google so we can work with the YouTube Data API (in a read-only manner). Create an automation on Make.com that sends YouTube video data to Notion. Here’s what our Make.com automation will do, specifically: Pull a list of video IDs from Notion Query the YouTube Data API using those video IDs Get view, like, and comments counts, thumbnail URL, and video publish date from the YouTube Data API for each video Send all of this data back to Notion Prepare Your Notion Database Estimated Completion Time: 10-15 Minutes The first step we’ll take is preparing a Notion database that contains the videos we want to track. The steps I’ll demonstrate below will work on any Notion database. You do not need to be using any specific template. In this step, you’ll: Identify the Notion database you want to use for tracking Ensure it contains a list of YouTube videos with live YouTube URLs Add properties for views, likes, comments, and publish date (if needed) Add a formula property that extracts the video ID from each video’s URL Note: If you want to learn more about Notion databases or need a refresher, check out my complete guide to Notion databases. I’m going to use a public demo version of my Creator’s Companion template, which means you’ll be able to visit it and see a working example. If you have Creator’s Companion, you can simply follow along with the steps I’ll demonstrate here. If not, simply apply the same steps to your custom database. If you’d like a simple starting point, grab my free example template and then skip to the next section of the tutorial: This example template already has all of the properties we’ll be creating, and it also contains a “finished” copy of the pictured database that has sample data, publish dates, and thumbnails already filled in. Even if you’re not using this template, you may want to reference it. Step 1: Add YouTube Video URLs to the Database Create or navigate to a Notion database in your workspace that will be use for tracking your YouTube video stats. Since I’m building this in Creator’s Companion, I’m going to be using its Master Content Tracker database, which is the template’s central database for all content. Creator’s Companion uses linked databases to show useful filtered versions of this database within each Channel page. I’ll go into the Channel page for my Thomas Frank Explains YouTube channel and navigate to the Completed Projects section, as I want to track stats for completed, published videos. From here, the crucial part is making sure I have a record for each video I want to track. As you can see, I’ve now got a row for each published video on my channel. Remember, you can view this public demo page yourself to see how everything works! Step 2: Create the Database Properties If your database does not already have them, create the following five properties. Ensure their property types are as list here. Property Name Type Views Number Likes Number Comments Number Publish Date Date URL URL Note: If you are unable to create new properties, your database is likely locked. Here’s how to lock/unlock any database (as long as you have full access to it). If you’re using Creator’s Companion, follow these steps to find your database’s location and unlock it. Step 3: Add YouTube Video URLs If you haven’t done so already, add the correct YouTube URL for each video to your Notion database. Each video should be public, or at least unlisted. Private video URLs will not work, as we’ll only be working with public YouTube data in this tutorial. Step 4: Create the “YT ID” Formula Property Next, create a Formula-type property and name it YT ID. This property will extract each video’s ID from its URL. Check out my guide on creating formula properties if you need help with this. Paste the following formula code into the formula editor: if(test(prop(\"URL\"), \"youtu.be\"), replace(prop(\"URL\"), \"^.*(?:\\\\.be)/([^?&]*)\\\\?*.*\", \"$1\"), replace(prop(\"URL\"), \"^.*(?:\\\\?v=|shorts/)([^?&]*)\\\\?*.*\", \"$1\")) How this formula works Curious about how this formula works? I’ll break it down for you here. This formula uses the replace() function, which takes in an input string, looks for a sub-string within it, and then replaces that sub-string with a provided replacement string. It also uses the if() function to determine if the URL is one of YouTube’s shortened “share” links. If it is, we use a different replace() call than if it isn’t. Here’s a super-simple example of replace() that’s easy to understand: replace(\"The best Ninja Turtle is Raphael.\", \"Raphael\", \"Donatello\") // Output: The best Ninja Turtle is Donatello. However, replace() gets much more useful when you use regular expressions in the second argument. A regular expression is a string of special characters that can make your matching criteria much more flexible. I’ve written a very detailed guide on regular expressions in Notion formulas, so I won’t cover all their details here. Instead, I’ll simply break down one of the regular expressions used in the YT ID formula. Here it is: replace(prop(\"URL\"), \"^.*(?:\\\\?v=|shorts/)([^?&]*)\\\\?*.*\", \"$1\") The second argument contains the regular expression: ^.*(?:\\\\?v=|shorts/)([^?&]*)\\\\?*.* Here’s the plain-English version of what this expression is doing: Match the entire input string. After the first instance of either ?v= or shorts/, take all the characters and capture them up until the first instance of a ? character, if it exists. Finally, replace the match (which is the entire input string) with the contents of the capture group. This is the best way to extract a small piece of a string and output it within a Notion formula. Here’s how our regular expression does it: ^ used at the start of the expression means, “The match must start from the beginning of the input string.” . is a special character which means “match any character (except new lines)”. * is a quantifier, which tells the regex engine to match zero or more of the preceding element – in this case, the . (?:) indicates a non-capturing group. It’s a group of characters that the regex engine won’t keep in memory for later reference. \\\\? matches the ? character. Since ? is used as a special character (e.g. (?:)), we have to escape it to tell the regex engine that we want to match an actual ? character. The pipe (|) character indicates either/or. So the engine can match either ?v= or shorts/ in this non-capturing group. () is a capturing group. The regex engine will capture any text in this group and allow us to reference it later. [^?&]* equates to “match any number of characters that aren’t ? or &“. [] defines a character class, and within the brackets, the ^ means “not”. //?*.* helps us avoid capturing any query strings that might come after the video id in the URL. Capture groups are given a number by default – much like items in an array automatically have number references. Our third and final argument within the replace() function is $1. The dollar sign ($) is a special character that tells the regex engine to reference a capture group, and the 1 tells it to reference the first capture group. Of course, we only have one capture group in this example! Using this formula, we’re able to extract the video’s ID out of its URL. We can then pass that ID to the YouTube API later in the tutorial. Note: You could also do this part on Make.com, as it comes with a regex-enabled text parser tool. I prefer to do it directly in Notion. If you’d like to learn more, check out my comprehensive Notion formula reference guide. It’s a complete technical reference for Notion formulas. Specifically, you should check out: The replace formula Regular expressions in Notion Formulas If you want to push your formula knowledge even further and learn how to solve complex, real-world problems using Notion formulas, check out my 14-day Notion Formula Bootcamp. At this point, your Notion database is prepped and ready to go! Get Your YouTube Data API Key Estimated Completion Time: 5 Minutes The next thing we’ll need is an API key from Google that will allow us to interact with the YouTube Data API. Using it, we’ll be able to send Video IDs from our Notion database to the API, and get back each video’s publish date, statistics, thumbnail image, and more. In this step, you’ll: Enable Google Cloud on your Google account Create a project Enable the YouTube Data API for that project Obtain an API key Restrict the key so it can only be used via Make.com To get started, head to the Google Cloud Developer Console. Note: Google Cloud is a vast resource that includes access to database tools, APIs, AI tools, and a lot more. Any time you want to work with a Google-owned API (such as the YouTube Data API), you’ll go through Google Cloud. You’ll need to be signed into your Google account. If your account hasn’t already activated Google Cloud, you’ll be asked to do so before you can start accessing API features. Next, we’ll create a project. This is necessary for enabling access to Google APIs and getting an API key. Click Select Project near the top of the screen. Click New Project. If you don’t see “Select a Project” at the of the screen, click APIs & Services on the lefthand sidebar. You’ll be prompted to create a project there if you don’t already have one. Give you project a name. Click Create. Note: This will work seamlessly if you’re using a personal Google/Gmail account. If you’re logged in with a work account through Google Workspace, then your organization’s Workspace account will need to be active. Additionally, your organization admin may need to give you account the ability to create new projects. Open the navigation menu Choose APIs & Services, then Enabled APIs & services. Near the top of the screen, click Enable APIs and Services. From the API Library, search for youtube data api v3. Click YouTube Data Api v3 from the search results. It should be the only option. Click Enable to enable access to this API from your account. The YouTube Data API is now enabled on your account, but you’ll still need an API key to work with it. From the navigation menu, click Credentials. Click Create Credentials near the top of the screen. Choose API key. We’re not building a user-facing application, so there’s no need to worry about the dialogue that mentions configuring an OAuth consent screen. An API key will be created for you. I’ve blurred mine here for security; copy yours for later use, but don’t share it with anyone else. For extra security, we’ll also restrict what this key can be used for. Click Edit API key. You can leave Application Restrictions set to None. However, we do want to set up some API Restrictions. Under API Restrictions, choose Restrict key. Search for and select YouTube Data API v3. Click Save. Note: These restrictions are just for extra security. As long as you don’t share your key, no one else will be able to use it. However, in the event that it is shared, these restrictions limit what it’s able to do. Now that you’ve set up your API key and ensured it has access to the YouTube Data API, we can move onto the next step! For easy re-access, I recommend bookmarking Google Cloud so you can come back and fetch your API key whenever you need. Build the Make.com Automation Estimated Completion Time: 15-20 Minutes The final step in this process is to create a no-code automation that will get data about each video from the YouTube API and send it to the correct database row in Notion. To accomplish this without coding, we’ll be using Make.com, which is my favorite no-code automation builder. If you don’t already have an account, you can sign up for free here: Best for No-Coders Make.com My favorite no-code automation builder that can create workflows between hundreds of apps. Has a bit of a learning curve, but it significantly more powerful (and cheaper) than Zapier. Has a great free tier too. Sign Up for Free I'll earn a commission if you sign up through this link and upgrade to a paid account (at no extra cost to you). In this step, you’ll: Create a Make.com account (if you don’t already have one). Decide how to optimize your automation for update-frequency and cost (it can be done for free, but with limits). Build your automation visually using the Scenario builder. Enable your automation and set it to run on a schedule. During the build process, you’ll do the following: Query your Notion database to get a list of video IDs Send those video IDs to the YouTube API Get information about each video, including view, like, and comment count, publish date, and thumbnail URL Update each video’s stats in Notion Set each Notion page’s cover to that video’s public thumbnail Let’s get started! Step 1: Create a Make.com Account If you don’t have a Make.com account, let’s create one. Enter your new account details. Click the verification link sent to your email in order to enable the account. Once you’ve got your account set up, you can go to Scenarios to start building your automation. Skip down to step 2 of this section to start doing that. However, I’d recommend first clicking the Free button under Subscription to review the features and limitations of Make.com’s free account: Make.com Pricing and Cost Considerations Using Make.com, this tutorial can be completed for free! Why not Zapier? A significant reason we’re not using Zapier for this tutorial is that multi-step workflows are only available on their paid plans (which are also much more expensive than the paid plans of other platforms). Note: I’ll note that I actually use Make.com and Zapier for different purposes, so I have experience with both platforms. Make.com’s learning curve is significantly higher, but the platform is also more powerful. As I’ve continued to learn more about Make.com and how to use it, I’ve found myself moving automations from Zapier to it. By contrast, Make.com allows you to create workflows with as many steps as you need, even on the free plan. Another reason is that Zapier’s Notion integration is not as powerful, and since the Notion API’s launch, Zapier has been much slower to update their integration than other platforms like Make.com and n8n. However, it’s important to understant that Make.com has limits on how much you can do on its free plan. This is true of all automation builders (the one exception I know of is n8n, but only if you self-host it on your own server or computer). The most important limitation to understand is Make’s operation limit. On the free plan, you’re limited to 1,000 operations per month. If you upgrade to the $9/mo Core plan (the one I use), that goes up to 10,000 operations per month. Once you’re on a paid plan, you can increase that number for an additional fee (20,000/mo, 40,000/mo, and so on). Here’s how these limits apply to the automation we’re building here: To query the YouTube API and send data to Notion, it takes 2 operations per video each time you run your scenario. It also takes 2 operations per video to set your Notion page cover using your YouTube thumbnail, though this only needs to be done once per video (and you can simply skip this part if you’re ok uploading page covers manually). Finally, it takes 1 operation to query your Notion database (to get the list of Video IDs) each time you run your scenario. Since setting the thumbnail only needs to happen once, I consider this automation to cost 2n+1 operations, where n is the number of videos you’re tracking. If you’re tracking 50 videos, thats means each run of your automation will cost 101 operations. With 1,000 operations/mo to play with on the free plan, that means you could run the scenario 9 times per month before running out. Given this limitation, here are a few options: Schedule your stats to be updated once a week. That equates to roughly 4 times a month, which should be fine for sitting down and reviewing content performance on a regular basis. Add a “Track” checkbox to your database, manually select the videos you want to track, and set the automation to only track those videos. Upgrade to Make.com’s paid plan to increase your operation limit to 10,000/mo. I’ll leave that up to you to decide! Can this process be made cheaper? Yes! But you’ll need some coding knowledge. The ever-present trade-off when using no-code platforms is that they cost more to use than simply building apps and hooking into APIs yourself. But they’re far cheaper than hiring a developer, and they allow you to build amazing things without coding knowledge! The closer you get to actually coding, the cheaper you can generally make things on an ongoing basis. If you have some familiarity with JavaScript or Python, this automation can be set up and run much more cheaply using Pipedream. On their free plan, you’d be able to build the automation shown in this tutorial and run it multiple times a day (even for hundreds of videos). Unlike Make and Zapier, Pipedream is a low-code automation builder. While it has built-in integrations for hundreds of apps and will allow you to set up no-code workflows, the majority of its power lies in the fact that you can add NodeJS or Python modules within your workflows. However, unlike Make.com, Pipedream does not include built-in no-code tools for parsing JSON or looping over arrays. This means that their no-code integrations can do very simple things (such as updating a single Notion database page), but once you want to do more, you need to have some basic/intermediate programming skills. Here’s a look at one step in my automation: Pipedream requires some knowledge of programming in order to be truly useful. I’ve started to learn Pipedream, and currently have a working version of this tutorial’s automation that uses JavaScript and works directly with the Notion and YouTube Data APIs. However, I still need to scale it so that it can handle databases with more than 50 videos – unlike Make, Pipedream doesn’t handle pagination or rate-limiting automatically, so I have to modify my code to deal with any and all scale problems. I’ll post a link to my Pipedream workflow when it’s finished. Until then, I’d recommend checking out the Pipedream quickstart guide if you want to learn how to use the platform! If you’d like to start learning JavaScript, here are some free beginner resources I recommend: JavaScript Algorithms and Data Structures on freeCodeCamp That Weird JavaScript Course by Fireship MDN Web Docs JavaScript Reference Beginner JavaScript Notes by Wes Bos Here are a few resources for learning to work directly with the APIs used in this tutorial: Notion API – official documentation Notion API – Postman (features more detailed examples) YouTube Data API – official documentation If you prefer learning with video, Traversy Media published a great video on coding with the Notion API: And here’s a video from freeCodeCamp that will show you how to work with the YouTube Data API using HTML, CSS, and JavaScript: Step 2: Build Your Make.com Scenario We’re finally ready to start building our automation. To start, click Create a New Scenario from the top of the Make.com interface. You’ll now be presented with the Make.com Scenario Editor. This is essentially a canvas where you can visually build your automation. To do that, you’ll create modules and connect them together. As a mental primer, here’s what your final scenario is going to look like: To start building that, let’s create our first module. Click the big Plus button on the screen. Search for and choose Notion from the menu of app choices. Once done, you’ll see a whole list of actions you can take from within Make.com’s Notion integration. The first thing we need to do is query your Notion database in order to get a list of the database rows that we want to send to the YouTube API. To do that, choose Search Objects. We now need to connect your Make.com account to your Notion account so the Scenario can access your Notion database. Next to Connection, click Add. Under Connection Type, choose Notion Public. Give your connection a name that you like – it doesn’t need to be anything specific. A Notion authentication window will now pop up. Ensure you’re signed into the workspace that contains your target Notion database. Click Select pages. Next, select the pages for which you’d like to grant your Make.com connection access, and click Allow Access. Important: Notion has cascading permissions, meaning child pages inherit the permissions of their parent page. Make sure your target database is contained within the page you select here (or search for it directly). Additionally, understand that your Make.com connection will have permissions to access any other pages underneath the selected page. Here, I’m adding my Creator’s Companion Demo to the permissions list. This is a standalone demo version of Creator’s Companion, so the Master Content Tracker database that I’m targeting is a child of this page. (If you have the Creator’s Companion + Ultimate Brain bundle, note that Master Content Tracker has a different location. Refer to this page if you need to reference its location.) Once you’ve done this, you can verify that Make.com has access to your target database like so: Navigate to your database’s location in Notion. Click the ••• icon in the top-left corner. Verify that Make is listed under the Connections sub-heading. Here you can see that Make has permission to read, insert, and update content within this database. Back on Make, let’s configure this module. Ensure Search Objects is set to Database Items (since we want to pull individual database items with this query). Under Database ID, click Search, and then search for the name of your database and click Ok. If you’ve given Make the correct permissions, it should pull in your database’s ID automatically. How to Find Your Database ID Manually If the Search dialogue doesn’t work correctly, you can also enter your database ID manually. Here’s how to find it. From your Notion database’s home page (not a page containing a linked database view), click the ••• menu and click Copy Link. This will copy the entire URL of your database to the clipboard. It will look something like this: https://www.notion.so/ultimatebrain/8a37b5ad471a4153921eae0aaadb2c20?v=ede300269dd444eabaac7f00542c65c4 Your database ID is the bolded portion of the snippet above – it is the string of characters after the final / character and before the ?v= characters. This means that my database’s ID is: 8a37b5ad471a4153921eae0aaadb2c20 If I paste this string directly into the Notion module in my Make.com Scenario, it’ll work perfectly. Next, we want to filter our query so we only pull database rows where the URL field is filled with a youtube.com URL. To do that, set up a filter: URL (URL) Contains youtube.com Additionally, you can set a limit for the query. Set this number high enough that it’ll fetch all the videos you want to track. Note: The Notion API limits database queries to 100 rows at a time. In order to an integration to pull more, it has to paginate its requests. Fortunately, Make.com’s Notion integration does this for you, so you can set a limit higher than 100! Next, let’s test the integration and make sure we get a response from Notion that contains data that we can send to YouTube. Right click the Notion module and click Run this module only. Note: Don’t skip these test runs while building this automation. They bring in data that you’ll need to reference later on, so you’ll get stuck if you skip them. If the test was successful, you’ll see a green checkmark underneath the Notion module. You can also click the magnifying glass icon in order to see the data that was returned. If you’ve followed everything perfectly so far, you should see a collection of Bundles in the output section of the window that comes up. All about bundles The Notion API technically returns an array of objects; each database row that matches the query we sent is an object, and the objects make up the elements of the array. Make.com converts each element to a bundle. Bundles are then sent one-by-one through the chain of modules you have set up. If you’re totally new to this concept, I like to think of it as similar to the classic Sega Dreamcast game Chu Chu Rocket. In that game, the player places directional blocks on a grid. Then, a chain of mice starts running. Each mouse has its direction changed the moment it steps on the direction block: Make.com scenarios do the same thing to bundles of data. Each bundle travels into a module; it is then operated upon by the module, and its output gets sent to the next module. If you have a programming background, you can also think of an entire Make scenario like a for…of loop. Typically, 1 operation is counted whenever a module processes an incoming bundle. This means that you can quickly use up your allotted Make.com operations if you’re building workflows that create lots of bundles. However, you can often make your scenarios more efficient by using their built-in tools, such as the array aggregator. This doesn’t work well for the YouTube-to-Notion workflow we’re building here (since we need to send page updates to Notion one-at-a-time), but you may find it useful in other automations! Next, we’ll pull the YT ID property value from each of these Notion bundles and send it to the YouTube API in order to get information about each video. Make.com does not have a built-in YouTube API integration. Fortunately, they provide an HTTP module that we can use to talk to any API. We’ll use that to send our data to YouTube. Specifically, we’ll be calling the Videos:list method, which is used to get information about specific videos. The HTTP module is a general purpose module that you can use to send API calls to any API. It allows you to interact with tools and web apps that Make.com doesn’t officially support. Learn more about it here. Click the + icon to add another module. Search for and choose the HTTP module. From the menu of actions, choose Make an API Key Auth Request. To interact with the YouTube API, we’ll need to pass the API key we set up earlier with any request we make. Under Credentials, click Add. You’ll now add a new Key to your Make.com account. Note that this will be saved to the Keys menu accessible from the sidebar, and you’ll be able to use it in other scenarios. Enter the following details: Name: Anything you want – I like to match it to my Google Cloud project name Key: Your API key from Google Cloud API Key placement: In the query string API Key parameter name: key Click Create. Now we’ll define the endpoint and method for our HTTP request. URL: (click the clipboard icon in this code block to copy) https://www.googleapis.com/youtube/v3/videos Method: GET Next, we’ll set the parameters that will be passed in the query string that get outputted by this HTTP module. Leave Headers blank. This entire request is passed via query string. Under Query String, create two Items. Within Item 1, set Name to part and Value to snippet,statistics. Within Item 2, set Name to id. Click the Value field and find Notion – Search Objects → properties_value → YT ID → string. Drag it into the Value field. This process of clicking/dragging elements into fields is called mapping. Click here to learn more about mapping in Make.com. Finally, under Parse Response, choose the Yes option. If you choose No, the HTTP module will output YouTube’s response as a string (and a very long one at that). To properly interact with the data in the next step, it needs to be formatted as JSON. Choosing Yes will tell Make to automatically output the response as JSON. Let’s test the workflow we have so far: Near the bottom of the screen, click the Save Icon to save your work. Click Run Once. If your test was successful, you should be able to click the magnifying glass icon on the HTTP module and see one operation per bundle that was sent from the Notion module. You can even toggle into the Output bundles. Under Data → items → 1 → snippet, you’ll be able to see your video’s title and some other info! Now we can send this data back to Notion in order to update your video statistics there! From the HTTP module, click the + icon to add another module. Select Notion. Select Update a Database Item. Set the following details: Enter a Database ID: Enter manually Database ID: Find and click Notion – Search Objects → Parent → Database ID Page ID: Find and click Notion – Search Objects → Page ID Next, we’ll define the properties to be updated. We’ll set the property name, type, and value it should recieve. For each Value, click the field and map the indicated value listed below by clicking it. Item 1: Key: Views Value Type: Number Value: Click and Drag: HTTP → Data → items → statistics → viewCount Item 2: Key: Likes Value Type: Number Value: Click and Drag: HTTP → Data → items → statistics → likeCount Item 3: Key: Comments Value Type: Number Value: Click and Drag: HTTP → Data → items → statistics → commentCount Item 4: Key: Publish Date Value Type: Date Value: Click and Drag: HTTP → Data → items → snippet → publishedAt Everything else can be left blank. Click Ok when done. Fields screenshots Items 1 and 2: Items 3 and 4: Save your automation and then click Run Once again. If you’ve set everything up correctly, you should now see your view, like, and comment counts (and your publish dates) updated in Notion! Here’s the Completed Projects section of my demo template, complete with updated stats! Next, we’ll modify our automation so that it also sets each Notion page’s cover using your actual video thumbnails from YouTube. This involves adding another Notion module to our scenario, since the Update a Database Item module doesn’t give us access to the Page Cover property. However, another Notion module means another operation for each bundle. Operations are limited, and since thumbnails don’t change often, you’ll probably want to set the page cover only once. To do that, we’ll first add a Router to the automation. This allows you to add conditional logic to your workflow; bundles will travel down each path in a Router, but only if they fit the filter criteria of each path (if there is any). Right-click the dotted line between the HTTP module and the final Notion module. Click Add a Router. Click the Router to add another path. On the new path, add a new module. Select Notion, then select Update a Page. Note how I’ve dragged my modules around to create a branching < shape. Within the Update a Page module, set the following: Page ID: Notion – Search Objects → Page ID Cover URL Link: HTTP → Data → items → snippet → thumbnails → maxres → URL Click Ok. This module will now pull your video’s thumbnail URL directly from YouTube and set it as your video’s page cover in Notion. Finally, let’s set up a filter to make sure this only happens if the page cover hasn’t been pulled from YouTube already. Click the dotted line between the Router and the Update a Page module you just set up. Label the filter: Only if thumbnail isn't set (or something else descriptive). Leave Fallback Route on No. Now set the Condition fields: Notion – Search Objects → Cover → External → URL Text operators: Does not contain (case insensitive) HTTP → Data → items → id Finally, click Ok. Each video’s thumbnail URL is derived from the video’s ID, which can be found within the video’s actual URL. For example: Video: https://www.youtube.com/watch?v=61a1Edq4iBo Thumbnail: https://i.ytimg.com/vi/61a1Edq4iBo/maxresdefault.jpg Here’s how your final setup should look: Step 3: Enable and Schedule the Scenario If you’ve followed all the steps I’ve laid out, your scenario is now completely set up! All that remains to be done now is to save your work, enable the scenario, and set a schedule for it. Near the bottom of the screen, set the following options: Click the Save Icon. Set a schedule for your scenario. I’ve chosen Each Monday at 12:00 PM here – this means the scenario will run once a week. Turn the scenario On. You’re free to set the schedule however you like; just keep in mind the operation limits of your Make.com plan when doing so. Remember that each run of the scenario will take 2n+1 operations, where n is the number of videos you’re updating. And runs that involve thumbnail updates will take 1 additional operation per video that gets passes through the thumbnail filter. Final Result Here’s the result of this process applied to my demo copy of Creator’s Companion: If you’d like to check out these stats live, here’s the direct link to this Thumbnail View in my demo. If you’re curious about how I got these stat counts that start with emojis, they’re the result of a small formula! Here’s the actual formula code: \"👀: \" + replace(replace(format(prop(\"Views\")), \"(\\\\d{1})(\\\\d{3})$\", \"$1,$2\"), \"(\\\\d{1})(\\\\d{3},\\\\d{3})\", \"$1,$2\") You can learn how this formula works by checking out the replace and regular expression guides in my Notion Formula Reference. Hopefully you’ve found this tutorial helpful, and hopefully it has also shown you the vast potential of these no-code tools! By combining Notion with tools like Make, you can connect to hundreds of other web apps and do basically anything you want. I’m planning to create lots of other no-code automation tutorials in the future. If you want to be the first to know when they go live, join my Notion Tips newsletter. Once you join, all also send you a handy link to all my free templates and Notion reference guides!","metadata":{"source":"https://thomasjfrank.com/notion-automation-youtube-data","title":"How to Send YouTube Data to Notion (No Code) – Notion API Tutorial","date":"2022-10-11T23:30:24+00:00","contentLength":9445}},{"pageContent":"This tutorial will show you the exact, step-by-step process to create recurring tasks in Notion and completely automate them. That means you’ll be able to check off a task, and everything else simply happens for you – the due date gets moved, the Done checkbox becomes un-checked, and the task is ready and waiting for you the next time you need to do it. Yes, seriously. The method I’ll show you in this article requires no coding and can be done for free. Additionally, once you’ve completed the initial setup, you’re good to go – your recurring tasks will just work. Here’s a breakdown of what we’ll be doing: Set up recurring tasks inside of Notion Automate those recurring tasks using Pipedream (free) The automation here is driven by the Notion API, and by some code that I’ve written for you. All in all, this automation should take you no more than 10 minutes to set up. Let’s go! Note: A previous version of this workflow used Make.com, and required a lot more manual setup. While I don’t recommend using that version, I’ve kept the written instructions for it in a toggle section below. Click here to jump to it if you need it. Set up Recurring Tasks in Notion Before you can automate your recurring tasks, you’ll need to set up a system to add recur settings to those tasks in the first place – e.g. “Every other day”, or “Every 2 months”. Fortunately, we’ve done this work for you. My team and I have added a set of powerful recurring task features to Ultimate Tasks, my free task manager template. I recommend starting by adding the template to your workspace: The Ultimate Task and Project Management Template for Notion Use this template to move ALL of your task and project management into Notion. Get it Free Ultimate Tasks also has a ton of other features that will allow you to manage your tasks and projects completely in Notion: Projects (with built-in progress bars) Sub-Tasks Smart Lists (Today, Next 7 Days, etc.) Cold Tasks (long-overdue tasks get out of your way) Ultimate Tasks also comes with a detailed wiki that includes tutorials and deeply detailed reference docs. For the rest of the tutorial, I’ll assume you’re using Ultimate Tasks (or its big brother, Ultimate Brain). However, if you want to implement the recurring tasks features from Ultimate Tasks into your own template, you can see all of them in my Advanced Recurring Task Dates template. This template exists as an educational proof-of-concept, so it’s less useful as an actual task manager. Add Recur Intervals to Your Tasks To set up a recur interval for a task, open the task as a page. You’ll see a Due Date property, as well as three properties for setting up a recurring task: These give you all the tools you need to set almost any recur interval you could want. Recur Interval – A simple number property that works with Recur Unit. Recur Unit – The available recur units, including Day(s) Week(s) Month(s) Month(s) on the Last Day Month(s) on the Last Weekday Month(s) on the First Weekday Year(s) Days (Only if Set to 1 Day(s)) – this will let you set a task to recur on specific days on the week – e.g. Mon/Wed/Fri Recur Unit must be set to Day(s) and Recur Interval must be set to 1. Once you set up a recur interval, you’ll also see a property called Next Due. This shows the next due date for the recurring task. Example Recur Settings Here are a few examples of recur intervals you could set up using these three properties: Due Every 3 Days: Recur Interval : 3 Recur Unit: Day(s) Due Every 2 Months on the Last Weekday Recur Interval: 2 Recur Unit: Month(s) on the Last Weekday Due Every Tuesday and Thursday Recur Interval: 1 Recur Unit: Day(s) Days (Only if Set to 1 Day(s)): Tuesday, Thursday As you can see, there are many combinations of these three properties that will let you create most of the useful recur intervals that you could create in other apps like Todoist, Asana, or ClickUp. Completing Recurring Tasks Manually You can “complete” a recurring task directly inside of Notion simply by changing the Due Date property to the date displayed in the Next Due property after you finish the task. Note that you do not need to click the Done checkbox property in this case, as it won’t do anything. If you want to be able to click Done and have the task automatically update its Due Date, then continue on to the next portion of the tutorial. Set Up Automated Recurring Tasks in Notion Using the Notion API, we can automate all sorts of processes inside of Notion that used to be done manually. This includes processing recurring tasks! If you’re curious about the details, I’ve written about them in the two toggle sections below. Feel free to read those; otherwise, you can skip them and get right to building. What is an API? Essentially, an app can have an API (Application Programming Interface) that allows outsiders – including indie developers and even other apps – to work with certain pieces of its code. Here’s an example of an API in action. In Slack, I can use the Giphy extension – which leverages the Giphy API – to paste a gif right in one of my conversations. There are several tools – we can call them integration builders – that let you connect different app APIs together. Some focus on providing a set of no-code tools, allowing you to build automations without coding at all. These include Zapier, IFTTT, Make.com, and others. Others are code-light; they provide some no-code tools, but also allow you to write your own code – without having to worry about things like authentication, security, and server infrastructure. Pipedream is one of those tools, and it’s the one I personally use to build all my automations – and to build automations that I can share with you in these tutorials. How This Automation Works If you’re curious, here’s how the automation of recurring tasks works – both in Notion an in basically any productivity app. When you set up a recurring task and check it off as “Done”, here’s what happens from the app’s perspective: The user has checked “Done”, so run the recurring tasks script Update the Due Date as specified by the user’s recur interval (e.g. “every other day”) Uncheck the “Done” box There’s another way an app could handle recurring tasks: Instead of editing the task you checked off, it could create a duplicate of that task with the new due date. However, most productivity apps use the method I’ve just described instead. My Ultimate Tasks template contains all the logic needed to calculate the Next Due Date right within the template itself. This is very useful – it allows you to use the manual method of updating recurring tasks if you want, but it also saves us the trouble of adding very complex date calculation code to our automation. Here’s all that our automation will be doing. Step 1: Search through your tasks database in Notion, looking for tasks that have been marked Done and that have a date displayed in the Next Due property. Step 2: For each found task that fits those two criteria, update the Due Date property to have the date displayed in the Next Due property, and then un-check the Done checkbox property. That’s it! In the next section of the guide, I’ll walk you through the exact steps to setting up your automated recurring tasks workflow. Automated Recurring Tasks with Pipedream Now that your tasks database in Notion is all set up, all that’s left to do is create that automation that will actually process your completed recurring tasks. I’ve built this workflow for you in Pipedream, an automation builder that allows developers to build and share workflows with others. Since Pipedream allows me to use code to build workflows, I’m able to build truly custom tools that fit the exact needs of Notion users. (When I was using no-code builders like Zapier and Make, there were often a lot of limitations in my workflows – hence why I’ve switched to Pipedream). To get started, click the link below to import my recurring tasks workflow into your Pipedream account. If you don’t already have an account, you’ll be prompted to create one. And yes, it’s free! Essential Notion – Automated Recurring Tasks This workflow adds completely automated recurring tasks to Notion. Use This Workflow This workflow is 100% free to use, and this link adds extra perks over the normal free Pipedream account. However, I'll earn a commission if you click this link and upgrade to a paid Pipedream account (at no extra cost to you). Full disclosure: I’m both a heavy Pipedream user and an affiliate. If you use my link and decide to upgrade to a paid plan, I’ll earn a commission (and if you do, thank you! It helps support my work). That said, Pipedream has a very generous free plan. You can do a lot more with their free plan than you can with the free plans of other automation builders. And when you use my link, your Free plan gets even better. Normally, Pipedream‘s free plan limits you to 3 connected apps – but my link raises that limit to 5 connected apps, allowing you to build even more automations before needing to upgrade. Once you’ve added the workflow to your account, follow the instructions in this brief video to get it all set up. That’s it! (Legacy) Set Your Time Zone Note: The Pipedream workflow I shared above completely takes care of this step for you. I’ve left these instructions here for anyone using the old Make version of the workflow, but I highly recommend upgrading to the Pipedream version. For automated recurring tasks to work, you’ll first need to set up a UTC Offset property in your Notion workspace. Why do I need to set a UTC Offset? Feel free to skip this, but here’s a technical explanation for those who are curious. When a Notion formula outputs a date, the Notion API will always see that date from the perspective of UTC time. This presents a problem, because our Next Due formula has advanced logic that takes into account whether or not a task was overdue when it was completed. Most task management apps do this, including Todoist and Asana. If they didn’t, then you can run into a situation like this: A task is due Jan 1, and is set to recur every 3 days. Normally, it should be next due on Jan 4. You ignore it for a long time, and finally check it off on May 6. Now it shows as due Jan 4 – still way, way overdue. A smarter task manager would realize that the task is overdue and take this into account. Instead of updating the due date to Jan 4, it should update it to be due on May 7. Our Next Due formula does this, which is great… except it clashes with the Notion API’s insistence on seeing the output of Next Due in UTC time. Here’s the problem… UTC time is often in a different day than your local time zone is. For example, if it’s 7pm in Denver on May 6, it’s actually 2am in UTC time… on May 7, the next day. This means that the your automated recurring tasks script (which we’ll build below) looks at the output of Next Due using the Notion API… and sees the task as overdue. You checked the task off on time (at 7pm), but the API sees it as 2am the next day. Note: Our recurring tasks solution doesn’t officially support task times. They’ll work most of the time, but there are weird situations where they won’t (such as the day that Daylight Savings Time happens). But even without times on your tasks, the API looking at your workspace from UTC time-perspective can cause it to see your workspace from the perspective of the next day (or the previous, if you’re east of the UTC time zone and it’s very early in the morning). That’s where our UTC Offset property comes in. Since I’m in Denver, I set my offset to -7, which subtracts 7 hours from the output of Next Due (but only if it’s being viewed from the perspective of UTC time – we thought ahead on that one). This means the Notion API now sees the output of Next Due the same way we see it. In other words, the offset forces the API to look at Next Due as if it were in my local time zone (Denver). Fortunately, Ultimate Tasks, Ultimate Brain, and my Advanced Recurring Tasks proof-of-concept templates all come with a UTC Offset property by default, so all you’ll need to do is edit it so that it matches your time zone. If you happen to be using an older version of one of my templates that doesn’t contain this property, please see this upgrade guide to learn how to add it. A UTC offset is just the number hours that your local time zone is behind or ahead of UTC (Coordinated Universal Time). I live in Denver, Colorado, so my standard UTC offset (when not affected by Daylight Savings Time, the scourge of the modern world) is -7. Hence, you see -7 in the UTC Offset property above. You can find your own UTC Offset at the Time and Date website. Type in your location, then find the UTC Offset for your standard (not Daylight Savings) time zone. Here, you can see that I’ve identified UTC-7 as my offset. By default, my templates have their UTC Offset property set to 0. You’ll want to change it to match your actual UTC Offset. In your All Tasks database, find the UTC Offset property by opening up any task and then clicking the more properties button: You’ll find UTC Offset in under the ⏱ Recurring Divider property: Edit UTC Offset so it contains your standard UTC offset (again, not your daylight savings time offset). If you’re unable to edit this value, you’ll need to unlock the database you’re working on first. With your UTC Offset set, you’re now ready to build your automation! (Legacy) Automated Recurring Tasks with Make.com Note: These are the instructions for the previous version of this workflow, which used Make.com instead of Pipedream. These instructions will still work, but the setup takes much longer and is much more error-prone. I highly recommend using the Pipedream version above – it’s free, and I have lots of other custom Notion automations for Pipedream in the works! Make.com is a powerful integration builder that gives you near-direct access to Notion’s API (as well as the APIs for many other apps). Best for No-Coders Make.com My favorite no-code automation builder that can create workflows between hundreds of apps. Has a bit of a learning curve, but it significantly more powerful (and cheaper) than Zapier. Has a great free tier too. Sign Up for Free I'll earn a commission if you sign up through this link and upgrade to a paid account (at no extra cost to you). Here are the steps you need to follow to create your recurring tasks automation using Make.com. First, create a Make.com account if you don’t have one. You can stick with the free plan, as it’ll work perfectly for our purposes. The only thing to be aware of regarding the free plan is its Operation limit. The free plan limits you to 1,000 operations per month. We’ve found that it costs one operation each time you run the script (called a Scenario) we’ll be building, as well as one operation per recurring task that is updated. By default, Make.com will set your Scenario to run every 15 minutes – however, that would result in 2,976 operations per month – without counting the operations needed to actually update your tasks! For that reason, I set my Scenario to run once a day at 11:55pm (it needs to be before midnight). That’s 31 max operations per month, leaving 969 left over to update my tasks (and I don’t have even close to 969 recurring tasks in a month). Armed with that knowledge, head to your Scenarios tab and Create a New Scenario. Click the large + button and search for Notion. From the list of actions that pops up, select Search Objects. This will create the first part of a two-step automation that will help us automatically process recurring tasks. The next step is to connect your Scenario to your Notion account. Click the Add button under Connection: Ensure Notion Public is selected under Connection Type. The Connection Name doesn’t matter, so you can leave it as My Public Notion Connection if you want. Now you’ll authenticate with Notion. Be sure you’ve selected the correct Workspace that contains your copy of Ultimate Tasks, then hit Select Pages. Next, select your copy of Ultimate Tasks, or a page that contains it. Remember that Notion has cascading permissions, which means that sub-pages inherit the permissions of their parent page unless you change them manually. This works in our favor, as what we really need to give Make.com access to is the All Tasks database contained within Ultimate Tasks. Once you’ve selected the correct page, click Allow Access. Now we need to get the Database ID from our All Tasks database. This will tell our Scenario precisely with database to search. You can find your Database ID by navigating to your All Tasks database within Ultimate Tasks. Important: You must be on the actual All Tasks database page. Ensure that you’re not merely on another page that contains a Linked Database view. Copy the URL of the All Tasks database to your clipboard. You can do this with Ctrl/⌘ + L or by hitting the three-dot menu in the top-right corner and then clicking Copy Link. From there, you can find the Database ID by copying the part of the URL directly after the / character in notion.so/ and before the ? character: Here’s my database’s URL: https://www.notion.so/97a4d9506d1840d2a00e186a3d2d632f?v=2cf8cd2d0caa47fd88e61de05cf9ee59 Which means my Database ID is: 97a4d9506d1840d2a00e186a3d2d632f Head back to your Scenario. Ensure that Search Objects is set to Database Items, and then paste your Database ID into the Database ID field. Note: The example ID shown in this post will not work for you – your Database ID must be from your own All Tasks database. Next, add three Filters, ensuring the second and third are added as AND rules. Filter 1: Done (Checkbox) Equals True (drag the pink true Keyword from the popup. Ensure the gear-icon tab is active.) Filter 2: Next Due (Formula) Formula sub-heading → Text – Is not empty (boolean) – Important: Select this option from under the Formula subheading in the dropdown menu. True (drag the pink true Keyword from the popup. Ensure the gear-icon tab is active.) Filter 3: Next Due (Formula) Formula sub-heading → String – Does not equal Paste Error in Recur Interval: Non-Whole or Negative Number in the third field. This is an error that Next Due will display in Notion if you happen to set your Recur Interval property to an incorrect number, like 1.5 or -42. Finally, set the Limit to 100 and hit OK. Before we move onto the next step, head back to your copy of Ultimate Tasks and ensure there is at least one recurring task that has been marked Done. Your Make.com Scenario needs to find at least one Done recurring task in order to complete the search we just set up and grab data that we’ll need to finish building the automation. Once you’ve done this, head back to your Scenario and hit the Run Once button in the bottom-left corner. Additionally, hit the Save icon in order to save your work. If everything worked as expected, you should see a green checkmark under your Notion icon, as well as a number in the upper corner (this is the number of Done recurring tasks that the search found in your All Tasks database). Additionally, there should be no errors displayed in the Log. If there are, the most likely error is that you didn’t have a recurring task in your All Tasks database that was marked Done before you hit Run Once. In this case, mark a recurring task Done and then hit Run Once again. Next, we’ll create the second half of our Scenario which will actually update our All Tasks database and process the completed recurring tasks that were found in the search. To the right of your Notion icon, click Add Another Module. Click Notion, then choose Update a Database Item from the list of actions. Under Enter a Database ID, change the dropdown option to Enter Manually. Paste the same Database ID from before (the one from your All Tasks page URL) in the Database ID field. Next, drag the id object from the pop-up and drop it into the Page ID field. Note: The id object may also be called Page ID. I’ve seen it listed both ways, but it works either way. Next, click Add Item under Fields. For Item 1, set it up as follows: Key: Due (simply type this – it’s the name of your Due property in Ultimate Tasks) Value Type: Date In the Start Time field, do the following: First, click over to the calendar menu icon in the popup, then drag in the parseDate(;) function to the Start Time field. Next, click back to the star menu icon in the popup. Under properties_value and then Next Due, find the string object and drag it between the ( and ; in parseDate(;). Finally, between the ; and ) symbols in parseDate(;), paste MMMM DD, YYYY. The other fields – End Time and Include Time – can be left blank. This function simply updates the Due Date property in Ultimate Tasks with the date displayed in Next Due. Remember: Next Due is the Formula property that does all of the recurring date calculation directly in Notion for us! Add one more item with the following values: Key: Done Value Type: Checkbox Value: No This part of the function will automatically uncheck the Done checkbox. Hit OK. There’s just one more thing to do. Click the three dots between your two Scenario steps to create a filter. Give it the following settings: Label: Check Results Condition: Drag the id object into this field. Note: It may also be called Page ID. Criteria: Exists This filter will keep the Scenario from throwing an error (and sending you an annoying email) in the event that it doesn’t find any completed recurring tasks when it performs its search. At this point, you can hit Run Once in order to test your script. Watch your All Tasks database: Any Done recurring tasks should be automatically un-checked and have their Due dates updated. Once you’ve verified the test was successful, there’s one quick step left before we approach the finish line. Right-click the very first module you set up in the beginning—the Notion Search Objects module—and click Add error handler. In the box that pops up, click Commit. This will tell Make that the scenario has completed successfully, even if the Search Objects module fails to find anything. You wouldn’t normally want to silence error messages, so it’s important that this step comes last, after everything’s already working. The reason we need to do this is that a scheduled Make scenario automatically turns off if it gives an error too many times in a row. Since the Search Objects module fails if it doesn’t find anything, this would happen if you just happened to go a few days without completing any of your recurring tasks, and you’d have to come back to Make.com to turn it on again. With that out of the way, it’s time to set your Scenario’s schedule. I recommend running it once per day to minimize the actions it takes up. Note that your Scenario must run during the current day, so I recommend setting it to 11:55pm. This way, your scheduled Scenario runs will only use a maximum of 31 Operations per month (one per day), leaving 969 (1,000 – 31) leftover to process your completed recurring tasks. Note that on Make.com’s free plan, 15 minutes is the smallest interval you can use for your Scenarios. Keep this in mind when building other Scenarios that may need more frequent updating or faster response times. Finally, switch the Scenario to On, and save your work. (Legacy) Adjust Your Template Settings Note: The Pipedream workflow I’ve shared above takes care of this step for you automatically. I’ve only left these instructions up for people using the old Make version of the workflow. The last thing you may want to do is edit the Type property in your All Tasks database if you’re using Ultimate Tasks or Ultimate Brain. Replace its formula with this one: if(empty(prop(\"Recur Interval\")), \"⏳One-Time\", \"⏳One-Time\") These templates contain filters that will prevent tasks with a Type of 🔄Recurring from leaving your task views when the Done checkbox is checked. This is a bit of error-prevention, since many users don’t know that checking Done on a recurring task won’t do anything by default. But now that you’ve set up automatic recurring tasks, checking Done actually does do something! So we can now get rid of this error-checking, and the easiest way to do it is to edit the Type formula as described above. Otherwise, you’d have to go around and edit the filters in every view of Ultimate Tasks. Wrap-Up and More Resources That’s the end of this tutorial, but if you want to learn more and take your Notion workspace to the next level, check out some of my other tutorials: Notion API Guide: Integrate with 3,000+ Apps (With NO Code) How to Build a Personal Dashboard in Notion Synced Blocks in Notion: Everything You Need to Know Also, if you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-automated-recurring-tasks","title":"The Best Way to Create Recurring Tasks in Notion (2023)","date":"2022-03-24T17:25:06+00:00","contentLength":4568}},{"pageContent":"If you want to learn how to work directly with the Notion API, this tutorial will teach you how to do it – even if you’re a beginner with no coding experience. In this tutorial, you’ll learn: What the Notion API is and what it can do What an API is (in general) How to create a Notion API integration inside your Notion workspace How to send data to Notion via the Notion API How to create new pages in a Notion database via the Notion API How to read, understand, and actually use API documentation Lots of beginner-to-intermediate level JavaScript The Notion API already has great documentation, so here I’ll be teaching you how to actually use the API by walking you step-by-step through a fun example project – building a complete Pokédex in Notion! Many people have built Pokédexes in Notion by hand, but we’ll build ours with zero manual data entry. Everything will be handled by the Notion API and a small JavaScript application that we’ll build, which will automatically create an entry for each Pokémon. Here’s a look at the final product (you can also view this Pokédex directly on Notion): Each Pokémon has its own database entry with art, stats, description, and more. This is a great introductory project for learning how to work with the Notion API. And once you’ve completed it, you’ll have the knowledge and skill to do nearly anything else with the API. I have many more API tutorials planned, so if you’d like to get notified when they go live, join my Notion Tips newsletter. You won’t need any special software for this project – we’ll do everything in the browser using free tools. We’ll even code in the browser (of course, you can use your own local code editor if you want). I’ve also included deep explanations (in handy collapsible toggles) and external links that explain everything, so you’ll be able to use this as a true zero-to-hero path for learning Notion’s API. There’s even a fully mapped-out learning path below. Every Pokémon will get its own Notion database entry that includes its stats (HP, attack, defense, etc), types, flavor text, artwork, and more. We’ll accomplish this by building a simple JavaScript application that pulls all of this data from PokéAPI, a free and open-source resource with an immense amount of information on all things Pokémon. Our app will then format the data and send it to Notion. Note: This tutorial is meant for those who want to work directly with the Notion API using a programming language like JavaScript. If you’d like to work with the Notion API using no-code tools (like Make.com), check out this tutorial instead: How to Send YouTube Data to Notion (No Code) – Notion API Tutorial A step-by-step guide for importing YouTube views, likes, and other statistics directly into Notion – automatically, with no coding required. thomasjfrank.com What is the Notion API? To kick this off, let’s talk a bit about what the Notion API actually is. The Notion API is a set of tools that allow you to connect your Notion workspace to other apps and services outside of Notion (including apps you build yourself). Using the API, you could: Add new rows to a sales database in Notion when customers make purchases on your online store (using a platform like Lemon Squeezy or Shopify) Auto-transcribe voice notes using a service like Deepgram and send the transcript to a Notion page (tutorial on this coming soon! Join the newsletter to get notified.) Use Notion as a CMS for blog posts and display them on a custom-built website (like Braydon Coyer does – though you can also use Notaku for this instead of building a site from scratch) …and much more. The possibilities are basically endless. The Notion API provides endpoints for many major functions, including: Querying, creating, and updating databases Retrieving, creating, updating, and archiving pages Retrieving, creating, updating, and deleting blocks Appending child blocks to a parent block Listing workspace users and retrieving specific user information Creating and retrieving comments All API requests to the Notion API must be sent to the base URL https://api.notion.com, which you’ll see as the first part of the listed endpoint for any action you’d want to take. For example, if you wanted to query a database, you’d send a POST request to: https://api.notion.com/v1/databases/{database_id}/query Notion requires all API requests to be made over HTTPS, and they must be authenticated properly. To make API requests to your workspace, you’ll first need to create an integration (we’ll cover this later), then give that integration explicit access to pages in your workspace. Notion also provides a JavaScript SDK for working with the API. As you’ll see later in the tutorial, it’s easy to add this to your project, and it gives you access to handy methods that make API requests easy to construct in your code. If you’d like a more thorough overview, check out the official API documentation’s introduction. However, I think you’ll get a better grasp on the API by actually working with it – so let’s start doing that! If you do happen to want a primer or refresher on what an API is (in general), check out the toggle block below. What is an API? (General API Definition & Primer) APIs (Application Programming Interfaces) are sets of tools that allow different web services to talk to each other over the HTTP protocol. An API can allow one service to read data from another one; alternatively, it can allow one service to create new data at another service, update existing data, or even delete data. You’ll often see another acronym used to describe these four potential operations: CRUD. Create Read Update Delete APIs are what allow you to posts Giphy GIFs directly in Slack. They enable those awesome link previews that you can create in a Notion page. And they are the many engines under the hood of connector tools like Zapier and Make.com. APIs typically consist of one or more URLs, to which your application can make HTTP(S) requests in order to do one or more CRUD operations. These URLs are often called endpoints. Note: You may have a conversation in the future about APIs with a nerd who will stress that you access URIs, not URLs. The distinction really does not matter here, but here’s an article on their differences if you’re curious. In most cases, APIs will have separate endpoints for each type of operation you can do. In other words, you’ll almost never use the same endpoint to both read data and delete data. To see how an API actually works, let’s look at an example from PokeAPI – the API we’ll be working with later in the tutorial. One of PokeAPI’s endpoints is the pokemon endpoint, accessible via either one of these URL schemes: https://pokeapi.co/api/v2/pokemon/[pokemon name] https://pokeapi.co/api/v2/pokemon/[pokemon number] To access information about Charmander, you’d either use https://pokeapi.co/api/v2/pokemon/charmander or https://pokeapi.co/api/v2/pokemon/4. Since PokeAPI doesn’t require any special kind of authentication, you can even visit these URLs in your browser. Here’s a link you can try. However, you’ll quickly realize that visiting that URL in the browser isn’t very useful; you’re just presented with a huge string of JSON. I’ll cover JSON more thoroughly later, but you can watch this video now if you’re curious about what it is and how it works: However, if you make that request from a program, you can use additional code to process that JSON response and do really useful things. For example, you could write code that goes through all that data, pulls out the Pokemon’s name, and displays it. I show this example later in this guide (click here to jump to it), so I won’t repost it here. Of course, you can do much more than just display the Pokemon’s name. Once you have the information, you can do basically anything with it, so long as you know how to write the required code. That’s the power of an API: It allows you to do CRUD operations, and then combine them with any sort of code you want to write. The applications are basically limitless. To wrap up this small primer, I’ll go over the five most common HTTP methods available to you when working with APIs. You’ll see these all the time, so it’s good to be familiar with them. GET – used for reading data from the application. It is read-only, so it has no risk of modifying any data. POST – sends data to the application to create something new. PUT – sends data to the application to update an existing resource. Contains a full updated copy of the resource. PATCH – also updates an existing resource, but only contains the changes to be made instead of the entire updated resource. DELETE – sends an instruction to the application to delete an existing resource. In many cases, your requests to a particular API will need to contain both the URL to be accessed and the method to be used. For example, if you want to create a page in Notion via the API, you’ll need to access the https://api.notion.com/v1/pages endpoint using a POST request. You’ll learn much more about APIs simply by working through this project. However, you can also get additional insight with the following resources. First, check out Fireship’s excellent (and short) overview: If you fancy long videos, you may also enjoy freeCodeCamp’s APIs for Beginners course (though you could also just watch the video version of this tutorial near the top of this page! “What If I Don’t Know How to Code?” In this project, we’ll build our application using JavaScript. So if you have a basic understanding of JavaScript, you’ll be more comfortable going through it. However, you don’t need to already know JavaScript to go through this tutorial. My entire goal with this tutorial is to help non-technical people dip their toes into the world of coding and working with the Notion API. I’ve gone to great lengths to make it a truly comprehensive resource. Read this if you’re feeling anxious or overwhelmed about coding If you don’t know how to code – if you get confused and overwhelmed at most coding tutorials – I’ve been in your shoes. At the beginning of last year (2022), I didn’t know how to code. I barely knew what an API was. I tried to watch tutorials, but I’d get confused when the creator would throw around terms like “npm”, “node.js”, and “API endpoint” without explaining them. Eventually, after much Googling and a lot of frustration, things started to click for me. Hopefully I can spare you some of that frustrated Googling (Froogling?) with this tutorial. As you’ll see later, I’ve added lots of toggles just like this one throughout the tutorial. The purpose of these is to give you an explanation for everything if you need it (and keeping these explanations in toggles lets more experienced coders skip past them easily). However, the best piece of advice I can give you for learning how to do is this: Run your code early and often. The true “best” way to learn how to code is to write a lot of code and to get lots of feedback. Luckily, you get feedback pretty quickly when you’re coding; when there’s an error, it’ll be logged in your console or somewhere else. So dive in and get your hands dirty! To build any skill, you need 3 ingredients:1. Quality instruction2. Deliberate practice3. FeedbackMost people don't get nearly enough of #3 because they're too afraid of making mistakes or getting judged.Don't be one of them.Try often, get judged often, learn faster.— Thomas Frank (@TomFrankly) October 20, 2022 As we go through this tutorial, I’ll include asides and primers about all of the tools and concepts we’ll use. However, I’ve also collected them all in this learning path toggle, enabling you to find them all in one place. Full Learning Path and Resource List This project involves working with several tools, two different APIs, and multiple JavaScript programming methods and concepts. Here, I’ve compiled a full list of all of these things, along with some general resources you can use to learn JavaScript more comprehensively. I encourage you to use this as a reference, but don’t let its length intimidate you! If you follow the rest of the tutorial, I’m confident that you can get the entire project working even if you don’t understand everything right away. Once you do, you’ll be in a better position to go back, dig into these resources, and really understand how they all fit together. Tools Used in This Project This is a list of the specific tools and libraries we’ll use in this project. Since we’ll be building in Glitch, you don’t really need to worry about their details – Glitch will take care of most of the work for you. Glitch – a free platform for building websites and web apps. Includes everything – a full code editor, Node.js backend, npm package manager, terminal, and more. Node.js (automatically set up by Glitch) – a runtime for JavaScript. Allows you to run JavaScript code outside of the browser, effectively enabling JavaScript to be used as a back-end (server-side) language. Learn more about Node here. Npm (automatically set up by Glitch) – the Node Package Manager. Allows you to very easily include external code libraries in your project and use them. There are thousands of packages, including one for Notion’s API. PokéAPI – an open-source API that enables you to access pretty much any data related to Pokémon that you could ever want. Notion API – Notion’s official API, which allows you to read, write, update, and delete resources in a Notion workspace. Axios – a free HTTP library that works with Node.js. This is the library we’ll use to access the PokéAPI. Note: You can also build this project on your local machine. I’m using Glitch because it keeps things extremely simple and takes care of the setup. If you want to go the local route, you’ll need a code editor like VS Code. You’ll also need to install Node.js and npm. JavaScript Learning Resources These free courses and general-purpose resources are great for developing a full understanding of JavaScript. JavaScript Algorithms and Data Structures – a full, free, and interactive JavaScript course by freeCodeCamp. This is, IMO, the best beginner resource for learning JavaScript. The course has hundreds of mini-lessons, each of which teaches a concept and then has you actually use it in the in-browser code editor. I have only done the Basic JavaScript and ES6 sections of this course, personally. You absolutely don’t need to finish the entire course to understand this tutorial. That Weird JavaScript Course – Fireship’s great series of YouTube videos on JavaScript. Each is super-entertaining and does a great job at explaining JavaScript at a high level. The Modern JavaScript Tutorial – an excellent written guide to JavaScript. The MDN Web Docs – the definitive technical reference for JavaScript. I’ll be linking to this many, many times in this guide. Beginner JavaScript Notes – a free “cliff’s notes” version of Wes Bos’ paid Beginner JavaScript course. JSFiddle – a tool for running small code snippets in your browser. Great for testing things out without much required overhead. Specific Concepts This is a list of the individual concepts and programming patterns/data structures we’ll use in this tutorial. I’ve listed the actual methods we’ll use separately below. These have been ordered roughly by their difficulty, and I’ve included a recommended understanding level for each. This isn’t a requirement; I think you can work your way through this tutorial and refer to these concepts as you go. It’s more an indication of my own perceived understanding of each concept at the time I built this project. Concept Recommended Understanding Variables – const vs. let Full Data types – string, number, etc Full Variable scope Medium Boolean values – truthiness and falsiness Full Console logging Basic Arrays Basic Objects Basic Accessing object properties Full Functions Basic Conditional statements Medium Ternary syntax (for conditionals) Full For loops Full For…of loops Full Try/catch blocks Basic Requiring modules in Node.js Basic REST APIs Basic Template literals Basic Arrow functions Medium Object destructuring Medium Destructuring nested objects Full Regular expressions Basic Promises Basic Async/await Basic Specific Methods We’ll use several built-in JavaScript methods throughout this tutorial. Below, I’ve linked to the documentation for each one on the MDN Web Docs. These are ordered alphabetically. Array.prototype.find() Array.prototype.join() Array.prototype.map() Array.prototype.pop() Array.prototype.push() setTimeout() String.prototype.replace() String.prototype.split() String.prototype.substring() String.prototype.toUpperCase() How to Go Further If you finish this tutorial and want to push your skills even further, here are a few challenge ideas: Use the Notion API and database relations to display the evolution chain for each Pokémon. Display a table within each Pokémon’s page that contains each move that it can learn. Push the data from your Notion Pokédex to a static website (example: Daniel Shiffman’s Nature of Code site uses Notion as a CMS) Steal My Code and Create a Pokédex Instantly If you just want the code you’ll need to build a Pokédex, you’re in luck! I’ve built this project on Glitch, which is a free platform that allows people to build and share working web apps and sites. Here’s the direct link to my Glitch project. There’s a handy Remix feature that allows you to fully copy my Pokédex project and run it for yourself. All you’ll need to do is create a free Glitch account, hit the Remix button, and follow the instructions in the README.md file. Even if you intend to follow this tutorial and build the project from scratch, I’d encourage you to first Remix mine and see how it works! One of the most powerful ways to learn faster is to prime your brain by skipping ahead and getting a preview of what you’re trying to accomplish. Even if you don’t fully understand it, you’ll be setting your brain up to more readily understand each piece of the process once you go back and start it in earnest. I’ve also meticulously commented my code, so you can work through it and get an explanation of how everything works. To get the script running: Create a Glitch account and hit the Remix button on my project. Duplicate my Pokédex Template into your Notion workspace. Follow the instructions in this section → Create Your Notion Integration Follow the instructions in this section → Set Your Environmental Variables Open the Terminal. Type node index.js and hit Enter. By default, the script will pull the first 10 Pokémon into your Notion database. To change this, modify the start and end variables (lines 65 and 66 in index.js, or 18 and 19 in index-nocomments.js). Full Project Code I’m also going to share the full code for this project right here. As we work through the tutorial, I’ll include smaller code snippets that focus on the specific part we’ll be building at that point. However, you may want to reference the project code in its entirety; when that happens, just open one of these toggles. Full Project Code (No Code Comments) Remember that you can view this code directly on my Glitch project as well! It is located in the index-nocomments.js file. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage(); } getPokemon(); const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Full Project Code (With Comments) Remember that you can view this code directly on my Glitch project as well! It it located in the index.js file. /* Bring in the external packages we'll be using. Axios is an HTTP client that makes working with APIs easier: https://axios-http.com/docs/intro Additionally, we bring in the Notion API client so we can make requests to it. */ const axios = require('axios') const { Client } = require('@notionhq/client') /* Create a new object 'notion' that gives our code access to the Notion credentials set up in the .env file */ const notion = new Client({auth: process.env.NOTION_KEY}) /* Create a blank array in which we'll store an object for each pokemon fetched from the PokeAPI */ const pokeArray = [] /* Create a function for making requests to the PokeAPI. We have to use an asynchronous function becuause axios.get() returns a Promise. Without using an async function, the rest of our code would run before axios gets a response from the PokeAPI. */ async function getPokemon() { /* Define start and end variables for the 'for' loop below. These numbers would usually be set directly in the for loop itself, but I've made them into their own variables so you can easily tweak them. They correspond to actual Pokemon numbers - e.g. 1 = bulbasaur. */ const start = 1 const end = 10 /* This 'for' loop will make the first set of requests to the PokeAPI. We're using a basic 'for (let i = num)' loop because i will correspond to specific Pokemon numbers. So if you only wanted the original 151, you'd set start at 1 and end at 151. */ for (let i = start; i <= end; i++) { /* Use the axios.get() method to make a GET request to the PokeAPI's 'pokemon' endpoint: https://pokeapi.co/docs/v2#pokemon This endpoint allows to to access MOST of the information we need. The only info we can't get from this endpoint is flavor text, generation #, and category (e.g. \"Flame Pokemon\"). For that info, we'll have to query the 'pokemon-species' endpoint later on. Note how we're using a template literal in order to pass our `i` variable's value into the URL. This is what will allow us to call PokeAPI for the correct pokemon on each run of the loop, e.g. https://pokeapi.co/api/v2/pokemon/4 (when i = 4) will get Charmander. */ const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { /* Pokemon have a variable number of types (some have 1, some have 2). The Notion API expects Multi-Select property selections to come in the form of an array of objects, so we need to create an array of objects that we can pass when we're setting the 'Type' Multi-Select property's values. First, we store the types array from PokeAPI in the typesRaw variable. */ const typesRaw = poke.data.types /* Now we'll create a blank array that will contain our type objects, which will be formated specifically so they'll work with the Notion API. */ const typesArray = [] /* Create a for...of loop that will loop through all the elements of typesRaw. For each one, we'll create an object 'typeObj' which is formatted as needed for the Notion API, which which contains ONE of the Pokemon's types. Since the number of loop iterations is defined by the length of the typesRaw array, we'll end up with a new array (typesArray) that contains an object for each of the Pokemon's types. E.G. - Butterfree is Bug-type and Flying-type, so its typesArray will have two elements. */ for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } /* Add the object onto the end of typesArray */ typesArray.push(typeObj) } /* The PokeAPI returns very basic formatting for Pokemon names - e.g. 'Mr. Mime' is formatted as 'mr-mime'. We want to show names with proper punctuation and capitalization in Notion - e.g. 'Mr. Mime'. This is also important for auto-generating links to Bulbapedia, where more information about each Pokemon can be found (this is a basic Pokedex that doesn't include move information, locations, etc.) To accomplish this, we're running the poke.data.species.name object through several functions. First, the split().map().join() combo capitalizes the first letter of each word - e.g. 'mr-mime' becomes 'Mr Mime'. When methods are chained like this, they are executed left-to-right. So the return value of split() is fed into map(), and map()'s return value is fed into join(). Then, we run that result through a gauntlet of replace() calls to deal with edge case Pokemon like Type: Null, Ho-Oh, Mr. Mime, and Nidoran♀ - all of which include punctuation or symbols. Each replace() call looks for a regular expression match and replaces the first one it finds with the next argument. */ const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") /* Define a variable that holds the bulbapedia URL for the Pokemon. Bulbapedia has a very standardized URL scheme for Pokemon, so all we need to do is pass in the processedName variable and then replace any space characters it contains with underscores. All other special characters are left in the URL - even :,é,-,etc. Example URL: https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pokémon) */ const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pokémon)` /* Here we're defining a variable for the sprite using ternary syntax (? and : ) to create a conditional statement. We need to do this because certain Gen VIII Pokemon were introduced in Pokemon Legends: Arceus and do not have a sprite. The PokeAPI has an 'official-artwork' image for EVERY Pokemon, so we'll set the value of sprite to 'official-artwork' if a 'front_default' sprite doesn't exist. (!poke.data.sprites.front_default) is a Boolean check; if the value of this object is null, it'll evaluate to false. */ const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default /* Now we'll construct the object that will hold all of the data about this Pokemon. If you recall, we aren't able to pull generation, flavor text, or category from PokeAPI's 'pokemon' endpoint, so we'll add those to this object later. For now, each object property is being set to the value of the corresponding property returned from our first PokeAPI call. Note how ['official-artwork'] is defined differently. Property key names with dashes or spaces must be called using 'bracket notation' rather than 'dot notation'. */ const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } /* Send a log to the console with each fetched Pokemon's name. Doing this will allow the console to show activity the whole time the script is running. Without it, you'll just see a blank spot in your console while the script takes minutes to run. */ console.log(`Fetched ${pokeData.name}.`) /* Push our pokeData object onto the end of the pokeArray array. This is done each time our loop executes, resulting in an array full of objects - one for each Pokemon that you included in the loop (using the start and end numbers). Each object will look just like the pokeData object definition above, except the properties will contain actual information. If you want to see how these look, add console.log(pokeData) above this line. */ pokeArray.push(pokeData) }) .catch((error) => { /* if axios.get() fails and throws an error, this catch block will catch it and log it in the console. */ console.log(error) }) } /* We now need to call another PokeAPI endpoint to get three more pieces of information about each Pokemon: - Flavor text (e.g. \"Spits fire that is hot enough to melt boulders. Known to cause forest fires unintentionally.\") - Generation (e.g. I, II, III...) - Category (e.g. \"Flame Pokemon\", \"Owl Pokemon\") These must be obtained from the pokemon-species endpoint (https://pokeapi.co/docs/v2#pokemon-species) We now have all of the Pokemon we'll sent to Notion in pokeArray, so we'll now use a for...of loop to loop through that array, get the 'species' info for each element from PokeAPI, and add each piece of info to that pokemon's object in pokeArray. */ for (let pokemon of pokeArray) { /* Just like we did above, here we use axios.get() to call the PokeAPI endpoint we want. Note that this time we're passing the pokemon.number property from the current element of pokeArray (which is stored in the pokemon variable created in this loop) into the PokeAPI URL. */ const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { /* Create a variable to store the pokemon's flavor text. Depending on the pokemon, PokeAPI will have a differing number of flavor text options. These are all stored in an array called flavor_text_entries, and the English-language flavor text might be at any one of the indexes. See for yourself: Go to pokeapi.co and enter 'pokemon-species/charmander' in the testing box. Array index 0 (the first one) contains English-language flavor text. However, try 'pokemon-species/cramorant' and you'll see that the English flavor text doesn't show up until Array index 7. So instead of calling a specific array index, we have to search deeply inside the array's objects to find the one that has a 'language' object, which itself contains a 'name' property with a value of 'en'. To accomplish this, we call the find() method on the flavor_text_entries array, which returns the first array element that satisfies a test condition we'll set up though a function. That function is name === 'en'. To make sure the value of the nested 'name' property is fed into the function as the 'name' varible, we do what is called nested object destructuring. ({language: { name }}) tells find() that for each array element, go into its language object, then into the name property nested within, and pass name's value as the variable for the function. find() returns the full array element that matches the test condition, so we then tack on `.flavor_text` to get the value of its flavor_text property. Finally, we pass the found value through replace(/\\n|\\f|\\r/g, \" \") to replace any newline characters with spaces, resulting in a single line of flavor text. */ const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") /* Here we do the exact same thing as was done with the flavorText variable, except for the 'genus' property, which is PokeAPI's term for the category - e.g. \"Flame Pokemon\" */ const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus /* Now we get the pokemon's generation. It is returned in this format: 'generation-i' - but we want it to simply be 'I', so we run the result through split(/-/), which splits the string into an array using the dash character (-) as the divider. Then we use pop() to \"pop\" the last element of that array off of the array and return it - this will always be the generation number in Roman numerals, e.g. 'iv'. Finally, we pass that value through toUpperCase() to capitalize it - e.g. 'IV'. */ const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() /* Now we add our three new pieces of information to the current pokemon's object by creating three new properties within that object, and then assigning them the values from our three variables above. Note how pokemon['flavor-text'] uses bracket notation; this is required when an object property name has or will have spaces, dashes, or other special characters in it. Dot notation can only be used when property names contain letters, numbers, and underscores. */ pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation /* Add a log entry in the console each time this information is fetched from PokeAPI. */ console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { /* Log any errors thrown by axios.get(), just as in the previous loop block. */ console.log(error) }) } /* Once both loops have finished running, we call the createNotionPage() function which is defined below. It's important to note that we're calling this function within the getPokemon() function. Since getPokemon() is an async function, calling createNotionPage() outside of it (in the global context) will cause createNotionPage() to run before getPokemon() can finish construcing its array of objects. Calling it here forces createNotionPage() to run only after our two loops have completely finished fetching and formatting the data from PokeAPI. */ createNotionPage(); } /* Here's where we actually call the getPokemon() function. When you type `node index.js` in the Terminal to run this script, it immediately runs this function, which kicks off everything else. Note how we've defined additional functions below this; these are totally fine to exist below this line because JavaScript \"hoists\"function definitions to the top when it actually runs a .js file. Look up \"JavaScript Hoisting\" to learn more about this. */ getPokemon(); /* Create a \"wait\" function to comply with Notion API rate-limiting. The Notion API only allows ~3 requests per second, so after we create each new page in our Notion database, we'll call this sleep function and have it wait for 300ms. This will ensure that our app doesn't try to send data to Notion too quickly, which would cause our calls to eventually fail. */ const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; /* Create a function for sending our data to the Notion API. As with getPokemon(), this function has to be async because it is using axios.get(), which is an asynchronous method that returns a Promise first. Therefore, we must await it, and to do that it has to be inside an async function. */ async function createNotionPage() { /* Here's our main loop for the process of sending data to Notion. We already have our array of pokemon objects (pokeArray), so we can use a for...of loop to iterate through it. For each element, we'll construct a new object that formats the data in the way Notion wants. Then we'll create a new page in our Notion database with that data. */ for (let pokemon of pokeArray) { /* Here we'll construct the data object that we'll send to Notion in order to create a new page. This object defines the database in which the page will live (the \"parent\") and sets its icon, cover, and property values. It also adds a few blocks to the page's body, including the flavor text and a link to the pokemon's Bulbapedia page. I won't verbosely comment every piece of this object definition. Instead, I'll encourage you to study it and also point you to a few reference pages that you'll fine invaluable for working with the Notion API: - Property Values: https://developers.notion.com/reference/property-value-object - Block Objects: https://developers.notion.com/reference/block - Create a Page: https://developers.notion.com/reference/post-page Note how, for each block, we're setting the relevant property values to the variables in our pokemon object (except for the database ID, which is set by process.env.NOTION_DATABASE_ID). It's also useful to note that EVERYTHING in Notion is a block. The 'data' object will end up being a block that is recognized by Notion as a page due to the 'parent' value we're giving it (a database), and due to the fact that we're using the notion.pages.create() method to create it. However, you can see below that this block has children, which are blocks that will show up as its page content. Note that you can create 'block children' under nearly any block - not just under a page! See more: https://developers.notion.com/reference/patch-block-children */ const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } /* Here we call our sleep() function, passing it a value of 300 so that the loop \"sleeps\" for 300ms before going onto the next cycle. This ensures that we respect the Notion API's rate limit of ~3 requests per second. */ await sleep(300) /* Finally, we actually create the new page in our Notion database. First, we add a log item to the console for our own benefit. Then we call the notion.pages.create() function, which creates a new page in our database. We pass it our data object (defined above), which contains all of the necessary information. Finally, we store the Notion API's response in the response variable, and log it. */ console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } /* When the entire process is done, this will simply print \"Operation Complete\" in the console. */ console.log(`Operation complete.`) } Bonus: My developer’s take on the getPokemon() function As I mentioned above, I only learned how to code in JavaScript this year, so my skills are not well-honed. Fortunately, that doesn’t matter much. These days, computers are so powerful that simple applications can be built many ways. Even if the code isn’t perfectly-optimized, it’s “good enough” so long as it gets the job done and handles errors well. Still, there are often better ways to do things. To show you an example, below I’m sharing my full-time developer Eli’s take on the getPokemon() function. He readily admits that his code is less readable than mine, but it does result in a 40% reduction in code length. In professional setting, my code above would probably get refactored to look more like his. async function getPokemon() { const replacer = (str) => { const n = { \"Mr M\": \"Mr. M\", \"Mime Jr\": \"Mime Jr.\", \"Mr R\": \"Mr. R\", \"mo O\": \"mo-o\", \"Porygon Z\": \"Porygon-Z\", \"Type Null\": \"Type: Null\", \"Ho Oh\": \"Ho-Oh\", \"Nidoran F\": \"Nidoran♀\", \"Nidoran M\": \"Nidoran♂\", \"Flabebe\": \"Flabébé\", } let pn = Object.keys(n).find((o) => str.includes(o)) return pn ? str.replace(pn, n[str]) : str } let urls = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=50`) .then((r) => r.json()) .then((d) => d.results.map(u => u.url)) let base = await Promise.all(urls.map(async (url) => { let d = await fetch(url).then((r) => r.json()) let name = replacer(d.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1) })[0]) return { name: name, number: d.id, types: d.types.map((t) => t.type.name), height: d.height, weight: d.weight, hp: d.stats[0].base_stat, attack: d.stats[1].base_stat, defense: d.stats[2].base_stat, specialAttack: d.stats[3].base_stat, specialDefense: d.stats[4].base_stat, speed: d.stats[5].base_stat, sprite: d.sprites.front_default, artwork: d.sprites.other['official-artwork'].front_default, bulbURL: `https://bulbapedia.bulbagarden.net/wiki/${name.replace(' ', '_')}_(Pokémon)`, } })) let flav = await Promise.all(base.map(async (p) => { let d = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${p.number}`).then((r) => r.json()) return { flavorText: d.flavor_text_entries.find(({language: {name}}) => name === \"en\"). flavor_text.replace(/\\n|\\f|\\r/g, \" \"), category: d.genera.find(({language: {name}}) => name === \"en\").genus, generation: d.generation.name.split(/-/).pop().toUpperCase() } })) return base.map((b, i) => ({...b, ...flav[i]})) } ​ getPokemon().then((r) => { createNotionPage(r) }) What You’ll Need to Get Started To successfully complete this tutorial, you’ll need a few things: A Notion account. Even the free tier is able to work with the API! A Notion database that you’d like to use for your Pokédex (you can start with my template below). An integration in your Notion account. We’ll create this in the first step of the tutorial. A free Glitch account. This is the platform where we’ll build and run the application. Don’t Want to Use Glitch? You can also build and run this project locally on your own computer. Likewise, you could do things like the pros, pushing your code to Github and then deploying it to a company that can host Node.js apps such as Vercel. The reason I’ve chosen to build this project on Glitch is because it gives you a complete starting point for free. We can code directly in the Glitch editor and then run our code directly in Glitch’s terminal. If you’d rather build this project locally, here are the prep steps you’ll need to take: Get a code editor – I recommend VS Code, as it has a built-in terminal for running your code along with many extensions and a huge community. Install Node.js and npm. The Node.js LTS installer should install both. Refer to this guide to see other ways to install (included the recommended-yet-harder nvm method), and to see how you can check that node and npm are indeed installed on your machine. Follow this guide to set up VS Code for a Node.js project and to move into the correct directory where you want to build your app. Once you have your project set up with a package.json file, type npm install axios in the terminal and hit Enter to add the Axios package to your project. It should show up in the package.json file under dependencies. Likewise, type npm install @notionhq/client in the terminal and hit Enter to install the Notion SDK package. Just like on Glitch, you’ll need to create a .env file in your project and add your authentication details to it. However, Glitch automatically takes care of a few things you’ll have to do manually here. First, type npm install dotenv and hit Enter in the terminal to install the dotenv package and add it to your package.json. (Glitch includes this by default.) In your project’s root directory (the same top-level folder where package.json is contained), create a filed called .env (no other file extension). Add your environment variables to this file and hit Save. Replace these default values with your Notion integration key and your target database’s ID. Refer to the Create a Notion Integration section for more detail on this. NOTION_KEY = blargablargblarg NOTION_DATABASE_ID = blargblarg At the top of your index.js file, you’ll also need to include: require('dotenv').config() This will allow your app to access the variables defined in your .env file. You can test this by adding these lines to your index.js file, then running node index.js in the terminal: console.log(process.env.NOTION_KEY) console.log(process.env.NOTION_DATABASE_ID) If you plan on pushing your code to Github or otherwise using git for version control, you’ll also want to create a .gitignore file in your project’s root directory. Then, add .env to that file and commit your .gitignore to your repo (see this more comprehensive guide for more detail): .env From there, you can follow the rest of the instructions in this tutorial. If you’d like to learn more about .env files and running things locally, see this guide: How to Use Environment Variables in Node You can use any database you want to create your Pokédex, but if you’d like a head start, you can use this free Pokédex Notion template I’ve created for you. The template is an exact copy of my public Pokédex, minus all the actual Pokémon. It comes with all the properties and views pre-configured, so you can skip all of the database setup and get to coding. Since I’m providing this template, I won’t cover the database set up in this tutorial. However, if you want to learn more about setting up Notion databases, check out my beginner’s guide to Notion databases. You may also find my complete Notion formula guide helpful for understanding some of the formulas in this template! Tutorial Overview Before we start coding, let’s do a quick overview and cover what we’ll be accomplishing. We know that we want to pull information about each Pokémon from PokéAPI and then create a new page in our Notion database for each Pokémon – but how exactly will we do that? First, the prep work: We’ll set up our Pokédex database on Notion, create a Notion API integration, and ensure the integration is able to edit the database (covered in the very next section). Once that’s done, we’ll build the script that will actually execute the process of getting the data and sending it to Notion. Let’s break down the process. Don’t worry if you don’t know what GET and POST requests are – I’ll explain them as they come up! For each Pokémon, we’ll send a GET request to PokéAPI. This will contain the URL that maps to the specific Pokémon we want information about – e.g. https://pokeapi.co/api/v2/pokemon/4 (you can paste that link directly in your browser to see the response). PokéAPI will accept our GET request if it is formatted correctly. PokéAPI sends back a response that contains all of the Pokémon data we want, plus other meta info. The response contains way too much data, and it’s not always formatted perfectly. So we’ll do some work to process the response directly on our web server (Glitch/Node.js). For each Pokémon, we’ll create a custom JavaScript object called pokeData that will contain all the info we’ll need. We’ll do the work to extract and format the data from PokéAPI and add it to the pokeData object – including name, height, weight, base stats, artwork, etc. We’ll add each pokeData object to an array called pokeArray. Now we’ll make a POST request to the Notion API for each Pokémon within pokeArray. Assuming our request is formatted correctly and authenticated, Notion will create a new page within our Pokédex database, setting property values and populating the page content with the information we sent over. Finally, the Notion API will send back a response that we’ll simply log. Here’s a graphic that shows the entire process visually (you can also view this directly on Whimsical): Now that you’ve got a map in your head for what we’ll be building, let’s build it! Create a Notion Integration The first thing we’ll do is create an integration within your Notion account. This integration will allow you to work with the Notion API and make changes to your workspace. Note: You’ll also find these instructions in the getting started guide within the Notion API docs. We’ll be referencing these docs a lot later on, and I highly recommend getting familiar with them if you plan on building more Notion API integrations! To start, make sure you’ve duplicated my Pokedex template into your Notion workspace. This template contains all the properties and views you’ll need. Next, you’ll need to create an integration in your Notion account. Click here to go directly to the “My Integrations” area of your account. Alternatively, you can find this page by going to Settings & Members within the Notion app, then navigating to My Connections → Develop or Manage Integrations. Click New Integration. Fill out the Basic Information for your integration. You can leave most of the settings at their defaults, but set these as needed: Name: Any descriptive name. I’ll use “Notion Pokedex Integration” in this guide. Associated workspace: Choose the workspace you want this integration to work with (aka the one that contains your Pokedex database). User capabilities: Set to no user infomation. This project doesn’t need user info, and it’s a good practice to limit integrations to only the capabilities they need. Click Submit. Once the integration has been created, you’ll see a field where you can show your internal integration token. Copy this token to your clipboard; you’ll need it when we start setting up the project in Glitch. Important: Keep this token secret. As this tutorial will show you, an integration token allows external tools and scripts to make changes to your Notion workspace. Show the token, then copy it to your clipboard. Additionally, note where it says, “Only works with [your workspace name] workspace”. If you want to work with another workspace, you’ll need to create another integration. You’ll also be able to see that your integration is set as Internal rather than Public. This is what you want! I’m just pointing it out in case you’re unsure which one should be selected. Add Your Integration to Your Pokedex Database Before we can move on, we need to give your integration permission to edit your database. To do that, head to your Pokedex: Click the ••• icon in the top-right corner. Find the Connections sub-menu. Find and select your integration. You’ll see the following message: Notion Pokedex Integration will have access to this and all child pages. Continue? Click confirm. Once connected, you’ll be able to navigate back to that Connections menu and see your connected integration’s permissions for this page. Note that any child pages/databases of the current page will also be accessible to the integration. Now that your integration can modify your Pokedex page, we can move onto the next step! Create Your Glitch Project We’ll be writing our actual code on Glitch, a free platform that lets you built and run websites and apps in a single, easy-to-use interface. To get started, head to Glitch and create a free account. Next, click New Project. You’ll be given the choice of a few different starter apps, but you should actually click Find More, as the one we want isn’t shown here. From this new page, find the Hello Node! starter project and choose the blank version. While you can use the regular Hello Node! app (and I do in the video tutorial above), it comes with a bunch of extra stuff you don’t need. It also doesn’t come with a .env file by default, whereas the blank version does. Select the blank version of the Hello Node! app. Once done, Glitch will set up a new project that is pre-configured to run Node.js, the server runtime that will allow us to run JavaScript code directly from the terminal (instead of needing to run it in web page). What is Node.js? Node.js is a backend runtime environment that allows JavaScript to be executed outside of the browser. Originally, JavaScript was designed to be a programming language that could only run in a web browser. This was initially done for security reasons back when JavaScript was first being built in the mid-1990’s. Over time, people started using JavaScript for more and more purposes. What was once meant to be a simple scripting language started getting used to build complex web applications. In 2009, Node.js was released in order to allow developers to write the JavaScript syntax they were familiar with in other contexts. Node allows JS code to do all sorts of back-end tasks, like processing user data, reading and writing to file systems, and more. If you want to learn more about Node.js, watch this video: The Glitch app gives you a complete development environment. Here’s a quick tour, going over the most important parts: The editor is where you’ll write your code. As you can see below, it can also render markdown files (.md files) with formatting. The sidebar gives you access to all of the files and assets within your project, and allows you to create more. You can also access your project settings here. The terminal will allow you to run your code. This is where we’ll run your Pokedex script. The main thing you should do right now is create an index.js file. This will be the file where we write our JavaScript code in the next steps. To do this: Click the + icon next to Files in the sidebar. Name the file index.js. Click Add This File. For now, you can leave this file blank. We’ll come back to it soon and start coding, but before that, we need to set up our environment variables and import a couple of packages. Let’s go! Set your Environment Variables For the script to be able to send Pokemon data to your Notion workspace, you’ll need to provide it with two pieces of specific information: Your internal integration token (set when you created your Notion integration earlier) The database ID for your Pokedex database Both of these are private pieces of information that shouldn’t be shared. When developing Node.js apps (which we’re doing here), there’s a best practice for storing private pieces of information with which the program needs to directly interact, and that’s to store them in as environmental variables in a .env file. So that’s exactly what we’ll do now, and we’ll start by gathering these pieces of information. What is a .env file? A .env file is a special file that contains environmental variables. These are often variables that hold sensitive information, such as authentication tokes for API access. .env files are never pushed to version-control systems like git, meaning that programmers and teams can use services like Github and even share open-source code without exposing sensitive information. If you want to learn more, check out this video: You should already have your internal integration key from when you set up your Notion integration; if not, head back to the My Integrations page and copy it. Next, we’ll get your database ID. Obtain Your Database ID Your database ID can be found within the URL of your Notion database. To find it, first navigate to your source database in Notion. If you’re using my Pokedex template, note that the template is a normal page that contains the source database. Click the Open as full page button on the database view to access the source database. Once you’re looking at your source database, copy its URL by going to the ••• menu and clicking Copy Link. Alternatively, you can use the shortcut ⌘/Ctrl + L. Within your database’s URL, your database ID is the string of characters after the final / and before the query symbols ?v=. // Full URL https://www.notion.so/thomasfrank/c9cdd00ed7314f9497f4ab23e9fa0bdd?v=2d6e86289d304cd1ab5ba08a0d9ec1b4 // Database ID c9cdd00ed7314f9497f4ab23e9fa0bdd Copy your database ID and paste it in a temporary holding place along with your internal integration token. P.S. – if you don’t have clipboard history enabled on your computer, now’s a great time to turn it on! On Windows, just hit ⊞ Win + V. If you’re on a Mac, get Raycast; it’s an incredibly powerful launcher tool with built-in clipboard history. Edit the .env File Now that you have your internal integration token and database ID, head back to Glitch. Your project should already have a .env file listed in the sidebar. If not, click the + one more time and create a file called .env. Add these two environmental variables. Ensure the labels are NOTION_KEY and NOTION_DATABASE_ID, but replace the example values with your own. NOTION_KEY=secret_LykgP0z2wvrYCiqAaWKu3j5uSokRvosbsqgWaHIjLw6 NOTION_DATABASE_ID=c9cdd00ed7314f9497f4ab23e9fa0bdd As the dialogue box pictured above will tell you, these environmental variable values will be visible to you and anyone else you specifically invite to edit your project. However, anyone else will merely see the variable names – not the values. That means you’ll be able to safely let people view (or even Remix) your project without revealing them. To learn more about how .env works in Glitch, check out their article on Adding Private Data. Add Your NPM Packages The script we’re building uses two external libraries that do a lot of the heavy lifting. These include The Axios HTTP library The Notion API’s JavaScript SDK Once we start coding, I’ll explain what these libraries actually do in more detail. For now, we simply need to bring them into our project and set up index.js so that our code can access and use them. Luckily, bringing these libraries into our project is very easy. Node.js comes with a package manager called npm, which lets developers quickly import packages (which contain these libraries) into their projects. Normally, a developer would install a package by typing npm install into the terminal along with the name of the package. For example, you could install the dadjoke library into your project by typing: npm install dadjoke You can actually do this on Glitch, and I’ll invite you to do so and then type dadjoke in the terminal to see what happens. For clarity: You do not need the dadjoke library for this project; it’s just a very simple library that you can easily use to test the npm install process. However, Glitch provides an even easier way to install packages. Simply head to your package.json file and click Add Package. From there, you can search for packages and click them to install. Search for and install the following packages. I’ve linked their npm pages below in case you need to double-check that you’re installing the right ones. axios @notionhq/client Once done, you’ll see that your package.json file has been updated with new depencies: \"dependencies\": { \"fastify\": \"^4.4.0\", \"handlebars\": \"^4.7.7\", \"@fastify/view\": \"^7.1.0\", \"@fastify/static\": \"^6.5.0\", \"@fastify/formbody\": \"^7.0.1\", \"axios\": \"^1.3.1\", \"@notionhq/client\": \"^2.2.3\" } Aside: NPM Packages Can Break (Here’s What to Do) As of this writing (Februrary 2023), both of the npm packages we’ll use in this project are in a working state. However, I actually went through the experience of dealing with a broken npm package while making this tutorial. After I filmed the video version in November 2022, Axios had a buggy update that broke its ability to make API calls. To make my script work, I had to manually roll Axios back to the 1.1.3 version. Today, Axios’ current 1.3.1 version is working – so you (hopefully) shouldn’t have any troubles with it as you go through this tutorial. That said, if you find that Axios – or any package – isn’t working in the future, here’s what to do. First, check the package’s Github Issues page to see if others are posting about a potential bug. For example, here’s the Issue I ran into with Axios (you can even see a comment from me in this thread). Checking for Issues on Github can help you confirm that there’s a problem with the package itself, rather than your code. Second, simply roll back to an earlier version of the package and see if that works. Axios’ 1.2 version broke my script, but I was able to roll back to 1.1.3 to get it working again. In Glitch, this is incredibly easy – just go into package.json and change the version number of the package. Refresh the page, and Glitch will take care of the downgrade in the background. Note: If you want to “lock in” a specific version of the package, take care to remove the caret ^ symbol – read up on SemVer if you’re curious about that. E.g. 1.1.3 instead of ^1.1.3. Elsewhere (such as your own machine with Node.js installed), run the npm install command with the version you want specified, like so: npm install [email protected] Even if the package is already installed with a later version, this command will replace it with the older version you specify. More detail on how to do this can be found at this post: How to downgrade an installed npm package – Nathan Sebhastian Learn how you can downgrade an npm package to rollback breaking changes sebhastian.com Now you’ve got the packages installed in your project. Before you can use them, however, you’ll need to “require” them within your index.js file. Head over to index.js and add the following lines to the top of the file (which should currently be blank): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) For our purposes, it’s not incredibly important to know exactly how require() works. But if you’re curious, here’s a great article: Everything you should know about ‘module’ & ‘require’ in Node.js by Srishti Gupta Everything you should know about ‘module’ & ‘require’ in Node.js Modules > Node.js treats each JavaScript file as a separate module. For instance, if you have a file containing some code and this file is named xyz.js, then this file is treated as a module in www.freecodecamp.org Make Your First Call to PokéAPI We’re finally ready to start coding! In this step, we’ll make our first call to PokeAPI and log the name of a Pokemon in the Glitch terminal. First, let’s look at how this actually works. In this Replit embed, I’ve created a very simple script that will call PokeAPI once. Go ahead and hit Run to see what happens. If everything went smoothly, you should see bulbasaur displayed in the terminal. Here’s a look at the code: const axios = require('axios') async function getPokemon() { await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) } getPokemon() This very simple script does three things: Uses require('axios') to make the axios library’s methods available for use in the script Defines an asynchronous function getPokemon(), which will call PokeAPI and console log the name of the first pokemon Calls the getPokemon() function in order to run it Once the function is called, the code inside it runs. Here, we’re only doing two things: Using the axios.get() method to call a specific resource within PokeAPI. In this case, it’s the first entry in the pokemon resource, which contains data about bulbasaur. Once we get the response, we use JavaScript’s built-in console.log() function to display the pokemon’s name in the terminal PokeAPI returns JSON data, so we access specific pieces of that data by using dot notation. To get the name, we have to traverse the JSON data tree. Property accessors – JavaScript | MDN Property accessors provide access to an object’s properties by using the dot notation or the bracket notation. developer.mozilla.org PokeAPI is mainly a learning tool, and they actually have a great interface for exploring the API’s data right on their homepage. I’d encourage you to check it out if you want to understand the JSON data structure found in the response a bit better. Here’s a screenshot showing the name that we’re accessing: Here, you can see that there’s a species object, which contains a property called name. (There’s also a separate name property as well, but I’ve found that the species.name property is more reliable to use). Note: You can see all of the properties accessible via this pokemon endpoint at the endpoint’s page in the official PokéAPI docs. Of course, in the code above, we’re accessing: console.log(poke.data.species.name) So where does the poke.data part come into play? poke is a variable that we declare, which holds the entirety of the response from PokeAPI. Let’s look at the API call: await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) I’ll cover the await part in a second; right now, let’s look at the part that says .then((poke) => ... and break that down. The code axios.get(`https://pokeapi.co/api/v2/pokemon/1`) calls the PokeAPI to get the resource stored at https://pokeapi.co/api/v2/pokemon/1. Once the call is finished, we need to do something with the response. The .then() function allows us to do this. Within it, we’re both defining and calling a function (using an arrow function) which stores the entire response in a variable called poke. It then uses console.log() to log the poke.data.species.name property’s value. Using .then() just keeps our code nice and concise. We could re-write it using an old-school function declaration and get the same result: async function getPokemon() { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/1`) log(poke) } function log (poke) { console.log(poke.data.species.name) } But this is more verbose, so using .then() is preferable. Next, let’s address the data property in poke.data.species.name. We don’t see that on the PokeAPI website’s example response, so where is it coming from? As it turns out, the response we get from PokeAPI contains a lot of information. We get a status code, headers, config information, and a lot of other information that we generally don’t need to worry about (but that’s good to have for debugging in case something goes wrong). The entire response is contained within an object, and inside that object there is another nested object called data. This data object contains all the information that you can see on the PokeAPI homepage’s sample response. More on objects: Objects javascript.info In the accordion block below, I’ve included the entire response that PokeAPI returns for this API call. Take a second to look through it and identify the data object. Full PokeAPI Response (Sample) This is the entire response returned by PokeAPI for this API call. Find the data object within it to see how we’re accessing the pokemon’s name (line 238). Note that, by default, console.log() won’t fully show the details of objects that are nested many layers deep. For that reason, most of the information in the data object is simply labeled [Object]. However, when you access specific properties in your code, you’ll get the actual values. For example, poke.data.species.name has a value of bulbasaur, which we were able to see in the console in the Replit embed above. { status: 200, statusText: 'OK', headers: AxiosHeaders { date: 'Fri, 09 Dec 2022 20:29:25 GMT', 'content-type': 'application/json; charset=utf-8', 'transfer-encoding': 'chunked', connection: 'close', 'access-control-allow-origin': '*', 'cache-control': 'public, max-age=86400, s-maxage=86400', etag: 'W/\"359f3-JlmmuiyGZkKyOFlSvLzln1IpB6Q\"', 'function-execution-id': 'tkmw3o8u9p36', 'strict-transport-security': 'max-age=31556926', 'x-cloud-trace-context': '3dba91851bd1a57c6ea5dade1ac7e883', 'x-country-code': 'US', 'x-orig-accept-language': 'en-US', 'x-powered-by': 'Express', 'x-served-by': 'cache-iad-kiad7000067-IAD', 'x-cache': 'HIT', 'x-cache-hits': '1', 'x-timer': 'S1669043889.601956,VS0,VE1', vary: 'Accept-Encoding,cookie,need-authorization, x-fh-requested-host, accept-encoding', 'alt-svc': 'h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400', 'cf-cache-status': 'HIT', age: '51296', 'server-timing': 'cf-q-config;dur=6.9999987317715e-06', 'report-to': '{\"endpoints\":[{\"url\":\"https:\\\\/\\\\/a.nel.cloudflare.com\\\\/report\\\\/v3?s=4KTK4BOb7zSytazr61FEYksT%2BVDQfvoEhzU6Ph%2FYbVr%2Bc9ZgsACueHvhFQy5%2BsijYeXyqKyD3Vo7sBe%2FieNvBWwCdvO%2B55koSkx9YXvyuZQXrpitHk2UCZt3rUoa\"}],\"group\":\"cf-nel\",\"max_age\":604800}', nel: '{\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}', server: 'cloudflare', 'cf-ray': '77707e289bca208d-IAD', [Symbol(defaults)]: null }, config: { transitional: { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, adapter: [Function: httpAdapter], transformRequest: [ [Function: transformRequest] ], transformResponse: [ [Function: transformResponse] ], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, maxBodyLength: -1, env: { FormData: [Function], Blob: null }, validateStatus: [Function: validateStatus], headers: AxiosHeaders { 'User-Agent': 'axios/1.1.3', 'Accept-Encoding': 'gzip, deflate, br', [Symbol(defaults)]: [Object] }, method: 'get', url: 'https://pokeapi.co/api/v2/pokemon/1', data: undefined }, request: <ref *1> ClientRequest { _events: [Object: null prototype] { abort: [Function (anonymous)], aborted: [Function (anonymous)], connect: [Function (anonymous)], error: [Function (anonymous)], socket: [Function (anonymous)], timeout: [Function (anonymous)], prefinish: [Function: requestOnPrefinish] }, _eventsCount: 7, _maxListeners: undefined, outputData: [], outputSize: 0, writable: true, destroyed: true, _last: true, chunkedEncoding: false, shouldKeepAlive: false, _defaultKeepAlive: true, useChunkedEncodingByDefault: false, sendDate: false, _removedConnection: false, _removedContLen: false, _removedTE: false, _contentLength: 0, _hasBody: true, _trailer: '', finished: true, _headerSent: true, socket: TLSSocket { _tlsOptions: [Object], _secureEstablished: true, _securePending: false, _newSessionPending: false, _controlReleased: true, secureConnecting: false, _SNICallback: null, servername: 'pokeapi.co', alpnProtocol: false, authorized: true, authorizationError: null, encrypted: true, _events: [Object: null prototype], _eventsCount: 9, connecting: false, _hadError: false, _parent: null, _host: 'pokeapi.co', _readableState: [ReadableState], _maxListeners: undefined, _writableState: [WritableState], allowHalfOpen: false, _sockname: null, _pendingData: null, _pendingEncoding: '', server: undefined, _server: null, ssl: null, _requestCert: true, _rejectUnauthorized: true, parser: null, _httpMessage: [Circular *1], [Symbol(res)]: null, [Symbol(verified)]: true, [Symbol(pendingSession)]: null, [Symbol(async_id_symbol)]: 3, [Symbol(kHandle)]: null, [Symbol(kSetNoDelay)]: false, [Symbol(lastWriteQueueSize)]: 0, [Symbol(timeout)]: null, [Symbol(kBuffer)]: null, [Symbol(kBufferCb)]: null, [Symbol(kBufferGen)]: null, [Symbol(kCapture)]: false, [Symbol(kBytesRead)]: 6334, [Symbol(kBytesWritten)]: 175, [Symbol(connect-options)]: [Object], [Symbol(RequestTimeout)]: undefined }, _header: 'GET /api/v2/pokemon/1 HTTP/1.1\\r\\n' + 'Accept: application/json, text/plain, */*\\r\\n' + 'User-Agent: axios/1.1.3\\r\\n' + 'Accept-Encoding: gzip, deflate, br\\r\\n' + 'Host: pokeapi.co\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n', _keepAliveTimeout: 0, _onPendingData: [Function: noopPendingOutput], agent: Agent { _events: [Object: null prototype], _eventsCount: 2, _maxListeners: undefined, defaultPort: 443, protocol: 'https:', options: [Object], requests: {}, sockets: {}, freeSockets: {}, keepAliveMsecs: 1000, keepAlive: false, maxSockets: Infinity, maxFreeSockets: 256, scheduling: 'lifo', maxTotalSockets: Infinity, totalSocketCount: 0, maxCachedSessions: 100, _sessionCache: [Object], [Symbol(kCapture)]: false }, socketPath: undefined, method: 'GET', maxHeaderSize: undefined, insecureHTTPParser: undefined, path: '/api/v2/pokemon/1', _ended: true, res: IncomingMessage { _readableState: [ReadableState], _events: [Object: null prototype], _eventsCount: 5, _maxListeners: undefined, socket: [TLSSocket], httpVersionMajor: 1, httpVersionMinor: 1, httpVersion: '1.1', complete: true, headers: [Object], rawHeaders: [Array], trailers: {}, rawTrailers: [], aborted: false, upgrade: false, url: '', method: null, statusCode: 200, statusMessage: 'OK', client: [TLSSocket], _consuming: true, _dumped: false, req: [Circular *1], responseUrl: 'https://pokeapi.co/api/v2/pokemon/1', redirects: [], [Symbol(kCapture)]: false, [Symbol(RequestTimeout)]: undefined }, aborted: false, timeoutCb: null, upgradeOrConnect: false, parser: null, maxHeadersCount: null, reusedSocket: false, host: 'pokeapi.co', protocol: 'https:', _redirectable: Writable { _writableState: [WritableState], _events: [Object: null prototype], _eventsCount: 3, _maxListeners: undefined, _options: [Object], _ended: true, _ending: true, _redirectCount: 0, _redirects: [], _requestBodyLength: 0, _requestBodyBuffers: [], _onNativeResponse: [Function (anonymous)], _currentRequest: [Circular *1], _currentUrl: 'https://pokeapi.co/api/v2/pokemon/1', [Symbol(kCapture)]: false }, [Symbol(kCapture)]: false, [Symbol(kNeedDrain)]: false, [Symbol(corked)]: 0, [Symbol(kOutHeaders)]: [Object: null prototype] { accept: [Array], 'user-agent': [Array], 'accept-encoding': [Array], host: [Array] } }, data: { abilities: [ [Object], [Object] ], base_experience: 64, forms: [ [Object] ], game_indices: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], height: 7, held_items: [], id: 1, is_default: true, location_area_encounters: 'https://pokeapi.co/api/v2/pokemon/1/encounters', moves: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], name: 'bulbasaur', order: 1, past_types: [], species: { name: 'bulbasaur', url: 'https://pokeapi.co/api/v2/pokemon-species/1/' }, sprites: { back_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/1.png', back_female: null, back_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/shiny/1.png', back_shiny_female: null, front_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png', front_female: null, front_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/1.png', front_shiny_female: null, other: [Object], versions: [Object] }, stats: [ [Object], [Object], [Object], [Object], [Object], [Object] ], types: [ [Object], [Object] ], weight: 69 } } You may have also noticed the async and await keywords shown in our sample script. These have to do with asynchronous JavaScript and Promises, two topics that are intermediate-level in complexity. I’ll explain them in the accordion block below and link you to some useful resources for learning them in more detail, but the gist is this: Axios is a “promise-based” library, and to use it correctly within our script, we need to use async and await. If we don’t, responses might come back from the PokeAPI out-of-order. Of course, there are other JavaScript tools for working with APIs that don’t force you to use Promises (like fetch), but I’m choosing to use Axios for this tutorial because it’s the default option used by Pipedream, which is an amazing automation platform that I’ll be using for upcoming Notion API tutorials. More Detail on Pipedream Pipedream is a code-light platform that I’ll be featuring in upcoming tutorials; it’s generally a much easier tool for working with the Notion API and creating automations compared to what we’re doing here. I’ve used it personally to mirror Notion databases, send YouTube stats to Notion, create a speech-to-text automation, and more. I’m not using it for this tutorial because I want you to be fully aware of what’s happening while you learn the Notion API, and because you may want to go off and build apps on your own tech stack! So this tutorial is sticking to more general purpose tools – but I did want to base it off of Axios so you’ll be fully prepped when you deal with it on Pipedream. More About Async/Await and Promises Axios is a “promise-based” library, which means that when we use the axios.get() method, we get a Promise. In JavaScript, a Promise is essentially an IOU. It’s almost as if JavaScript is handing you a piece of paper that says: “I promise to give you the full results of this API call if it is successful. And if it fails, I’ll give you details about the error. The actual response, be it the successfully-retrieved data from the API or an error message, comes later on once the Promise resolves. In general, this is quite useful because JavaScript is a single-threaded language, which means that it generally can only do one thing at a time. This can become a problem with API calls, because they can often take a (relatively) long time to execute. In a program where lots of things are happening, an API call can block additional code steps that would otherwise execute extremely fast. Promises allow that later code to execute before something like an API call finishes, since the Promise gets returned almost immediately. In complex applications, this means later code steps can do their thing, and then once the Promise resolves, you can take action on the actual response from the API. As I mentioned above, I’m choosing Axios for this project specifically because Pipedream uses it heavily and I’ll be doing lots of Pipedream/Notion API tutorials in the future. However, what we’re doing here doesn’t really need Promises or async/await. Our script is going to get all the information about all the Pokemon before doing anything else, so we would be fine to go with a totally synchronous option here if we wanted. Still, asynchronous JavaScript can be very useful in other cases. If you want to learn more about it, here are some resources. First, I highly recommend watching this talk on the Javascript event loop if you want to understand how JavaScript can be “asynchronous” despite being single-threaded: Next, I’d recommend watching my friend Daniel Shiffman’s series on Promises and async/await: JSInfo also has some great articles on these topics: Promises Async/await With all that preamble out of the way, let’s start coding! In the embedded Replit above, we made a single call to PokeAPI and logged bulbasaur’s name in the terminal. Let’s take that a step further and set the foundation for our script by adding the following code to index.js in our Glitch project (everything from here on out will go in index.js): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Note: From this point on, we’ll often be adding new code in between existing lines. Sometimes we’ll even change existing lines. I’m doing it this way so the learning curve in this tutorial remains gradual. I’ll make sure to highlight those lines in the code blocks that follow this one. Remember, you can always reference the full code (with or without comments) in the Steal My Code section above. In your terminal, type node index.js and then hit Enter to run your script. If you’ve set things up correctly so far, you should get a list of the first 10 Pokemon: This code is very similar to the code in the embedded Replit example above. One change is the addition of these lines: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] The first two are creating a notion variable and bringing in the Notion SDK that we imported earlier, so we can use it within our script. We’ll start using it in earnest below when we send our first page to Notion. We’re also creating an empty array with const pokeArray = []. As I mentioned in the tutorial overview, we’ll be adding an object for each Pokemon to this array. Then, we’ll loop through the array and create a new page in Notion for each of those Pokemon objects. Another big difference is that we’ve added a for loop to the function; now we’re calling the PokeAPI from inside it. Loops: while and for javascript.info This means that we’re making a call to PokeAPI every time the loop executes. Additionally, we’ve tweaked our axios.get() function call slightly. It now reads: axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) We’ve wrapped our PokeAPI URL in template literals (the backticks ``), which allows us to use variables within it. Template literals (Template strings) – JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org We can use ${} to reference a variable within our string; in this case, we’re referencing i, which increases by 1 each time the loop runs. In effect, each execution of the loop calls the next Pokemon from PokeAPI: https://pokeapi.co/api/v2/pokemon/1 https://pokeapi.co/api/v2/pokemon/2 https://pokeapi.co/api/v2/pokemon/3 …and so on. The start and end variables define how many times the loop will run. Currently, we’ve set them so that the loop runs 10 times, but hopefully you can see how tweaking them would let us get all 905 Pokemon! Finally, I’ll point out the addition of the .catch() block of code: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) If our API throws an error for some reason, the catch block will be activated. Right now, we’re just logging the error in the console, but you could add more sophisticated error-handling code if you wanted. Learn more here: Error handling, “try…catch” javascript.info Code Checkpoint At this point, your code should look exactly like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Format the Pokémon Data The next thing we need to do is construct an object that will hold the information about each Pokemon that we want to send to Notion. That information includes: Name Number Type(s) Category – e.g. “Flame Pokemon” or “Seed Pokemon” Generation Height Weight HP Attack Defense Special Attack Special Defense Speed Sprite Official Artwork Flavor text Bulbapedia URL We could declare individual variables for each of these, but a better method is to construct an object and store the values inside it. In JavaScript, an object is a collection of key:value pairs. Object keys always have defined names, and the key:value pairs do not have a specific order (unlike arrays). Objects are heavily used in JavaScript, so check out this primer if you want to learn more about them: Objects javascript.info We’re going to create an object for each Pokemon that will store all of the data we want to send to Notion. For now, we won’t add all of the information. Instead we’ll stick with a few basics – name, number, height/weight, and basic stats. This will keep things simple; we’ll add the other pieces later on. Remove the old console.log() line, and add the highlighted code within your .then() block: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) In the pokeData object declaration, we are creating several keys, such as name, number, height, etc. The value that corresponds to each key is dynamically set by accessing a specific value from the poke object, which contains the entire response from PokéAPI. Later, we’ll access the values of this object in order to send information to Notion. You can see that we’re already doing it once here: console.log(`Fetched ${pokeData.name}.`). After declaring the pokeData object and filling it up with values, we also add the object onto the end of our pokeArray array with pokeArray.push(pokeData). You may remember that we declared that array near the top of our code: const pokeArray = []. The [] symbols define the variable as being an array, but when it was declared, it was empty. In other words, it was an array with no elements inside it. Using the push method, we “push” our pokeData object onto the end of the array. You can learn more about how this method works here: Array.prototype.push() – JavaScript | MDN The push() method adds one or more elements to the end of an array and returns the new length of the array. developer.mozilla.org Before we move on, you should also change your const end = 10 line to const end = 1 for now: async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { This will cause the script to fetch only the first Pokémon, Bulbasaur. Later, we’ll change it to a higher number so we can fetch hundreds of Pokémon – but for now, it’ll keep things simpler if we fetch just one. Once again, run node index.js in your terminal. You should see a result like this: The console.table() method is another useful tool for seeing information in the terminal. It nicely formats data structures like objects, and by using it we can see all of the properties that we created within the pokeData object. I’ve removed the console.table() line from my final code; you can choose whether or not to do the same. Leaving it in won’t change anything, as it’s just a logging tool. Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) }) .catch((error) => { console.log(error) }) } } getPokemon() Create Your First Page with the Notion API Now that we have a tidy little object full of Pokémon data, let’s send it to Notion and create the first page in our Pokédex! To do that, we’ll declare a second function called createNotionPage() at the bottom of our code, beneath the getPokemon() function call. Additionally, we’ll call the createNotionPage() within the getPokemon() function’s declaration, at the very end before its closing curly brace. Go ahead and add the highlighted lines to your code: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } We’ll go through what this code does in a second. For now, we’re going to run the code and see what happens. First, you’ll need to go to your Pokédex database’s ••• menu, go to Group, and set the No Generation option to visible. We currently aren’t passing generation information, so you’ll need to do this in order to see the page you’re about to send to Notion. Next, go ahead and run node index.js in the terminal once more. If your code and .env variables are set up correctly, you should see something similar to this in your terminal: [email protected]:~ 23:48 $ node index.js Fetched bulbasaur. ┌─────────────────┬─────────────┐ │ (index) │ Values │ ├─────────────────┼─────────────┤ │ name │ 'bulbasaur' │ │ number │ 1 │ │ height │ 7 │ │ weight │ 69 │ │ hp │ 45 │ │ attack │ 49 │ │ defense │ 49 │ │ special-attack │ 65 │ │ special-defense │ 65 │ │ speed │ 45 │ └─────────────────┴─────────────┘ Sending bulbasaur to Notion { object: 'page', id: '64499d85-9748-4ddd-a08b-38a8c6dd6a2c', created_time: '2023-02-05T23:49:00.000Z', last_edited_time: '2023-02-05T23:49:00.000Z', created_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, last_edited_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, cover: null, icon: null, parent: { type: 'database_id', database_id: 'c9cdd00e-d731-4f94-97f4-ab23e9fa0bdd' }, archived: false, properties: { Height: { id: 'C%3FgF', type: 'number', number: 7 }, 'Weight (kg)': { id: 'Dn_%5D', type: 'formula', formula: [Object] }, Attack: { id: 'MRaQ', type: 'number', number: 49 }, 'HP Label': { id: 'MdMo', type: 'formula', formula: [Object] }, Weight: { id: 'N%3BN%7B', type: 'number', number: 69 }, 'Stats Meta': { id: 'NZS%7B', type: 'formula', formula: [Object] }, HP: { id: 'Rce%7D', type: 'number', number: 45 }, 'Sp. Attack': { id: 'U%7Bi%40', type: 'number', number: 65 }, 'Defense Label': { id: 'VRMi', type: 'formula', formula: [Object] }, Sprite: { id: '%5BlYm', type: 'files', files: [] }, No: { id: '%5DY%40D', type: 'number', number: 1 }, 'Ht/Wgt Meta': { id: 'cjoi', type: 'formula', formula: [Object] }, Speed: { id: 'dCkj', type: 'number', number: 45 }, 'Height (m)': { id: 'e%5DNz', type: 'formula', formula: [Object] }, Defense: { id: 'iLgx', type: 'number', number: 49 }, 'Height (ft)': { id: 'i%5DgP', type: 'formula', formula: [Object] }, Meta: { id: 'oBLz', type: 'formula', formula: [Object] }, 'No Label': { id: 'oLD%3B', type: 'formula', formula: [Object] }, 'Sp. Defense': { id: 'pmEd', type: 'number', number: 65 }, 'Weight (lbs)': { id: 'qT%5Er', type: 'formula', formula: [Object] }, Generation: { id: 'q%5CeI', type: 'select', select: null }, Type: { id: 'smaD', type: 'multi_select', multi_select: [] }, Category: { id: 'tESh', type: 'rich_text', rich_text: [] }, 'Attack Label': { id: 'xLfc', type: 'formula', formula: [Object] }, Name: { id: 'title', type: 'title', title: [Array] } }, url: 'https://www.notion.so/bulbasaur-64499d8597484ddda08b38a8c6dd6a2c' } Operation complete. You should also see a new Bulbasaur entry in your Pokédex: Congratulations! You’ve just created your first page in Notion using the Notion API. If it didn’t work, make sure you added the line calling createNotionPage() right before the closing } in your getPokemon() function! Now let’s walk through these code additions and see what’s actually happening. The code we added here does five distinct things: Declares the createNotionPage() function. Creates a for...of loop, which allows us to iterate over the elements of pokeArray, performing the same set of actions (defined within the loop) on each one. Defines a data object, which is formatted in the way the Notion API wants, and which is filled with the values of the current object within pokeArray that the loop is working on. Sends a POST request to the https://api.notion.com/v1/pages endpoint of the Notion API in order to create a new page, using the information from the data object Finally, calls the createNotionPage() function from within the getPokemon() function, after everything else in that latter function has finished executing. At this point, the basic structure of the entire script is in place. You can jump back up to the flow chart (or view it on Whimsical in a new tab) to see that entire structure, but here’s a super-quick refresher. When you run node index.js in the terminal, the following process kicks into high gear: Axios and the Notion API client are imported, the notion variable is created, and the pokeArray array is created (initially empty). getPokemon() is called. Within getPokemon(), a loop executes. For each loop iteration, we make a call to PokéAPI for a Pokémon, then place the data we want from the response into an object called pokeData. We then push that pokeData object onto the end of pokeArray. After the loop has finished running as many times as is defined, we call createNotionPage(). Inside createNotionPage(), we have a loop that will execute for each object within pokeArray. Each time, it will take the data from the current object within pokeArray being worked on, place it in the data object, then send that object off to Notion within a request to create a new page. In other words, we go through one loop to called PokéAPI a bunch of times and load up our pokeArray with lots of objects (one for each Pokémon), then we go through another loop a bunch of times to send those objects to our Notion Pokédex. Now that you understand the gist of what’s happening, let’s dig into the actual call being made to the Notion API. First, I’ll briefly cover what’s happening in our for...of loop: for (let pokemon of pokeArray) This is a looping construct that iterates over every element in pokeArray. As you’ll recall, each element in that array is an object, defined by the pokeData object definition, which holds information about each Pokémon. Each time the loop executes, the current element of pokeArray is temporarily stored in the pokemon variable defined in the loop declaration. This means that we can access the Pokémon’s name like so: pokemon.name Earlier in the script, we used pokeData.name to do the same thing. But since we define the variable name as pokemon in the loop declaration, we now use pokemon instead of pokeData. More detail on for…of loops In the code above, you can see that we’re using a for...of loop to iterate over our array: for (let pokemon of pokeArray) { } This is a type of for loop that can iterate over the values of an array or an object (for... in loops can iterate over the keys). You can see the differences between for...of and for...in here: For-In vs For-Of | Kevin Chisholm – Blog blog.kevinchisholm.com In most cases, you want to access the actual values of an object or array, so a for...of loop is cleaner. Note that you could also write a normal for loop, using the array’s length to set the end parameter: for (let i = 0; i < pokeArray.length; i++) { } Since we’re working on an array, these approaches are functionally identical. Next, let’s look at the data object declaration. const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } data is an object that is structured exactly as the Notion API expects. Of course, you may now be wondering… how do I know how to structure the object? That’s where the Notion API documentation comes in – and you’re going to want to get very familiar with it. In this case, I looked at the reference for creating new pages: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com On this page, you can get all the information you need to properly structure your request to the API. Let’s go over a few important parts of this page: First, at the top of the page you’ll see the endpoint URL and the method required for sending this type of request. For creating a page, you send a POST request to https://api.notion.com/v1/pages – or you use a method that does the same for you (e.g. using notion.pages.create() as we are in our script). Second, you’ll see the body parameters that can be sent with the request. You’ll also see the ones that are required – in this case, the parent (which is either a database or an existing page) and the properties. Third, you’ll see the example code area. This shows a sample request, which you can use as a reference for modeling your own request. Additional Example Options Note that you can use the dropdown menus to see other requests. The default example uses the official Notion SDK for JavaScript, which we’re using in this project as well. It provides lots of handy methods for making API requests without writing as much code. However, you can see several other examples. If you change the dropdown from Notion SDK to Axios, for example, you’ll see this code: import axios from 'axios'; const options = { method: 'POST', url: 'https://api.notion.com/v1/pages', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json' } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); My only issue with this example code is that it actually doesn’t give you all of the information you need to make a request using Axios. Perhaps they’ll fix this in the future (you may see different code if you’re reading this well after I publish it), but for now, it’s incomplete. Here’s the full code you’d need to use to create a page using Axios: const axios = require('axios') const options = { method: 'POST', url: 'https://api.notion.com/v1/pages/', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json', Authorization: `Bearer ${process.env.NOTION_KEY}` }, data: { parent: { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, properties: { \"Name\": { \"title\": [ { \"text\": { \"content\": \"Test Page\" } } ] } } } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); The code is quite similar, but you can see that I’ve included two new pieces of information: An Authorization property in the headers object, containing my integration’s secret key A data object that contains both the parent and the properties. Both of these are required, yet they aren’t shown in the Axios example. This is a harsh truth I’ve learned as I’ve gone through my journey of learning APIs; you’re often expected to know a lot of fundamentals, and API documentation often doesn’t hold your hand. This is likely because developers are trying to write mountains of documentation very quickly, and they’re also experienced enough to know the missing pieces by heart. Unfortunately, us noobs are often left scratching our heads as a result! Fourth, you can see examples of responses that the API will send back. Here on the Create a Page doc, there are four possible responses: 200 – a successful response, indicating that the page has been created. 400 – invalid request (can mean several things) 404 – resource does not exist (in this case, the parent) 429 – your application has been rate limited You can see a full list of the error responses that the Notion API may return here: Errors Responses from the API use HTTP response codes are used to indicate general classes of success and error. Error responses contain more detail about the error in the response body, in the “code” and “message” properties. developers.notion.com Using the information on this page – especially the example code – I was able to properly construct the data object. There’s one other page that came in very handy for constructing this request, and that’s the Property Values reference: Property values A property value defines the identifier, type, and value of a page property in a page object. It’s used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with … developers.notion.com Note: This page is currently not shown in the sidebar of the API reference. It’s quite hard to find, and it’s the only page that shows you explicitly how to set property values when creating or updating pages. There is also a Page Property Values page, which is listed in the sidebar, and which has a very similar title – but only shows you the responses that you get when you retrieve property values. Notion is in the middle of merging these two pages, but as of this writing, that process hasn’t been completed yet. This page will show you how to properly construct an object in order to set any kind of property value (that is supported by the API). For example, here’s how you’d set a value in the number-type property called No: \"No\": { \"number\": 42 } Important Note: That first key value (in this case, “No”), must match the name of the property in your database. Using the property references on that page, you’ll be able to figure out how to structure your request and add values to all of the properties in your target database (if indeed you’re creating a page in a database). Finally, we have this small block of code that actually sends the request to Notion: console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) Here, we’re simply using the notion.pages.create() method, passing our data object as the argument. Note that we could have defined the object directly between those parentheses, but I find it cleaner to define it first and then simply pass the variable as the argument. The console.log() lines simply log information in the terminal. Before we move one, I’d like to cover one more quirk from our data object definition: \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, Note how the first line accesses the defense property: pokemon.defense – this method of accessing object properties is called dot notation. It can be used when the property name contains only letter, numbers, or underscores. When a property name contains other characters – such as spaces or dashes – then you must use bracket notation to access it. The line accessing special-attack shows how: pokemon['special-attack']. Learn more here: Property accessors – JavaScript | MDN Property accessors provide access to an object’s properties by using the dot notation or the bracket notation. developer.mozilla.org Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Create Multiple Pages at Once Now that we have the basic structure of our script in place, it’s time to kick things up a notch and fetch multiple Pokémon at once. Fortunately, we already have both of our loops in place! So all we need to do in this step is: Tweak the end variable so that the initial loop runs more than once, and fetches more than one Pokémon Add a “wait” function to prevent our script from getting rate-limited Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Now let’s test this out. First, delete your original Bulbasaur entry from your Pokédex, since it will be recreated. Next, run node index.js in the terminal once more. If everything goes smoothly, you should see a lot of log information in your terminal. Additionally, you should now have ten entries in your Pokédex: Let’s go over what we’ve added. The first change here is pretty simple. We’re just changing const end = 1 to const end = 10, which will cause our initial loop to run ten times. This means that we’ll make ten called to PokéAPI and add ten objects to pokeArray. The other change is the addition of the following code beneath the getPokemon() call: const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; This is a simple function that takes a single argument (a number) and will cause the script to wait that many milliseconds before continuing whenever we call it. You can see that we’re calling it right before sending each page to Notion: await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) JavaScript doesn’t have a built-in sleep() function as some other languages do, but we can use the above code to approximate one. It uses a combination of setTimeout() (a built-in Web API method), a Promise, and async/await to essentially pause the script for the number of milliseconds we specify. More Detail on the sleep() function You don’t really need to understand the nuts and bolts of the sleep() function to use it; you can basically just copy and paste. However, if you’re curious about how and why it works, here’s a brief overview. The built-in setTimeout() function will set a timer and execute a function after the timer is up. Here’s the reference for it: setTimeout() – Web APIs | MDN The global setTimeout() method sets a timer which executes a function or specified piece of code once the timer expires. developer.mozilla.org However, setTimeout() will not delay the execution of the next line of code. We can get around this issue by creating a Promise within our sleep() function, which is only fulfilled after the setTimeout() call inside it has finished running. Then, by calling the function with the await keyword (e.g. await sleep(300)), we effectively cause our script to pause for 300 milliseconds before moving on. The MDN documentation on Promises explains why this works: Promise – JavaScript | MDN The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. developer.mozilla.org You can also get more detail on this sleep() function itself here: JavaScript Sleep: How to Pause Code Execution JavaScript does not have an inbuilt sleep function but thanks to the introduction of promises and async/await, we can implement such sleep in JavaScript. appdividend.com Why are we doing this, though? The reason is that requests to the Notion API are rate-limited, meaning you can’t send a huge number of requests super-quickly to it. Notion is not unique here; almost all APIs have some kind of rate-limiting implemented. The Notion API currently allows an average of three requests per second: The rate limit for incoming requests per integration is an average of three requests per second. Some bursts beyond the average rate are allowed. Read more here: Request limits To ensure a consistent developer experience for all API users, the Notion API is rate limited and basic size limits apply to request parameters. Rate limits Rate-limited requests will return a “rate_limited” error code (HTTP response status 429). The rate limit for incoming requests per integration … developers.notion.com This doc also mentions that a rate-limited request (e.g. one that fails due to hitting the rate limit) will return a 429 error. If you get this, you’re supposed to set up your code to try the request again after a number of milliseconds that is specified in the Retry-After header value in the 429 response. However, a quick-and-dirty way to make sure we never even see a 429 response is to make sure our script never sends requests too quickly. Hence our await sleep(300) line before the actual call to the Notion API – we are waiting 300ms before sending each request, keeping our average very close to that three-requests-per-second limit. There are certainly more sophisticated ways you could handle Notion’s rate limits, which would likely make your application run faster. I’d encourage you to explore them as you continue to learn and build! Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Refine Your Pokémon Data At this point, your script can send basic information about multiple Pokémon to Notion all at once. Now we’ll start the process of adding additional information to each Pokédex entry, as well as refining some of the information we already have. Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } Remember, you can always jump back up to the Steal My Code section to see the final version of the code. This step adds a lot of code, and makes some significant changes to the pokeData object declaration. If you’re starting to feel overwhelmed, now might be a good time to get up and take a short break! I made a video about how breaks are crucial to learning and productivity a while ago, and it even has a Pokémon in the thumbnail… so you know I have to include it here. Once you’re feeling fresh, let’s take some time to go through each of these new additions to our code. At a glance, here’s what we’re accomplishing in this step: Get and store each Pokémon’s type(s) Reformat each Pokémon’s name to look nicer (e.g. changing “mr-mime” to “Mr. Mime”) Construct a valid Bulbapedia URL for each Pokémon, which we’ll later embed in that Pokémon’s page content Get and store the sprite and/or official artwork for each Pokémon Each of these steps has a specific code block. For now, we’re simply getting and formatting this information; we’ll send it to Notion in a later step. First, we get the Pokémon’s type – or multiple types! const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } This presents a bit of a challenge. Pokémon can have up to two types, and PokéAPI returns each Pokémon’s type(s) as an array filled with objects. See for yourself at the official docs for the pokemon endpoint. This means we have to: Dig into each object within the types array and get the name of each type Place to types into a new array of objects, structured in the way that the Notion API requires To do this, we create a typesRaw variable, setting its value to the entire array of types from the API response: poke.data.types. We also create a new empty array called typesArray. Once again, we’re using a for...of loop to iterate over typesRaw. Inside, we declare an object called typeObj, setting its name property to type.type.name. The first type in that object is simply the type variable we defined in the for...of loop declaration, which represents the current object being iterated over. The second is the actual type property, the value of which is an object containing the name property (in addition to a url property that we aren’t using). Next, we format the Pokémon’s name so it looks nicer. This process also has a secondary benefit; it will allow us to construct valid Bulbapedia URLs later. const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") We’re doing a lot here code-wise, but the aims are simple: Capitalize each Pokémon’s name Handle edge cases where we need to add periods, accent characters (é), dashes, colons, or gender symbols (♂, ♀) How this code works This block of code may initially look confusing, as it is quite dense. The reason for this is that I’ve used method chaining to condense it. In JavaScript, you can call methods one after another with periods. This results in code that takes up less space, and for experienced programmers it can often be more readable. However, for a beginner, it may be intimidating. So the best way to explain this code will be to rewrite it as distinct steps on their own lines. Run the code here, then view the source: Here, I have both the distinct steps as well as the method-chained approach in the code. As you can see, both methods give the same exact result. However, using method-chaining takes up far fewer lines. Learn more about method chaining: Here’s what the code actually does, in order: Splits the name into an array of single-word values (will usually create a single-element array, but this is needed for Pokémon like Mr. Mime and Type: Null) Uses map() to iterate over the returned array, executing these steps on each element: Use toUpperCase to capitalize the first letter of the name Concatenate that capitalized letter with the rest of the name (using substring() to get everything except the first letter) Join the elements of that array back together as a single string, separating each with a space character (\" \") Use replace() to handle edge-case replacements, such as replacing “Mr M” with “Mr. M” As for the actual methods being implemented here, I’ll link to the docs for each one: String.prototype.split() Array.prototype.map() String.prototype.toUpperCase() (using bracket notation to access the first character in the string) String.prototype.substring() Array.prototype.join() String.prototype.replace() Third, we construct the Bulbapedia URL: const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` This step is fairly straightforward. We create a variable called bulbURL and set its value by creating a template literal (using the backtick ` characters), which allows us to reference variables within the string. Template literals (Template strings) – JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org Bulbapedia has an extremely rigid structure for its URLs. It’s always the same, except for the Pokémon name: https://bulbapedia.bulbagarden.net/wiki/Charmander_(Pokémon) https://bulbapedia.bulbagarden.net/wiki/Squirtle_(Pokémon) https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pokémon) Thus, our URL structure just needed to use processedName to set the correct URL. The only fancy thing we’re doing here is using replace() to replace any space characters with underscores: `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` More on replace(): String.prototype.replace() – JavaScript | MDN The replace() method returns a new string with one, some, or all matches of a pattern replaced by a replacement. The pattern can be a string or a RegExp, and the replacement can be a string or a function called for each match. If pattern is a string, only the first occurrence will be replaced. The original string is left unchanged. developer.mozilla.org Fourth, we define a variable called sprite that holds either the Pokémon’s sprite or its official artwork: const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default The reason we need to do either/or here is because Pokémon from Pokémon Legends: Arceus and later games don’t have sprites (their models are 3D). As a result, PokéAPI doesn’t have a sprite object for them, meaning we need to grab their official artwork instead. Finally, we add our new key:value pairs to the pokeData object definition: sprite, bulbURL, and typesArray. Additionally, we change the value of the name property to be our new processedName variable. const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } If you’d like to test your code at this point, I’d recommend commenting out the createNotionPage() function call. Adding // to the beginning of that line will turn it into a comment, preventing it from executing. // createNotionPage() Doing this will allow you to see the log information for your code changes without sending more pages to Notion (which we’re not yet ready to do). Run node index.js in the terminal once more, and you should see log information like this: Here, our console.table() reports are now showing our nicely-formatted Pokémon names. We can also see the URLs for the sprite, official artwork, and Bulbapedia page. Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is commented-out at this point; later, we’ll remove the comment symbols to enable it again. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Get Flavor & Generation Data for Each Pokémon In the last step, we added quite a lot of new information to our pokeData object definition. However, we’re still missing a few vital pieces – including each Pokémon’s: Generation (e.g. Gen I, II, III…) Category/Genera (e.g. “Flame Pokémon” or “Dancing Pokémon”) Flavor Text The reason we haven’t gotten these pieces of information up until now is because they’re accessible via a completely different endpoint of PokéAPI: the pokemon-species endpoint. All of our previous information came from the pokemon endpoint. In fact, PokéAPI has several different endpoints under the “Pokémon” umbrella: My guess as to why they’ve designed their API this way is to simply cut down on the amount of information that is returned from a single request. In any case, we need to query the pokemon-species endpoint in order to get these piece of information. To do so, add the following lines to your code, just above your createNotionPage() function call within the getPokemon() function: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } //createNotionPage(); } This code sets up a for...of loop, just as we did when we created our createNotionPage() function (click here to jump back to that section if you need a refresher). Within that loop, we’re using Axios to call the pokemon-species endpoint. Note how we use the pokemon.number property to define the specific URL: await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) Since we’re iterating over each element of pokeArray, we’re just taking the number obtained from our previous call to the normal pokemon endpoint. Once we get the response, we do three things: Declare the flavorText, category, and generation variables, setting their values by accessing the relevant information from the API response and formatting it. Add new properties to our pokeData object, setting their values using the variables we just declared. Log the event in the console. Note that we could easily combine steps #1 and #2 here; we don’t need the interim variables (e.g. flavorText). I’ve only split these steps up to make things clearer. There’s actually a lot going on here, and the steps we have to take to access and format the data in step #1 here are quite technical. Therefore, I’ll put each of them in a toggle that you can read through if you want. Flavor Text and Category To fetch and format the flavor text, we use this line of code: const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") We do nearly the exact same thing to get the category, just without the replace() call at the end: const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus Here I’ll break down the flavorText variable assignment, but it applies to category as well. Once again we’re method-chaining here, using these methods: Array.prototype.find() String.prototype.replace() Here’s the problem we need to solve with flavor text: the pokemon-species endpoint’s response contains an array called flavor_text_entries – which may contain many flavor text objects in different languages. Additionally, the english flavor text is not always at the same index in the array – so we can’t just target a particular index. Instead, we need to search through each object, find the one where the value of flavor_text_entries[X].language.name equals \"en\", and then get the flavor_text property from it. Chespin’s record stores the English flavor text at array element #6. To do this, we use the find() method, which will search through an array and return the first element that satisfies the condition we specify in a testing function. To make this clearer, let’s look at a simple embed that just uses find() to return the flavor_text entry from the array element that contains the English text: In our test function, we’re doing something called nested object destructuring. This will make sense more readily if you understand destructuring in general: Destructuring assignment javascript.info Once you understand destructuring, you can dig into nested object destructuring: Nested Destructuring Learn how to use nested destructuring on nested objects with JavaScript. davidwalsh.name The gist, though, is that instead of setting the entire object we’re currently iterating over as the argument in our test function, we’re “digging into” that object and setting only the nested name property as the argument instead. From there, find() iterates over each element in the flavor_text_entries array until it finds the one where that nested name property’s value is \"en\". Since the matched array element is the return value, we can simply access its flavor_text property (end of this line): const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text Unfortunately, this flavor text often contains lots of newline characters that make the text look very wonky. To deal with that, we finish our method chain with a replace() call: replace(/\\n|\\f|\\r/g, \" \") Here, I’m using a regular expression to replace every instance of a newline character (typically these will be \\n, but they can also be \\f or \\r) with a space character. Here’s how that works: The / characters define the beginning and end of the regular expression to be matched \\n, \\f, and \\r are all the possible “newline” characters that will cause a line break in a string The | character means “or” Finally, the g flag means “match every instance of this expression, not just the first one Regular expressions are a whole subject unto themselves, but if you want to learn them, start here: RegexOne – Learn Regular Expressions – Lesson 1: An Introduction, and the ABCs RegexOne provides a set of interactive lessons and exercises to help you learn regular expressions regexone.com You can find more regular expression resources at the Regex guide in my Notion Formula Reference: Regular Expressions in Notion Formulas – Notion Formula Reference Learn how to use regular expressions in Notion’s test(), replace(), and replaceAll() functions. learn.thomasjfrank.com Generation Getting and formatting the generation is easier than getting the flavor text and category. We use this code: const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() Here we’re fetching the generation, which PokéAPI formats like so: generation-vi. We want a simple Roman numeral, like VI. We also want it capitalized. To do that, we go through this process: split() to split the string into array elements, using the - character as our separator pop() to remove the last element of the returned array and (more importantly) return it toUpperCase() to fully capitalize that returned element Once we have those variables set, we simply create new properties in the current pokemon object (defined earlier by the pokeData definition, then represented as pokemon via the for...of loop definition): pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation As you can see, all we have to do is create the new property with either dot notation or bracket notation, depending on the characters in its name. Read more on this here: How to Add Property to an object in JavaScript? – Scaler Topics In this article by Scaler Topics, we will look at different ways of adding a property to an object in JavaScript using different methods and examples. www.scaler.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Add New Data to the Notion API Call We’re at the last code step! All we need to do now is modify the data object definition within our createNotionPage() function, adding the new pieces of information that we’ve fetched (generation, types, flavor text, art, etc.). Add the highlighted code to your data object definition: async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } In addition to the additions and changes highlighted above, be sure to add commas after the closing } symbols where needed. For example: \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, When defining JavaScript objects or writing JSON, sequential properties must be separated by commas as shown above. If you run into errors when trying to run your code, be sure to check for missing commas. I’ve missed plenty of them in my code before. In this step, we add the following information: Page Icon (Using the sprite) Page Cover (Using the official artwork) Properties: Category (rich text) Type (multi-select) Generation (select) Sprite (file) Child blocks (i.e. page content) Flavor text (quote block) A blank space (text block – for formatting/aesthetics) “View This Pokémon’s Entry on Bulbapedia:” (text block) Bulbapedia URL (bookmark block) We’ve already covered objects quite heavily in this guide, so I won’t spend too much time explaining each addition here. Instead, I’ll point you to the relevant pages in the Notion API reference that explain them. To learn how to set the page icon and page cover, refer to the example code shown on the Create a Page reference: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com Note that images cannot be uploaded to Notion via the API at this time, so you must link to an image hosted externally (as we’re doing here). For the properties, you can currently see how to format your objects when creating and updating pages here: Property values A property value defines the identifier, type, and value of a page property in a page object. It’s used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with … developers.notion.com In the near future, all of this information will be consolidated into the Page Property Values page, which is linked in the reference’s sidebar. To add child blocks/page content, refer to the example code in the Create a Page reference linked above. You can also use the Append Block Children reference to learn how to add new blocks to existing pages and blocks (remember, pages are blocks themselves!): Append block children Creates and appends new children blocks to the parent block_id specified. Returns a paginated list of newly created first level children block objects. Errors Returns a 404 HTTP response if the block specified by id doesn’t exist, or if the integration doesn’t have access to the block. Returns a 400… developers.notion.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. In the next step, we’re remove the // symbols and re-enable that function call. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Run Your Final Test It’s time to actually run your script! Before you do, go into your code and “un-comment” the createNotionPage() function call at the end of your getPokemon() function: console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() This will ensure the createNotionPage() function is actually called, and that your pages get created in your Notion database. Now it’s time for the moment of truth. Run node index.js in your terminal one more time; if all goes well, you should see these full-featured entries flooding into your Pokédex: Since we also set up the Generation information, you’ll also get them neatly grouped under the I group! If you click into each page, you should also see the flavor text and Bulbapedia link: If everything looks good, then you can modify your start and end variables in order to fetch more Pokémon. You already have #1-#10, so now you can set: start = 11 end = 905 Adding Pokémon #906-#1008 As of this writing, PokéAPI has not yet added flavor text, category, or generation information for Pokémon #906-#1,008 (those releases with Scarlet and Violet). Therefore, this script will work flawlessly for all Pokémon up to #905. If you’d like to add the newer Pokémon, you can see “default” values in the data object definition, as shown below. I found that I needed to do this for Category, Flavor Text, and Generation. \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category || \"No Category Information\" } } ] } There are more elegant ways to handle this, but I’ll leave them as an exercise for you to tackle if you’re so inclined! Once you’re modified those variables and ran the script again, you’ll be the proud owner of a full Pokédex in your Notion workspace. Conclusion If you’ve followed this tutorial, you hopefully now have a strong grasp on how to work with the Notion API using JavaScript. What you’ll quickly learn if you start working with other APIs is… you also know how to work with them as well! As I’ve learned, working with one API greatly prepares you for working with almost any other API. From here, you can use your newly-developed programming and API skills to do nearly anything you want. One resource I’ll recommend now is Pipedream, which is a platform that lets you connect APIs and write actual code (unlike no-code tools, such as Make.com). I love Pipedream because it handles all of the server setup and API authentication for you, letting you just worry about your code. They also have an incredibly generous free tier; I can’t imagine ever having to pay for Pipedream. As a result, you’ll see Pipedream-focused tutorials on this site in the future. This tutorial took months to produce; if you enjoyed it, you can support my work by grabbing one of my Notion templates (there are both free and paid options here): The Best Free Notion Templates for Tasks, Projects, Notes, and More If you want to improve your Notion workspace, these advanced, battle-tested templates will help you do it. Made by YouTuber Thomas Frank. thomasjfrank.com You can also join my Notion Tips newsletter below for free; once you’re on it, I’ll send you tons of Notion cheat sheets and goodies. You’ll also be the first to know when I publish new tutorials and templates.","metadata":{"source":"https://thomasjfrank.com/notion-api-crash-course","title":"The Complete Notion API Crash Course for Beginners","date":"2023-02-10T20:53:27+00:00","contentLength":24879}},{"pageContent":"In this Notion Fundamentals lesson, you’ll start learning how to create pages within Notion and customize them. Notion places everything on the page, which might be better described as a canvas. Pages can consist of a few paragraphs of text in a single column, or can contain complex, multi-column dashboards like the one in Ultimate Tasks for Notion. In the video lesson above, you can see how to create the following example page. It is deliberately simple right now; over the next few lessons, we’ll add more features to it before moving onto more advanced page designs. A simple page in Notion with a column of text. Read on to get an easily-referenced overview of Notion’s page features and options. All of this information is also covered in more detail within the video. You can also add all of the example pages and resources into your own Notion workspace from the Notion Fundamentals hub page. Notion Pages are Canvases Fundamentally, a page is a canvas that holds blocks, which are Notion’s basic unit. Pages can be nested within one another, and they can also exist inside of databases. When a page is in a database, it contains properties that it gets from that database. We’ll talk more about databases and properties later on in the course. Remember: Pages are simply a canvas! They can be many things: A simple page of text → Simple Page A single task → Task Due Today A complex, sprawling dashboard → Ultimate Tasks for Notion The flexibility of pages – and of the modular blocks that live on them – makes Notion fundamentally different than most productivity apps. In Notion, a page can be your navigation tool, writing area, task, etc. In most other apps, everything is given a defined roll. In Evernote, for example, a page is just a place to enter text and content. There’s a separate, defined navigation area. Content and navigation are completely separate in Evernote. Page Features You may notice that the content on this page looks a bit different! Notion lets you customize the look of a page in a few different ways: Fonts – normal, serif, and monospaced Small text – if toggled, text is smaller than normal Full width – not enabled on our example page. This feature is great for multi-column dashboards, or for databases with lots of properties. If a page isn’t in a database, you’ll be able to find it by navigating to it from the sidebar. If you want to quickly see the page’s location in your workspace, you can look at the breadcrumbs at the top of the page. You can search for any page as well, whether it’s in a database or not. If you want quick access to a page, hit the Favorite button and it’ll show up in the Favorites section. Pages always have a title. They can also have an icon and a cover. For each, you can choose from pre-defined options or upload your own! Lastly, pages can have comments and backlinks. On this page, you’ll see both near the top. The Comments section shows any comments that have been made for the entire page – though it won’t show comments placed on blocks or individual pieces of text. The Backlinks area shows pages that are currently linking to this page. We’ll talk more about how to create page links later on. In the page options, you can go to Customize Page and choose how you want to display comments and backlinks. Page History On plans that support it (all except the Free plan), your pages have version control. By going to the Page History area, you’ll be able to see the edits that have been made to a page, and choose to revert to a previous edit if you like. You can also simply copy the content in a previous version and paste it elsewhere if you don’t want to give up the current version. Page Nesting Useful to know: Pages can be nested infinitely, and higher-level pages have no special properties that don’t also apply to lower-level pages. The only minor exceptions to this: Top-level pages will show up in your sidebar. You can find lower-level pages by drilling down into these top-level pages in the sidebar view (unless you’re looking for a page in a database – then you’ll need to look in the database) Sharing settings cascade down to lower-level pages. So if you set up sharing for a page, all pages within that page will inherit the same settings. Now that you understand the basics of creating and editing pages, it’s time to move on to the next lesson: Mastering Notion’s Text Editing Tools. If you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/how-to-create-and-edit-notion-pages-notion-fundamentals","title":"How to Create and Edit Notion Pages – Notion Fundamentals","date":"2021-04-24T02:42:47+00:00","contentLength":843}},{"pageContent":"In this Notion Fundamentals lesson, you’ll learn all about Notion’s text editing tools. While it may not have the same level of text formatting capability as Microsoft Word, Notion does give you a lot of flexibility with your content. Notion has a multi-featured writing system that gives you many ways to do things. You can format your text using Markdown, keyboard shortcuts, or with a toolbar that comes up when you highlight text. You can also do a lot of formatting through Notion’s universal Slash (/) command. In the video lesson above, I’ll show you visual examples of all these tools. We’ll also use these tools to add new formatting to the example page from the previous lesson on creating pages in Notion. Our simple page from the previous lesson, now with additional formatting. Below, you’ll find a written version of the video lesson that includes some of the most useful Markdown commands and text editing shortcuts in Notion. You can also add the example page above – along with all the other examples and templates in this course – into your own Notion workspace from the Notion Fundamentals hub page. Text Formatting Options in Notion At a basic level, Notion allows you to format your text in the following ways: As I mentioned above, you have several options to achieving each of these types of formatting: Markdown formatting Keyboard shortcuts The editing toolbar The Slash command Let’s cover each of these. Notion’s Markdown System Like many modern note-taking apps, Notion allows you to use Markdown to format your text as you write. If you already know what Markdown is and how to use it, you can head down to the next section to get a Markdown reference for Notion. Markdown is a markup language created by John Gruber and Aaron Swartz in 2004. It allows you to apply formatting to text even when you’re using a basic plaintext editor, such as Notepad or Atom. This is done by wrapping your text in special formatting characters, such as * and _. A side benefit to this method of formatting is that you apply formatting as you write. Instead of needing to pause in order to hit a keyboard shortcut – or go back and highlight text – you can apply your formatting as you’re typing. When Markdown was first released, you’d write your text in any editor you wanted. To see your formatting, you’d then have to run your plaintext file through a formatting script, or open it in a Markdown preview application. Next came purpose-built Markdown editors. These often had a two-pane UI; in one, you’d write and apply markup in plaintext. The other would show you the formatted text, but wouldn’t let you edit it directly. Dillinger, a classic Markdown editor. Notion does things differently. In Notion, when you wrap text in Markdown characters, your formatting changes are applied immediately inside the editor. This is often called a WYSIWYG (What You See is What You Get) Markdown editor, and it’s my favorite type of text editor. Notion applies Markdown formatting immediately. You’ll also find this type of Markdown system in apps like Slite, Roam Research, Bear, and Whimsical Docs (which might have my favorite text editor of any app – ask me why on Twitter). Some Markdown purists don’t like WYSIWYG Markdown editors because they strip away the markup characters. While Notion does this, it also gives you to option to export a plaintext .md file, which will contain all the original markup. You can find this at the top-right 3-dot menu → Export. From there, choose Markdown & CSV as your export format. Notion Markdown Commands Reference The table below gives you a quick reference to all of the Markdown commands available to you within Notion. Note that not all Markdown features are supported within Notion. Some (such as footnotes) are simply not included, while others (like image embedding) are achieved using other tools like the slash command. For a full breakdown of Notion’s Markdown support, see Markdown Guide’s breakdown. Element Syntax Heading 1 # Heading 2 ## Heading 3 ### Italics *text* or _text_ Bold **text** or __text__ Strikethrough ~text~ Pre-formatted text `text` Unordered (Bullet) list *, -, or + – then space Ordered (Numbered) list 1., a., or i. – then space Horizontal Rule (Line) --- To-Do [] Blockquote \" Toggle block > Code block ``` Toggle heading 1 > + space, then # + space Toggle heading 2 > + space, then ## + space Toggle heading 3 > + space, then ### + space You can also view this table directly inside Notion. Text Editing Keyboard Shortcuts You can also use classic text formatting shortcuts in Notion. If you’ve used shortcuts in Evernote, Microsoft Word, or Google Docs, then you probably know most of these already. A few useful shortcuts to remember: ctrl/cmd + b = bold ctrl/cmd + i = italic ctrl/cmd + u = underline ctrl/cmd + e = inline code Notion has a lot of keyboard shortcuts, so it would be impractical to list them all here. Instead, I’d recommend bookmarking the shortcut guide in Notion’s official documentation. Editing Text with the Editing Toolbar Notion also has a floating tool bar full of options, which comes up anytime you highlight some text. Most formatting options are available from the editing toolbar. In addition to formatting options, the toolbar will also allow you to create links, add dates and reminders, and mention teammates. You can also use it to turn the entire block that contains the selected text into another type of block. Editing Text with the Slash Command Notion’s “Slash” command – so named because you merely need to type / to use it – brings up a powerful menu full of options. As you learn more about Notion, it will likely become the feature you use more often than any other. Using the Slash command to create lists. In general, the Slash command is used to create new blocks or to change the type of an existing block. It can’t really be used to format a precise selection of text. That’s what the other methods we’ve discussed are for. However, there are a couple of useful formatting tricks for which you can use the Slash command: Using the Slash command to change a block’s type and background color. Change a block’s type – click anywhere in a block and type /turn. You’ll see options for transforming the block into something else. You can keep typing to narrow this down – e.g. /turnbullet to highlight the Bullet List block type. Change a block’s text or background color – click anywhere and type /red (or any other supported color) to zoom to that color option. Start adding ” background” to the end to zoom to that background color – e.g. /red b. You can also type /back to zoom straight to all the background color options. I find myself using these two tricks all the time. They’re much faster than the alternative methods. Now that you have a firm grasp on text editing in Notion, it’s time to move onto learn about one of the most important features – blocks! If you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/a-guide-to-editing-and-formatting-text-in-notion-notion-fundamentals","title":"A Guide to Editing and Formatting Text in Notion – Notion Fundamentals","date":"2021-04-28T18:01:47+00:00","contentLength":1233}},{"pageContent":"In this Notion Fundamentals lesson, you’ll learn all about blocks, which are one of Notion’s most essential tools. What is a block? Put simply, a block is a basic unit of data. Notion’s official explanation (from their pricing FAQ): “A block is any single piece of content you add to your page, like a paragraph of text, a to-do item, an image, a code block, an embedded file, etc.” Think of blocks like LEGO pieces. By adding blocks together, you can build more complex – and more useful – things. Here’s an example page with some of the different block types labeled. When you build with LEGOs, you have access to lots of different types of pieces – short pieces, long pieces, thick pieces, and special pieces for that Star Wars X-Wing kit you lost the instructions for months ago. The same is true in Notion, which gives you access to many different block types. All of the following are blocks: A paragraph of text An image An embedded YouTube video A database A page …and yes, you read that last one correctly – pages are blocks, too. This concept is fundamental to fully understanding how to use Notion: Pages are canvases for blocks. Pages are also blocks themselves, which live on other pages. In this guide, you’ll learn how to create blocks, edit them, and easily turn them into other blocks. I’ve also created a comprehensive list of every block in Notion, which you can use to see most of the blocks available to you. In the video above, you’ll learn to use blocks hands-on by working through an example project – building a personal dashboard! We’ll work through this project slowly throughout the rest of the course, using it to explain every part of Notion – however, you can also skip ahead and checkout my full Notion dashboard tutorial. How to Create a Block in Notion You’ve got two main ways to create new blocks in Notion: Use the / Command Click the + button to the left of any existing block Here I’m creating a Quote block using the / command. Certain types of blocks – such as headings, bullet lists, and toggle blocks – can also be created using keyboard shortcuts and Markdown syntax. Check out my guide to editing text in Notion to learn more about using these methods. Using the two main methods listed above, you’ll be immediately presented with a pop-up menu of all the different types of blocks you can choose. You can scroll through this, but you can also start typing to narrow down your choices. Once you hit Enter or click your choice, that block will be inserted on the page. Edit Blocks with the Block Menu Hover over any block in Notion and you’ll see a gray six-dotted icon to the left of it, calle the block handle. Click it to access a menu of options you can use to edit your blocks, or click and hold it to drag the block around. (On mobile, tap any block, scroll the toolbar to the right, and find the “More” button to access these options.) Opening the block menu using the block handle. Within this menu, you’ll see the following options: Delete Duplicate Turn Into → lets you turn the block into another type of block. Turn Into Page → turns the block into a page. You can either create a new sub-page on the current page, or create a page elsewhere in your workspace. Blocks nested within it will become page content. Copy Link → copies the URL of the block. Navigating to that link will bring you to the containing page with the block highlighted. Move To → move the block to another page. Comment → leave a comment on the block. Color → highlights the block in a chosen color, or changes its text to a chosen color. On text-based blocks, nearly all of these commands can be accessed using the / Command as well. For example, you can type /comment to add a comment. Some editing features also have keyboard shortcuts, such as Ctrl/Cmd + Shift + M for adding a comment. Adding a comment to a block using the / command. Certain types of blocks also have additional options. On image blocks, you’ll see an option to view the image in full-screen. Code blocks will give you options for code wrapping and code language for syntax highlighting. There are other options as well, so go do some exploring! Synced Blocks in Notion In June 2021, Notion quietly released a special type of block called the Synced block. This block brings some significant changes to Notion, so it gets a whole section! Synced blocks can be copied and pasted elsewhere in your workspace, and all you to see and edit content from multiple locations. If you’ve ever used block embeds in Roam Research, you’ll be familiar with this concept. Any other block can go inside a Synced block (except other Synced blocks). You can also “turn” existing blocks into Synced blocks, which just wraps a new Synced block around them. Once created, you can copy and paste your Synced block to other locations in your workspace. You can even paste them into template blocks and database templates. You can use Synced blocks to create: Headers and footers across your workspace Databases that you want to see in multiple places (you can also use Linked Databases for this, but this method will let you see/edit the original database). Checklists and documentation that shows up inside project templates (remember to un-sync checklist copies if you want to change them on just one project) Learn more in my comprehensive guide to Synced blocks in Notion. Full List of Notion Blocks To see a list of most of the blocks available to you in Notion, check out my comprehensive block reference. You’ll also have the option to duplicate that page into your workspace if you like. Note that the page doesn’t include every block, since there are many, many types of embeds from different services. I don’t use all of them, so there are few that I haven’t included. As I mentioned above, you can simply type the / Command to see a list of every block available. Block Limits in Notion Prior to May 2020, Notion’s free personal plan limited your workspace to 1,000 blocks. Since then, however, Notion has removed the block limit and the Free plan now allows you to create an unlimited number of blocks. You can see the remaining limitations of the Free plan on Notion’s pricing page, but for the most part, the removal of the block limit means that the Free plan is more than enough for most people. The only place where the 1,000-block limit remains is on the free trial for the Team Plan. When using the trial, you can see how close you and your team have come to the limit in Settings & Members → Settings. Pro-tip: You can always delete existing blocks to make room for new ones. But – even more pro-tip: The Guest feature in Notion is very powerful. Guests in Notion can do most of what Team Members can, so if you’re simply working with frequent collaborators, you can save money by adding them as guests. The main limitations you’ll run into are that Guests can’t be added to Groups, and they’ll need to be added to each new top-level page. Team Members are automatically given access to all new top-level pages, unless you create them in your Private list. Now that you understand how to create blocks in Notion, let’s take you understanding to the next level and learn how to create multi-column page layouts! If you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-blocks-guide","title":"Notion Blocks: Everything You Need to Know","date":"2021-05-10T23:05:18+00:00","contentLength":1350}},{"pageContent":"One of my most-used areas in my Notion workspace is my personal dashboard. It’s a fairly simple page that does three important things. It: Works as a “home base” where I can jump to my tasks, notes, projects, wiki pages, etc. Gives me quick access to my daily tasks board, which I use to plan my day Makes my Notion sidebar way more useful. In this tutorial, you’ll learn how to create your own personal dashboard. I’ve also included a free template that you can add to your Notion workspace below. Watch the video tutorial above to see a step-by-step guide for building a personal dashboard. Alternatively, keep reading to see some examples and dashboard features you can use. Note: Building a personal dashboard is also the main example project in my free beginner’s series, Notion Fundamentals. If you want to learn all the basics of Notion, check it out. A Look at My Notion Dashboard A personal dashboard is a very, well, personal thing. The only design philosophy is that it should give you quick, convenient access to the parts of your workspace that you use most often. Here’s a look at my own dashboard: I use a very page link-heavy design with my dashboard. It exists as a jumping-off point – it’s like a train station that can take me to lots of different destinations. Note how the use of Link to Page blocks (rather than page Mentions) causes the links to show up in the sidebar, nested underneath my Dashboard alongside the pages that are actually contained inside it: This is a very powerful Notion feature. It allows you to simply Favorite your dashboard, then toggle it open to access other pages (rather than crowding your Favorites bar with tons of pages directly). Free Dashboard Template In the video above, we go step-by-step to create a slightly more advanced dashboard: In addition to page links, this dashboard also contains some linked databases, giving you on-page access to both a task inbox and note inbox. Many people like to be able to work directly from their dashboards; this example build allows that. I’ve turned this example into a free template you can duplicate into your own workspace. Keep in mind that the template really just gets you the page layout – since this is a personal dashboard, you’ll want to replace the example links with your own. If you’d like to also subscribe to my Notion Tips email list and be the first to know when I release new tutorials and templates, enter your email below. You’ll be redirected to the template right afterward, and I’ll also email you a link to all my free templates. Alternatively, use the second link to jump directly the template without subscribing! — Here are the other templates that I used to build the dashboard (these are all free): Ultimate Tasks and Projects Ultimate Note-Taking System Simple Habit Tracker Finally, if you’d like to add your own cool weather widget like the one I have in the template, check out Indify. They offer several other free Notion widgets as well. If you’d like some more personal dashboard inspiration, I’ll recommend the Notion subreddit – people are always sharing their own dashboards there!","metadata":{"source":"https://thomasjfrank.com/how-to-build-a-personal-dashboard-in-notion","title":"How to Build a Personal Dashboard in Notion","date":"2021-09-09T18:32:26+00:00","contentLength":559}},{"pageContent":"Pages in Notion can be simple, single-column affairs – but your pages can also have multiple columns as well. In fact, you’ve got quite a lot of control over how you lay out your pages in Notion! This allows you to create complex dashboards, wikis and knowledgebases, task management systems (like Ultimate Tasks), and lots of other cool things. In this Notion Fundamentals lesson, you’ll learn how to create these types of multi-column layouts. Note: As I mentioned in Page Basics, you can make Notion pages full width on a page-by-page basis. In most cases, you’ll want to do this when creating a multi-column page – however, it’s not required. Dragging and Moving Blocks Any block can be dragged and moved around on the page. To drag a block, click and drag the six-dot icon to the left of it. You can also select multiple blocks and drag them all at the same time in this way. As you drag a block, you’ll see a blue line indicating where it will go. Release the block to drop it wherever you want. Creating a New Column You can create new columns by dragging a block to the left or right of another block. You’ll see a vertical blue line indicating that a new column will be created once you do this. After you’ve create a new column, you can drag other blocks above or below the first block within that column to add them to it. You can also drag them to the side to create even more columns. You can create layouts with a lot of columns. In fact, I’m not even sure there’s a true limit to how many you can create: There’s one caveat to this feature: inline database blocks don’t play nice with it. You can’t drag them to the side of other blocks, nor can you drag other blocks to the side of them in order to create multiple columns. I’m not sure if this is a bug or intended behavior, but it’s been this way for a long, long time. But fear not! There are a couple tricks for getting inline databases to play nicely with multi-column layouts. First, you can click the three-dot menu on any inline database and then click Turn into page. This will convert your inline table into a Page block, which can be easily dragged around and used to create columns. Once you’ve created a column, click the three-dot menu once again and choose Turn into inline. Voilà! You now have a new column with your inline database. However, there’s another trick I use even more often. Simply create a column using another block (such as a Heading), and when drag your inline database under that block. This is typically faster, and I usually like to put header blocks at the top of my columns anyway. Organizing with Toggles One of my favorite blocks in Notion is the toggle block. Toggle blocks can be used to hide and show other blocks. They’re great for hiding detailed asides within long articles, giving the reader the option to skip over extraneous details if they’re in a hurry, or to open up the toggle if they want to soak up all the details. In addition to hiding long asides, toggles can hide pieces of multi-column layouts in order to keep them more organized and easier to navigate (especially when you’re using Notion’s mobile apps). When you’re creating a multi-column layout, try using some toggle blocks to keep things hidden and tidy! Nested Columns in Notion It’s also possible to nest multiple columns underneath an existing column. You can see an example of this in my free Habit Tracker template: If you try to create this type of layout by dragging and dropping blocks, you’ll find that it’s impossible. By default, you can’t create multi-column layouts within an already-split column. You can make a row of two columns, then a row of three under that – but you’ll find that those rows are very much separate. In order to create a layout like you see above, you’ll have to use an advanced trick. I know, I know – this is a Notion basics course – but I think we can make time for just one advanced trick! Here’s the secret: You can paste multiple columns into a Toggle block, then drag that Toggle block and drop it into an existing column. After doing so, you can then use the Turn Into function to turn the Toggle into a Heading. Once done, your columns will be nested under their parent column normally; you can simply delete the Heading afterwards. Note that this trick also works with Page blocks – you can create multi-columns layouts in a page, nest that page block under a column, and then turn it into a Heading just like you did with the Toggle block. Mobile Layout Considerations Multi-column layouts do not work on mobile phones. Instead, much like most responsive websites do, your columns will stack on top of each other in a left-to-right fashion. Keep this in mind when designing dashboards and other multi-column pages that will be accessed from a phone. How can you set things up so that you won’t have to do a ton of scrolling on your phone? Here are a couple tricks I employ. First, put things in toggles. This allows you to scroll to the section you need quickly, then open up the toggle to find specific content. Second, limit the number of rows that are loaded by default in any inline databases. I typically like to limit mine to 10 rows – I can always click to load more if I need. Finally (and this one is really cool), you use a Table of Contents block to create a list of links to your on-page Headings. Notice how I’ve created a “Quick Links” section at the top of my Dashboard Example. When you tap on these links, they’ll zoom you straight to that block on the page. This is a design pattern that I use in nearly all my templates, and you’ll likely find it to be very useful in your own workspace. Now that you understand how to create multi-column layouts, let’s move onto the next fundamental concepts – creating page links and sub-pages! If you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/how-to-create-multi-column-layouts-in-notion","title":"How to Create Multi-Column Layouts in Notion","date":"2021-09-27T22:19:07+00:00","contentLength":1138}},{"pageContent":"A huge part of Notion’s power as a knowledge management tool stems from the way it lets you easily create new pages anywhere in your workspace, and then link those pages together in multiple ways. In this Notion Fundamentals lesson, you’ll learn all of the different ways to create links in your workspace, as well as how to create sub-pages in multiple ways. Sub-pages are Notion pages contained within other pages. Unlike other apps such as Evernote, Notion allows you to create a practically infinite number of nested sub-pages: An example of nested sub-pages in Notion. If you’ve been following along with our Personal Dashboard example project in this course, you probably noticed several page links in the Tasks area of the example dashboard. These each link to another existing page (specifically, they link to pages in my Ultimate Tasks template). By the end of this lesson, you’ll understand exactly how those were created, and you’ll be able to create similar links all throughout your workspace. You’ll also learn all of the ways you can create new pages in your workspace. Creating Page Links Notion gives you several ways to easily link to pages from anywhere in your workspace. Instead of forcing you to use its organizational structure (or rely on search), Notion also lets you build your own web of links and shortcuts for getting around however you like. Here we’ll cover each of the ways you can link to existing pages. The Link to Page Block Just as the Page block (which we covered in Block Basics) lets you create a brand new sub-page, the Link to Page block creates a link to an existing page. This link is a full block, meaning it takes up a full line on your page (or within a column if you’ve created a multi-column layout), as opposed to inline links which can exist within other blocks. To create this type of block, you can either: Use the / command and choose Link to Page, then either search for the page you want or paste the URL if it’s on you clipboard Paste the URL of a Notion page directly onto the page you’re on. This will bring up a few different options – to create a link block, choose Link to Page. Notice that when you use the Link to Page block, your link shows up in the Sidebar nested underneath the current page. This is just like sub-pages that actually exist within the current page! This means that you can use the Link to Page block to create shortcuts to other parts of your workspace that are easily accessible via the sidebar. I make heavy use of this within my Favorites area. My “Thomas’ Dashboard” page contains links to other important areas of my workspace, which allows me to toggle that page open in order to quickly access them instead of adding them all directly to Favorites. Inline Links In some cases, you’re going to want to link to pages within a block of text. You also won’t always want your links to show up in the Sidebar. In these cases, you’ll want to use inline links, which are also known as mentions of pages. To create an inline link, you can paste the URL of a Notion page just as you’d do for creating a link block. When the menu of options comes up, choose Mention page. You can also create inline links via a few different keyboard commands: [[ – the easiest way to create an inline link. The double-bracket is specifically used to create inline links + – this is typically used to create new sub-pages, but you can also type the name of an existing page and create an inline link to it. @ – this is mainly used to mention people or create date reminders, but it – like the + symbol – can be used to create inline links as well. Fun technical details about inline links If you create an inline link on a new line in Notion (or create a sub-page on a new line using the + syntax), you’re actually creating a new Text block! You can prove this to yourself by trying to input text on either side of the inline link; it’ll work perfectly. You can also turn this Text block into a Page, which will get you a weird result – your Page Title will contain a link. One thing that trips people up here: If you create a sub-page inline using + syntax, you won’t be able to use the Turn Into command to turn the page into something else, such as a Toggle block. This is the block menu is actually operating on the Text block “wrapper” that contains the page link. There’s no way to access the block menu for the page itself. You can fix this by moving the cursor just to the left of the inline sub-page link, then hitting enter. This will force the inline page link onto its own line, turning it into a true Page block. Hyperlinks There’s one final way to create links in Notion – the tried and true hyperlink. These work just like you’d expect if you’ve ever created a link in a blogging platform like WordPress. You can link to Notion pages or external pages this way. To create a hyperlink, highlight a piece of text and bring up the editing menu. There you’ll find a Link option, which will allow you to type or paste a link. Backlinks Whenever you link to a page in Notion, you’re actually creating a bi-directional link. This is because Notion has a backlink feature, similar to the one in Roam Research (though not quite as powerful). When you link to a page, you’ll see a backlinks area underneath the title and properties of that page: You can use this feature to navigate back to a page after you leave it via a link, or to see which pages in your workspace are linking to a certain page. Creating Sub-Pages When you create a new page in Notion, it is known as a sub-page unless you’re creating a top-level page from the Sidebar. There are four main ways to create new sub-pages, not counting methods for creating pages within databases. These include: Creating from the Sidebar Using the New Page button Using the Page block Creating sub-pages using the + syntax Let’s quickly cover each one, shall we? Creating Pages from the Sidebar Notion’s sidebar lets you navigate your workspace, but you can also use it to create new pages and sub-pages. When you hover over Workspace or Private, you’ll see a small + icon. You can click this to create a new top-level page, either within your Workspace (accessible by everyone in your Workspace by default) or within your Private collection. You can also hover over any page within these areas to see another + icon. Click this to create a sub-page within that page. If you then visit that page, you’ll see the new page you’ve create at the bottom of it. Using the New Page button At the bottom of Notion’s Sidebar, you’ll find a New Page button. This button creates a brand new page that doesn’t yet have a home in your workspace. There are two other tricks for creating a page in this way: Tapping the big + button on the Notion iOS widget Visiting notion.new in the browser At the top of the page, you’ll see a destination menu with a pre-set destination, which you can change. If you’ve picked a destination before on the current device or browser you’re using, that destination will be remembered and will be set as the default (this is done on a per-device basis). Using the Page Block You can create a new sub-page where you are in your Workspace by using the Page block (we also talked about this in Block Basics). This instantly creates a new page, linked from where you created the block. Easy. Once done, you’ll see the page listed in the Sidebar underneath the page where you created it. Creating Sub-Pages with the + Syntax In addition to using the Page block, it’s also possible to create new sub-pages using the + syntax. This actually allows for more flexibility than the Page block does. As with inline links, sub-pages created with the + syntax can be placed in the middle of a line of text – or even in a page title! To use this page creation method, simply type a + followed by some text – whatever you’d like the page to be named. You can use @ and [[ as well, but + defaults to page-creation, while the others put the page creation options at the bottom of the menu. You’ll see two main options: New “____” sub-page New “____” page in… The “New ____ sub-page” option will create a new sub-page named with the text you entered. This is nearly identical to how the Page block works – but with one key difference. Using the + syntax, you can create new sub-pages inline. This means you can house sub-pages within your current page, but have them live on a line of text that’s already inside another block. By contrast, the Page block always creates a sub-page on its own line. The “New ____ page in…” option is more interesting. Click it will take you to a new menu, and will allow you to place the new sub-page anywhere within your workspace. You can even place the new sub-page within a database, and you can go even further by creating it using an existing template (Learn all about creating database templates here). When you use this option, you’ll see a link to the new sub-page that you created. I’ll note that using this option will also allow you to link to existing pages. The text you enter is used as a search query to look for existing pages you can link to. If you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-links","title":"Notion Links: How to Create Page Links, Backlinks, and Sub-Pages","date":"2021-11-22T22:02:50+00:00","contentLength":1761}},{"pageContent":"The most powerful and flexible tool in Notion is its database feature. Within your Notion workspace, you can create databases that can store almost any kind of data, including text, numbers, file attachments, and more. Databases can be used to create: Task managers (such as Ultimate Tasks) Calendars Note-taking systems CRMs Custom dashboards for sales and performance data …and much more. Once you understand how to work with databases, you’ll unlock a whole new level of capability inside of Notion. In this Notion Fundamentals lesson, I’ll guide you through all the basics of creating and using databases. Note: This guide is massive, and is intended to be a truly complete tutorial for Notion databases. I encourage you to use the table of contents to jump around! In the video version of this lesson, we’ll be using everything we learn to create a useful example database – a simple task manager, which you could include in the personal dashboard that we’ve been building throughout the other lessons in this series. One thing I’ll note before we get started is that I’ve created a completely free task management template called Ultimate Tasks, which has a lot more capabilities than the example we’ll be building here – such as sub-tasks, recurring tasks, progress bars for projects, and more. If you’re looking for a capable task manager for Notion, check it out! The Ultimate Task and Project Management Template for Notion Use this template to move ALL of your task and project management into Notion. Get it Free How to Create a Notion Database The best way to learn is by doing – by trying things out, experimenting, and getting your hands dirty. So let’s start this guide out by covering how to actually create a Notion database. Doing so is simple; just type /database on any Notion page, and you’ll see a list of database options. You can start out by choosing Database – Inline, which will create a brand-new database right on that page. Here’s a very simple example database that lists some of my favorite movies: By default, your new database will be displayed as a table. Notion offers other database layouts, but a table is a great starting point. There are a couple of alternative ways to create a database as well. First, you can create a blank page (see my lesson on creating pages), and then select one of the database options: You can also use the / command to create a database with the specific layout you want. The options include: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view If you create a database block using a layout command, Notion will give you the option to either create a Linked Database (which links to an existing source database), or to create a new database. There are later sections in this guide for both (click to jump to them): Database Layouts Linked Databases For now, it’s just useful to know the ways you can create new databases. Notion Databases at a Glance Databases store rows (sometimes known as records). And in Notion, those rows are actually Notion pages themselves. The Table layout in Notion displays a database’s rows as they’re actually stored in the database (since Notion uses a table-style database structure with rows and columns). In this example, each movie is a row in the database. However, I can open up any one of them and get a Notion page that works just like any other: These pages can hold any type of content you want – text, images, and even other Notion databases. Databases also have properties. You can see these at the top of the Hot Fuzz page above, or as columns in the Table view. Properties hold structured information within a database, and typically they’re set on a per-row basis. Here in the movies database, I have two: Genre – a Multi-Select property, which allows one or more tags to be applied to each record Seen Recently – a simple Checkbox property Properties have several uses, but their greatest use is in filtering and sorting your data. Here’s another view of our Movies table, filtered to show only the movies that we haven’t seen recently: Note how this is a different view of the same database. Our original Table tab doesn’t contain the same filter. By looking at the same database through different views with unique filters, we can look at the same database in many different ways. This is immensely powerful. Consider a Notes database containing all the notes in your life. That might be thousands of notes! Without any filters, this data would be hard to sift through. But by applying properties, sorts, and filters, you could create all sorts of useful views: All notes created in the last month Notes tagged with “Fitness” All notes, sorted by Date Last Updated Notes related to the Vacation project in your Project Database Notes with a Review Date that falls within the next week Without a database, these types of filters and sorts aren’t possible in Notion – which means you may eventually end up with long lists of pages that can only be sorted by dragging-and-dropping. Hopefully, this introduction has shown you just how powerful databases can be. From here, the rest of this guide is a choose-your-own-adventure: You can scroll up to the video tutorial above, where we’ll create a simple task manager using some slightly more advanced database techniques. Or, you can keep reading this written guide, which will detail all the important Notion database features – filters, sorts, grouping, properties, relations, linked databases, and more. What Is a Database? Now that you’ve had a proper introduction to how Notion databases work, I’d like to touch a bit on what databases actually are before we get into the details of their individual features within Notion. In general, a database is defined as an: “…organized collection of data stored and accessed electronically.” Nearly every program and web app you use relies heavily on databases. If you’ve ever used a digital calendar app like Google Calendar, then you’ve benefited from a database. Behind the scenes, every event on your Google Calendar is a row in a database. These rows have properties, just like the ones you saw in this guide’s introduction. Some of these include: Event date Location Calendar (Work, Personal, etc.) Google Calendar uses the values stored for these properties in each row to intelligently display your calendar, showing you each event on its correct day slot, displaying the event’s location, and color-coding each event based on its Calendar. Notion works in much the same way, but it gives you a lot more control over your databases. You can create your own properties, customize them, and set up database views that display your data based on filters, sorts, and more. Here’s an example: What if I just wanted to see events on my Work calendar in the month of August? In Google Calendar, I’d toggle all my other calendars to their “off” state, and navigate to the correct month: In Notion, I could achieve the same result by first ensuring that I have properties in my Events database for Date and Calendar. Then, I could simply create a view with two filters: Where Calendar contains Work Where Date is within August 1 ➡ August 31 Of course, Notion also includes a Calendar layout, so the date filter might not be necessary. I just wanted to show you how you’d directly interact with your database properties to create unique, filtered views. Databases vs. Spreadsheets You might have looked at all our example table views in the screenshots and thought, “Hey, those look like spreadsheets!” Indeed, they do look like spreadsheets – but they’re not. There’s a fundamental difference between spreadsheets and databases. On a spreadsheet, data is contained within cells that have specific X:Y coordinates on a grid, such as B2 or D5. This means that formulas can reference specific cells, like B2+D5 – this simple formula will add the values of B2 and D5. Conversely, databases don’t really have “cells” with X:Y coordinates. Rather, each record has the same number of properties, each of which can be set to a unique value per record. Technically, since most databases are relational and store data in a table with rows and columns, you could feasibly target coordinates on the table. But since databases are built to be flexible, the vast majority of database tools don’t provide spreadsheet-like cell coordinates for row:property pairs. We can display a database in a grid-like table, but it’s not actually a grid of cells that we can target. This means we can easily visualize the information in our database in other ways besides a classic table – such as a Kanban-style board, where the columns are based on the Assignee property: Spreadsheets and databases do have quite a bit of overlap, though. In a spreadsheet, we can simulate properties by creating a two-dimensional table. And apps like Excel even allow us to sort of treat a spreadsheet like a database through pivot tables and other functions. Likewise, an app such as Notion can let us view a database’s table structure, which looks like a spreadsheet. The most important thing to know as a Notion user, however, is that we can’t target individual row:property combinations as if they were cells on a grid. Here on my task table, I couldn’t write a formula that specifically targets the “cell” with “April 6” in it. In Excel, you might think of that location as B3, but there’s no B3 in Notion. Instead, there’s a row – the “Test Web Parachute” row – and its Due Date property is set to April 6. It’s also worth noting that “Test Web Parachute” is itself a specific value in the Name property. In Notion, new databases get a default property called Name, which can’t be hidden or deleted. But it is still a property – just a special property. Its type is “Title”, and you can actually open it up to see a brand-new Notion sub-page within your database. If you want to get even nerdier about spreadsheets and databases, check out this article comparing them. With this high degree of control and flexibility, you can use databases to create all sorts of different tools and applications inside of Notion. After all, many software tools are just collections of filtered database views! Consider: Your phone’s contacts app Task managers like Todoist Websites like IMDB Each of these simply gives you tools to work with one or more databases. As a result, you can create replacements for all of these tools inside of Notion. You can also create hyper-personalized tools that fit the exact information and processes you use for your work. That’s Notion’s superpower. It allows you to build tools that don’t yet exist, tailored to your exact needs. Notion Database Examples Book Tracker Contact Manager Simple Task Manager As we dig into all the particulars of Notion’s database tools, you might want some example databases to play around with. Here are a few, which will also serve to show you some of the tools you can build within Notion. Simple Task Manager Contact Manager Book Tracker Each of these databases is available as a free template, which means you can duplicate them into your Notion workspace and make changes to the duplicated copy. Learning happens fastest when you take action, so experiment and make some changes! Add some stuff! Let your cat walk on your keyboard for a minute and then try to fix everything that broke! There are 3 ways to make progress in anything:1. Buy new gear.2. Learn academically through books, courses, etc.3. Spend time in deliberate practice.In order of importance:Practice > Learning >>>>> Gear— Thomas Frank (@TomFrankly) May 29, 2022 I’ll also note that these are very simple example templates. They purposely lack a lot of features so that they’re easy to understand and edit. I’ve also designed several more robust templates with advanced features. These templates are completely ready to rock, and will instantly upgrade your Notion workspace with useful tools. Check them out on my Notion Templates page. We’re now ready to start digging into all of the features that Notion databases offer. From here, you may want to use the Table of Contents to the left (or at the top of this article if you’re on mobile) in order to find the topic you most want to learn about. Database Views A database view is a specific combination of layout, filters, sorts, etc. Note that a database block can contain multiple views. When it does, you’ll see them all listed across the top as tabs: Each of these views pulls from the same database, but each shows a unique set of data based on a combo of sorting, filtering, and layout. You can also add a new view to a database block using the Add view button: For each view, you can access a View Options menu, where you’ll be able to change nearly any setting related to that database view: Here, you’ll have access to nearly every setting inside your database, including: Database name Layout – Table, Board, Calendar, etc. Property settings – show/hide properties on the current view Filter options Sort options Group options Load Limit – sets the max number of rows that will be loaded automatically (you can load additional rows using the Load More button at the bottom of any view) Lock Database/Lock Views – On a source database, this will lock the entire database. On a Linked Database, you’ll see Lock Views, which merely locks the Linked Database’s views from being changed. (Learn more about locking databases) Copy Link to View – copies the link to the current database view to your clipboard Duplicate View – duplicates the specific view you’re currently on Delete View – deletes the specific view you’re currently on Layout Types Notion databases can be viewed in several ways. You’ve already seen the Table layout in our examples above, but that’s just one of six available layouts: Table – a traditional, spreadsheet-like view Board – a Trello-style “Kanban” view Timeline – a Gantt chart view Calendar – a no-frills Calendar view List – a responsive, mobile-friendly Table alternative Gallery – an aesthetic view that’s great for showcasing images Each one of these layout types gives you a different way of displaying the same information from your database. They each have their own advantages, disadvantages, and features, so try them all out! Add New Pages to a Database You have a few different options for adding new pages to your database. First, you can hit the +New button within your database view. In a Table view, you’ll find it at the bottom of the table: It’s worth noting that this is the only way to add a row that will conform to the view’s filters automatically. Example: If the view above had a filter that said “Genre is Action”, then your new row would automatically be tagged with Action. This is called a forcing function. Click here to jump to the section of the guide on forcing functions. You can also hit the blue New button in the top-right corner of any database view. This will open up a modal window with a blank record in the database. Additionally, you can create new rows in a specific database from anywhere in your Notion workspace by using the + link syntax, then choosing the “New page in…” command. For example, I could add a new row to my Movies database from anywhere by typing +Ghost in the Shell, choosing New page in…, and then selecting the Movies database as the destination. Learn more about this in my guide on linking Notion pages together. Finally, you can add new rows to a Notion database through external tools. For example, the official Notion web clipper and the Save to Notion extension can both clip web pages into your Notion workspace. If you want to get more advanced, you can even use the Notion API to add new database rows using thousands of other tools. Database Properties Properties are the columns in a database’s table structure, and they’re useful for holding structured information about each row. They let you add dates, checkboxes, tags, numbers, and a lot more to your databases. In a Table view, you’ll see your database’s properties as columns: In other layouts, you’ll see property values listed on the cards for each row: You can show/hide individual properties on any given view by going to View Options → Properties: By opening up a row as a page, you’ll be able to see all of the properties in that row’s database. You can also easily add new properties here. Notion comes with many different types of properties. Some are writable, meaning you can edit the information they hold on each row. Others are read-only, meaning they hold information that can’t be edited. Here’s a table showing all of Notion’s property types: Property Description R/W Text Holds text, which can be formatted. Writable Number Holds numbers. Can be formatted as a progress bar. Writable Select Holds singular “tags”. Writable Multi-Select Can hold multiple “tags”. Writable Status Indicates project/task status. Always has a default value. Can show as text or a checkbox. Writable Date Holds dates, which can be displayed absolutely (e.g. “03/25/22”) or relatively (e.g. “Tomorrow”). Writable Person Holds members or guests of the workspace. Writable Files & Media Holds file attachments, including images, audio files, video, etc. Writable Checkbox Holds a simple checkbox. Writable URL Holds a URL, which is clickable. Writable Email Holds an email address. Writable Phone Holds a phone number, which can be called on supported devices. Writable Formula Holds formulas that can process and output data in many ways. Read-Only Relation Relates the row to other rows in the same database or another database. Writable Rollup Pulls in property information from Related rows. Read-Only Created time Holds the date and time of the row’s creation. Read-Only Created by Holds the workspace user who created the row. Read-Only Last edited time Holds the date and time of the row’s last edit. Read-Only Last edited by Holds the workspace user who last edited the row. Read-Only One last useful thing to know about properties is that they can be deleted and restored. If you accidentally delete a property, just head to View Options → Properties → Deleted Properties to find it and restore it (or permanently delete it if you want): Sorting You can sort a database view by any property, in either ascending or descending order. To create a sort: Hit the Sort button at the top of your database block. Select the property by which you’d like to sort your view. Choose ascending or descending order. Add additional sort criteria if you want. By adding additional properties, you can create even more granular sorts in your database views. In these cases, the database will be sorted by each property in top-to-bottom order. Drag properties around to change the sort order. Here, you can see that I have this shot list database sorted first by Type, then by B-Roll Description. P.S. – This shot list database is part of Creator’s Companion, my all-in-one Notion template for content creators. Check it out if you make videos, blog posts, or social media content. If you create a sort within a database that is shared with others (Team Members or Guests), your sort will initially only be visible to you on your current device. You’ll notice a Save for Everyone button after creating the sort; click it if you want to apply the sort to the database for everyone. You can also click Reset to remove any changes you’ve made, or simply leave things as-is if you want to keep the sort for your eyes only. If you’re working on a database that’s private, you won’t see these options; they only come up on shared databases. Filters Databases often contain huge amounts of data, but you rarely need to see all of it at once. Typically, you just need to see the rows that are relevant to a specific context, like: Tasks that are due today Subscribers who are less than 30 days away from their renewal date Movies in the Action genre This is where filters come in. Filters allow you to limit the rows a view displays, and they’re among the most useful tools you’ll find in Notion. Just like a sort, you can create a filter by hitting the Filter button at the top of your database block: There are two types of filters in Notion: Simple Filter – a singular filter that targets one property Advanced Filter – a set of filters or filter groups Simple Filters Simple filters are quick to create and target a single property. To create one, hit the Filter button and then select the property you’d like to filter by. Filters follow this convention: Property Name → [Criteria] → Value Here, you can see that I’m filtering my view by the Genre property, which has the Multi-Select property type: Your criteria options will change depending on the property’s type. Here, I have four options: Contains Does Not Contain Is Empty Is Not Empty Finally, I can choose one or more values. My completed filter reads: Genre Contains Action, which means my view will only show rows that have Action in their Genre property. Since Genre is a Multi-Select property, rows can also contain other genres. You can add multiple simple filters to a database view, and you’ll see them displayed in a row across the top of your database view when the Filter bar is open. Advanced Filters An Advanced filter is a set of one or more filters that show up in a single dialogue box. Using an advanced filter, you can do something that’s incredibly useful; you can mix AND/OR operators when working with multiple filters. When you create multiple simple filters, you’re always using the AND operator between them. For example: “Genre contains Action” AND “Seen Recently is Checked”. By creating an advanced filter, you could instead set up this filter combo: “Genre contains Action” OR “Seen Recently is Checked”. Note how this drastically changes the rows that show up in this view! Now, a row only has to fit one of the filter criteria. Advanced filters also let you create filter groups. Within an advanced filter, click the Add Filter Rule dropdown and then select Add Filter Group to create one: Filter groups let you mix your AND/OR operators. Normally, once you’ve chosen either AND or OR, you’re locked into that choice when you add more rules to the filter. However, a filter group gives you a nested box where you can select a new operator. How is this useful? Here’s an example problem: Say I’m a movie buff. I want to watch a movie every night, and I have these preferences: I’m an action movie nut, so I might want to watch an action movie even if I have seen it recently. For other genres, I only want to watch a movie if I haven’t seen it recently. Using a filter group, I can create a view that fits both of these preferences. In my Movies database, I’ve created the following set of filters: If a row contains the Action genre, it’ll always show up. If it doesn’t contain the Action genre, it’ll only show up if Seen Recently isn’t checked. Here’s another example from my Ultimate Brain template: Ultimate Brain has a robust note-organization structure (modeled on Tiago Forte’s P.A.R.A. method) with: Higher-level Areas Lower-level Resources Areas can contain Resources, and Notes can exist in Areas or Resources. This means that within an Area, we’d want to show Notes that exist directly in that Area, or that exist within any Resources underneath that Area. We also want to make sure those Notes aren’t archived. Using a filter group, I’ve created a combo of AND and OR operators to meet these criteria. This example is more complex than the previous one, but I hope that it illustrates how filters can allow you to create truly useful tools directly within Notion! P.S. – If you’d like to use Notion as a true Second Brain, check out my Ultimate Brain template. It seamlessly combines tasks, notes, projects, goals, and whole-life organization, and it’s what I use as my own productivity system. Saving Filters As with sorts, filters created in shared databases will initially only affect your account and device. When you create a new filter or change/delete current filters, you’ll see a Save for Everyone button pop up: You can click that to apply the filter for everyone who has access to the database, hit Reset to erase your changes, or just leave things as they are if you want the filter to only affect you. Forcing Functions When you set up a filter in a database view, new rows created in that view must conform to that filter. As a result, creating a new row in a view with filters will automatically set default property values. Here’s an example: In this view of the Movies database, I’ve created the following filter: Seen Recently is Checked. Note how the new row I’ve added automatically has its Seen Recently checkbox property checked. When filters are used in this way, I call them forcing functions. You can use these in all sorts of ways – here are just a few ideas: Add tasks to a task view with a due date set to Today Add notes to a filtered notebook view with a specific tag, such as Lecture or Book Add tasks to a shared task database with a specific Assignee (person property) I’ve made an entire video explaining how these work (and how to use them to your advantage) in a lot more detail: Grouping Notion lets you group rows in a database view based on common values in nearly any property type. Here, I’ve grouped my Movies database view by the Genre property. Now my movie rows are grouped by genre: You can add Grouping to any view layout (except for Calendar) by going to View Options → Grouping. From there, you’ll be able to select the property you’d like to use for grouping: You’ll also find a few other options, such as Hide Empty Groups. Sub-Grouping Notion’s Board layout has a unique feature: In addition to Grouping, it can have Sub-Grouping as well. Normally, a Board view will display its groups as columns. This is the classic “Kanban” style of grouping that has its origins in Japanese manufacturing, and which was popularized in the U.S. by apps like Trello. By adding sub-grouping, you can group a board view into distinct rows. In this case, the rows aren’t actual database rows (as in a Table view); they’re sub-groups based on another property. In the screenshot above, I’ve grouped the Board view by Genre, and then sub-grouped it by a new Select property called Rating. Movies are grouped by their ratings – PG, PG-13, R, etc. You can add sub-grouping to a Board view in nearly the same way you’d add grouping – simply navigate to View Options → Sub-Group. Relations The Relation property type allows you to relate database rows to each other. These relations can be created: Between rows in the same database Between rows in separate databases This concept can take a bit of time to fully grok, so let me start out with an example. Example 1: Parent and Child Tasks Task managers often have a sub-tasks feature, which lets you nest sub-tasks underneath a top-level “parent” task. Here’s a task with a couple of sub-tasks in Todoist: When you open the Parent Task 1’s window as in the image above, how does Todoist know to show you two sub-tasks – and not show you any other tasks? Behind the scenes, there’s a Relation set up in Todoist’s database. This Relation consists of two properties, which you could think of as columns in a table: Parent Task Sub-Tasks The Parent Task 1 database row has its Sub-Tasks Relation property filled with links to two other database rows: Child Task 1 Child Task 2 Likewise, each Child Task has its Parent Task Relation property filled with a link to the Parent Task 1 row. In this way, Parent Task 1 is related to the two Child Tasks. With this Relation set up, Todoist can simply use a filter (also behind the scenes) to display the correct Child Tasks. Essentially, that filter would read: Where Parent Task contains “Parent Task 1” This filter ensures that only the two Child Tasks show up. If that makes sense so far, let’s create it in Notion! How to Create a Single-Database Relation A Relation is a type of property, so you can add one to your database by: Adding a new property Selecting the Relation type Selecting the Database you’d like your Relation property to point towards Choosing whether the Relation should have separate properties Since I’m creating a Parent Task ⬌ Sub-Tasks relation, I want to make sure I choose the same database that I’m currently working with – in this case, My Tasks. Next, I’ll choose whether or not I want to create Separate Properties. If I don’t, I’ll just get a single Relation property called Sub-Tasks. If I do turn it on, I’ll get a second property. Since I do want a second property called Parent Task, I’ll turn on the Separate Properties option and give my second property the correct name: Now that I have my Relation properties, I can model Parent Tasks and Sub-Tasks just like we did earlier with Todoist. Here, I’ve clicked into the Sub-Tasks property within the “Take Grocery Boxes…” row, and set two other rows as sub-tasks: Build grocery boxes Get rain covers Note how “Take Grocery Boxes…” automatically shows up in the Parent Task property for each of these sub-tasks. Now that we have these Relations set up, we can do some useful stuff! Here’s a basic example. I’ve set up a simple filter that says: Where Parent Task contains “Take Grocery Boxes…” With this filter in place, I can only see the two sub-tasks I created earlier. In the Linked Databases section of this guide, I’ll show you how to set up this same filtered view inside the Parent Task’s page. This is far more useful, and it models the Todoist example above perfectly. For now, let’s take Relations one step further by relating two separate databases together. Example 2: Tasks and Projects Task managers also tend to have Projects or Lists that are useful for grouping multiple tasks together. You can see this in Todoist: If we think about the databases that run everything behind the scenes, we realize that there are actually two main databases: Tasks Lists These databases are related to one another. This means that a single row in the Lists database can be related to many rows in the Tasks database. Then, using filters, Todoist can show you a tidy view of the tasks in a specific list, such as House. Guess what? You can do the exact same thing in Notion by creating a multi-database Relation! How to Create a Multi-Database Relation To create a multi-database Relation, we’ll first need two databases to work with. Fortunately, the Simple Task Manager example template already has two: My Tasks My Projects I can create my Relation in either database, but I’m going to create it in My Tasks. Adding a new Property, I’ll: Name it Project Select the Relation property type Select the My Projects database for the database connection Toggle Show on My Projects to the On position Name my Related Property with the My Projects database as “Tasks” Note how the Relation builder also gives you a preview of what your Relation looks like. Here, you can see that two properties are being created: “Project” within the My Tasks database – which points to the My Projects database “Tasks” within the My Projects database – which points to the My Tasks database These two properties are reciprocal, meaning that setting a related row in one will affect the other. In My Projects, the Suit Redesign project contains two related rows from My Tasks: Going over to My Tasks, we can see that both of these rows – Design new web shooters and Test web parachute – contain Suit Redesign in their Project property. With this Relation set up, I can do some very useful things. For example, I can group this view by my Project property. I can also set up a database view within a Project’s page that shows only its related tasks. To do that, I’ll need to use a Linked Database. Linked Databases Linked Databases allow you to create a database block that pulls data from an existing source database, which can live elsewhere in your Notion workspace. For example, the main All Tasks database inside my Ultimate Brain template lives inside the Archive: On Ultimate Brain’s Quick Capture page, there’s a Linked Database block that uses All Tasks as its source: This means that any rows I add to this linked database view will end up in the All Tasks database. Essentially, you can think of Linked Databases as collections of Views for a database that can live elsewhere in your Notion workspace. Linked Databases are immensely useful. They allow you to create pages and dashboards in Notion that are driven by source databases, but that serve specific contexts. The Quick Capture page shown above is just one example of a context-specific page. Here’s another one – this page only shows tasks that are due on or before tomorrow: Note that this Linked Database view has the source database hidden; this is an option you can turn off or on. How to Create a Linked Database You can create a Linked Database in Notion either by typing /Linked view of a database or by typing any of the following options: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view I’ll go with /Linked view... inside the Suit Redesign project in the My Projects database. That way, I’ll be able to get a view of all the tasks related to this project. The first thing I have to do is select a data source. This is the source database that I want to pull from. In this case, I want to select My Tasks: Next, I’ll be given the option to either copy an existing view from the source database or to create a new empty view. I’ll do the latter so I can completely customize it: From here, I can customize my view just like I would with a normal view inside the source database. All of the options are exactly the same. The only difference is that the Linked Database view comes with the option to show or hide the source database title. Here, I’ve hidden it in order to make my database view look cleaner: The last thing I’ll do here is add a filter to my linked view: Project contains Suit Redesign This will ensure that only tasks related to my Suit Redesign project show up. It also creates a forcing function, ensuring that new rows I add to this view will automatically be related to the Suit Redesign project! With this simple filter in place, my Project page works just like a List in Todoist (or any other task management app). Database Templates Pages inside a Notion database act just like normal Notion pages – they give you a blank canvas on which you can add any combination of blocks. But you won’t always want to start from scratch; sometimes, you’ll want to have a common starting point for certain pages in a database. That’s where database templates come in. By creating templates in your database, you can automatically generate any page content you want with just one click. Templates can be as simple or as complex as you want them to be. Here’s a very simple template within my Movies database: …and here’s the comprehensive Content Project Template that I use for all of my YouTube videos. In one click, it generates a task list, shot list, script page, research area, multiple checklists, and more: Note how it also sets default values on some of my database’s properties – including the Status, Channel, and #No properties. If you’re a content creator, you can get access to this template – along with a whole suite of dashboards and tools to aid your creation process – in my Creator’s Companion template. It’s the exact system I use to run my YouTube channels and blogs (including this one). When you have a template created within a database, you’ll see an option to use it whenever you create a new page in that database and open and open it: You can also create a page from an existing template by clicking the arrow next to the blue New button in your database’s top-right corner, then selecting a template: How to Create a Database Template You can create a new template by clicking the arrow next to the blue New button in the top-right corner of your database, then clicking New Template. From there, you can add any content you want to the template. You can also set default values in properties, which will be applied to any new page that you generate from the template. Default Templates After you’ve create a database template, you can choose to have that template automatically applied to any new pages you create. You can do this in two different ways: Set the template to be applied only on new pages in the current database view Set the template to be applied on pages created in all views of the database To set a template as a default, click the blue arrow next to the New button and find your template. Then click the ••• menu next to the template and choose Set as Default. Once done, you’ll see the options I mentioned above: Choose “For all views” if you want the template to be applied in all views of the database (i.e. it will always be applied). Choose “Only on…” if you want the template to only be applied on the current view of the database. Self-Referential Filters One of the most useful things you can do with a database template is to combine it with a Linked Database and set up what’s called a self-referential filter. If you wanted to create a database template inside a Projects database, which shows all the tasks related to the current project, you’d use a self-referential filter for that. Note: Self-referential filters are tools for Notion power users. You should be familiar with Relations and Linked Databases before worrying about them. A self-referential filter is a filter inside a database template that updates itself when you create a new page from that database template. Specifically, a self-referential filter: Is set on a Linked Database that is placed within a database template. Filters a Relation property, which targets the database that contains the database template. Targets the database template itself. Essentially, a self-referential filter helps you filter a linked database view so that it only shows rows that are related to the page that contains that linked database. When you set it up in a database template, you set it to target the template itself – but when you create a page from that template, the filter updates itself! Here’s a look at one in action. Here, I’m editing the Project Template in the My Projects database. I’ve created a linked database, which points to the My Tasks source database. In the filters, I’ve set up a filter that states: Project contains Project Template This means that only rows with Project Template set in their Project Relation would show up here. Of course, filtering for Project Template wouldn’t be very helpful. It’s a template, not an actual project. But watch what happens when I create a new project – Suit Redesign – and generate its page content from the Project Template: As you can see, my filter has automatically updated itself! Now it reads: Project contains Suit Redesign Crucially, I didn’t have to edit the filter myself. That’s the beauty of a self-referential filter; it auto-updates so that it targets your current database page instead of the database template. Rollups The Rollup property type allows you to pull property information from any rows that are connected to your current row through a Relation. You can also perform calculations on that information. To create a Rollup, add a new property just as you’d do for all other property types. Then set the Relation, Property, and Calculate options (explained below). Here, I have a Rollup called Undone Count in the My Projects database. It’s configured to show the state of the Done property for each of the rows that are related to my Suit Redesign row: See how the Rollup essentially allows me to pull information about the properties in these related rows? Not only that, but it collects this information in a single area; in other words, the information is “rolled up”! Rollups have three configuration options: Relation – the Relation property in your current database that you’d like to “reach through” Property – the Property in the database where the other side of the Relation exists (e.g. my Tasks Relation points to the My Tasks database, so it’s targeting the Done property of the rows there) Calculate – the way in which you’d like to display the information By default, Rollups will use the Show Original setting within the Calculate dropdown. However, you’ll find lots of other choices depending on the property type that you’re rolling up. If I set Calculate to Unchecked, I get a count totaling all the unchecked rows related to this project. In this case, both of the related tasks have been done, so the count is 0. Formulas Learn even more about formulas in my comprehensive Notion formula reference guide. Or, if you’re short on time, check out my one-page Notion formula cheat sheet. The Formula property type allows you to write formulas that can: Pull in data from other properties Format and change data Do complex calculations Run if-then scenarios with multiple potential outcomes Notion’s formula property is by far its most complex, and there’s essentially no limit to what you can do with it. Fun fact: My Ultimate Brain template contains a 10,000-character formula that does complex recurring-date calculations directly in Notion! You can create a formula property in Notion in the same way that you’d create any other property. From there, you can click the property’s content area to open up an editor where you can write formula code: Underneath the editor, you’ll find a list of properties, functions, and more that you can use to create your formula. These include: Properties – includes all the properties in your current database Constants – such as e, pi, true, false Operators – if, add, subtract, greater than, less than, etc. Functions – join, slice, format, toNumber, etc. Since this is an overall guide to Notion databases, I won’t delve too deeply into how to write formulas here – check out the full formula reference guide for that. For this post, I’ll share two example formulas and explanations that will help you get started with writing your own formulas. Both of these can be found in the Simple Task Manager example template! Formula Example 1: Combine Numbers and Text The first formula we’ll cover can be found in the My Projects database within the Simple Task Manager template. The property is called Meta, and it simply takes the number from the Undone Count property and formats it to look nicer. Here’s the “compact” version of the formula that you can easily paste into Notion: format(prop(\"Undone Count\")) + \" Tasks Left\" Note: If you paste this formula into a brand-new Notion database, you’ll need the Undone Count property to exist first. Otherwise, you’ll get a Property Not Found error. I prefer to write my formulas in a code editor (such as VS Code) and then make them compact using this Excel Formula Beautifier (which can either “beautify” code or compress it). As the name implies, it’s meant for Excel formulas – but it works perfectly on Notion formulas as well. In fact, Notion’s formula syntax is extremely similar to Excel’s formula syntax. Here’s a version of the formula that’s easier to read: format( prop(\"Undone Count\") ) + \" Tasks Left\" The first part of this formula is: format(prop(\"Undone Count\")). It uses the prop() function to pull in the value of the Undone Count property, which is a Rollup (see the Rollup section above to learn more about those). I’m wrapping prop(\"Undone Count\") within the format() function in order to turn it into a String (which is basically just text). Notion formulas can output four different data types: String (plain text) Number Date Boolean (true/false, shown as a checkbox) However, a single formula can only output one data type. In other words, you can’t mix data types. Instead, you need to convert data types so that all of your output has the same type. The Undone Count Rollup property outputs a number, but ultimately my formula needs to output a string – e.g. “3 Tasks Left”. To achieve that, I use format() to transform that number into a string. It still displays as a number, but since it’s a plain-text string now, it can no longer be used in calculations (addition, multiplication, etc). Finally, I use the + operator to add my formatted number to this string: Tasks Left. Put them together, and you achieve a data-driven final output, such as: 3 Tasks Left! Formula Example 2: If-Then Statement Next, let’s look at how you can create variable output in a formula by using an If-Then statement. In the My Tasks database within the Simple Task Manager, I’ve created a formula property called State. This property outputs a different symbol based on the status of the task: ⏰ = task is overdue 😁 = task is done 🟢 = task is due today or later Here’s the compressed formula code, which you can easily paste into Notion: if(prop(\"Done\") == true, \"😁\", if(dateBetween(now(), prop(\"Due\"), \"days\") > 0, \"⏰\", \"🟢\")) Note: If you paste this formula into a brand-new Notion database, you’ll need the Done and Due properties to exist first. Otherwise, you’ll get a Property Not Found error. And here’s an expanded version of the formula that’s easier to read: if( prop(\"Done\") == true, \"😁\", if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"⏰\", \"🟢\" ) ) This formula has an if-then statement with another if-then statement nested inside it. By nesting if-then statements, we can create a formula that has more than two possible outcomes. To help you fully understand this formula, let’s first break down how if-then statements work. The basic syntax for an if-then statement in Notion is: if([test condition],[outcome if true],[outcome if false]) Essentially, we run a test, then define what do to if that test passes, and what do to if it fails. Here’s a bare-bones example: if(prop(\"Done\") == true,\"😁\",\"😡\") The == operator is testing whether the two pieces of information on either side of it are the same. Done is a checkbox property (with the data type boolean), so it outputs true or false. If the output of Done matches true, then the first option will be output: 😁. If not, Notion will output the second: 😡. Here’s where things get interesting – either of the output paths in an if-then statement can contain additional functions. This can include more if-then statements! So let’s walk through the nested if-then statement from our example above: if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"⏰\", \"🟢\" ) This statement will only be evaluated if the outermost if-then statement – if(prop(\"Done\") == true – returned false. This inner if-then statement tests to see whether the task is overdue or not. To do that, it uses the dateBetween() function, which finds the amount of time between two dates. I’m passing three arguments to this function: The now() function, which is built into Notion and returns the current date and time prop(\"Due\"), which returns the task’s due date \"days\", which simply specifies the unit of time dateBetween() should count by Finally, I check if the output of dateBetween() is greater than (>) zero. If it is, then the task is overdue and my formula outputs the ⏰ symbol. If not, the task is not overdue and the formula outputs the 🟢 symbol. As you can see, Notion formulas are extremely flexible and powerful. It’s also worth noting that practicing with Notion formulas is a good first step into actual programming if that’s something that interests you! Locking Databases Databases can take a long time to configure, and chaos can ensue if someone accidentally deletes a property, changes the settings of a view, or messes with a formula. Fortunately, Notion allows you to lock your databases in order to prevent these kinds of changes. To lock a database, first navigate to its original location. Open up the View Options menu and click Lock Database: When a database is locked, you won’t be able to make changes to its structure. You’ll still be able to create new rows and set property values, but you won’t be able to: Add new properties Delete properties Change property settings (e.g. change a formula) Add/edit/delete options from a Select or Multi-Select property Fortunately, if you need to make a change, you can easily unlock the database by clicking the Locked button at the top. Note that you’ll need to navigate to the original database to find this Locked button; you won’t see it on Linked Databases. Wrapping Up Whew – we’re done. In this guide, we’ve covered every main feature you’ll find within Notion databases. You’re now ready to go out and start creating your own databases. Using the features we’ve covered here, you’ll be able to create useful tools that fit your individual workflows and tasks like a glove – rather than relying on old-school productivity tools that don’t quite match the way you want to work. To learn even more about Notion, head to the Notion Fundamentals home page to check out all the lessons in this free series. You can also check out my Notion Templates, which can give you a head start and equip your workspace with an advanced task manager, note-taking system, habit tracker, and more. If you enjoy this content and want more, consider joining my Notion Tips email list! I’ll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-databases-the-ultimate-beginners-guide","title":"Notion Databases: The Ultimate Beginner’s Guide","date":"2022-06-03T16:37:44+00:00","contentLength":8787}},{"pageContent":"If you want to learn how to work directly with the Notion API, this tutorial will teach you how to do it – even if you’re a beginner with no coding experience. In this tutorial, you’ll learn: What the Notion API is and what it can do What an API is (in general) How to create a Notion API integration inside your Notion workspace How to send data to Notion via the Notion API How to create new pages in a Notion database via the Notion API How to read, understand, and actually use API documentation Lots of beginner-to-intermediate level JavaScript The Notion API already has great documentation, so here I’ll be teaching you how to actually use the API by walking you step-by-step through a fun example project – building a complete Pokédex in Notion! Many people have built Pokédexes in Notion by hand, but we’ll build ours with zero manual data entry. Everything will be handled by the Notion API and a small JavaScript application that we’ll build, which will automatically create an entry for each Pokémon. Here’s a look at the final product (you can also view this Pokédex directly on Notion): Each Pokémon has its own database entry with art, stats, description, and more. This is a great introductory project for learning how to work with the Notion API. And once you’ve completed it, you’ll have the knowledge and skill to do nearly anything else with the API. I have many more API tutorials planned, so if you’d like to get notified when they go live, join my Notion Tips newsletter. You won’t need any special software for this project – we’ll do everything in the browser using free tools. We’ll even code in the browser (of course, you can use your own local code editor if you want). I’ve also included deep explanations (in handy collapsible toggles) and external links that explain everything, so you’ll be able to use this as a true zero-to-hero path for learning Notion’s API. There’s even a fully mapped-out learning path below. Every Pokémon will get its own Notion database entry that includes its stats (HP, attack, defense, etc), types, flavor text, artwork, and more. We’ll accomplish this by building a simple JavaScript application that pulls all of this data from PokéAPI, a free and open-source resource with an immense amount of information on all things Pokémon. Our app will then format the data and send it to Notion. Note: This tutorial is meant for those who want to work directly with the Notion API using a programming language like JavaScript. If you’d like to work with the Notion API using no-code tools (like Make.com), check out this tutorial instead: How to Send YouTube Data to Notion (No Code) – Notion API Tutorial A step-by-step guide for importing YouTube views, likes, and other statistics directly into Notion – automatically, with no coding required. thomasjfrank.com What is the Notion API? To kick this off, let’s talk a bit about what the Notion API actually is. The Notion API is a set of tools that allow you to connect your Notion workspace to other apps and services outside of Notion (including apps you build yourself). Using the API, you could: Add new rows to a sales database in Notion when customers make purchases on your online store (using a platform like Lemon Squeezy or Shopify) Auto-transcribe voice notes using a service like Deepgram and send the transcript to a Notion page (tutorial on this coming soon! Join the newsletter to get notified.) Use Notion as a CMS for blog posts and display them on a custom-built website (like Braydon Coyer does – though you can also use Notaku for this instead of building a site from scratch) …and much more. The possibilities are basically endless. The Notion API provides endpoints for many major functions, including: Querying, creating, and updating databases Retrieving, creating, updating, and archiving pages Retrieving, creating, updating, and deleting blocks Appending child blocks to a parent block Listing workspace users and retrieving specific user information Creating and retrieving comments All API requests to the Notion API must be sent to the base URL https://api.notion.com, which you’ll see as the first part of the listed endpoint for any action you’d want to take. For example, if you wanted to query a database, you’d send a POST request to: https://api.notion.com/v1/databases/{database_id}/query Notion requires all API requests to be made over HTTPS, and they must be authenticated properly. To make API requests to your workspace, you’ll first need to create an integration (we’ll cover this later), then give that integration explicit access to pages in your workspace. Notion also provides a JavaScript SDK for working with the API. As you’ll see later in the tutorial, it’s easy to add this to your project, and it gives you access to handy methods that make API requests easy to construct in your code. If you’d like a more thorough overview, check out the official API documentation’s introduction. However, I think you’ll get a better grasp on the API by actually working with it – so let’s start doing that! If you do happen to want a primer or refresher on what an API is (in general), check out the toggle block below. What is an API? (General API Definition & Primer) APIs (Application Programming Interfaces) are sets of tools that allow different web services to talk to each other over the HTTP protocol. An API can allow one service to read data from another one; alternatively, it can allow one service to create new data at another service, update existing data, or even delete data. You’ll often see another acronym used to describe these four potential operations: CRUD. Create Read Update Delete APIs are what allow you to posts Giphy GIFs directly in Slack. They enable those awesome link previews that you can create in a Notion page. And they are the many engines under the hood of connector tools like Zapier and Make.com. APIs typically consist of one or more URLs, to which your application can make HTTP(S) requests in order to do one or more CRUD operations. These URLs are often called endpoints. Note: You may have a conversation in the future about APIs with a nerd who will stress that you access URIs, not URLs. The distinction really does not matter here, but here’s an article on their differences if you’re curious. In most cases, APIs will have separate endpoints for each type of operation you can do. In other words, you’ll almost never use the same endpoint to both read data and delete data. To see how an API actually works, let’s look at an example from PokeAPI – the API we’ll be working with later in the tutorial. One of PokeAPI’s endpoints is the pokemon endpoint, accessible via either one of these URL schemes: https://pokeapi.co/api/v2/pokemon/[pokemon name] https://pokeapi.co/api/v2/pokemon/[pokemon number] To access information about Charmander, you’d either use https://pokeapi.co/api/v2/pokemon/charmander or https://pokeapi.co/api/v2/pokemon/4. Since PokeAPI doesn’t require any special kind of authentication, you can even visit these URLs in your browser. Here’s a link you can try. However, you’ll quickly realize that visiting that URL in the browser isn’t very useful; you’re just presented with a huge string of JSON. I’ll cover JSON more thoroughly later, but you can watch this video now if you’re curious about what it is and how it works: However, if you make that request from a program, you can use additional code to process that JSON response and do really useful things. For example, you could write code that goes through all that data, pulls out the Pokemon’s name, and displays it. I show this example later in this guide (click here to jump to it), so I won’t repost it here. Of course, you can do much more than just display the Pokemon’s name. Once you have the information, you can do basically anything with it, so long as you know how to write the required code. That’s the power of an API: It allows you to do CRUD operations, and then combine them with any sort of code you want to write. The applications are basically limitless. To wrap up this small primer, I’ll go over the five most common HTTP methods available to you when working with APIs. You’ll see these all the time, so it’s good to be familiar with them. GET – used for reading data from the application. It is read-only, so it has no risk of modifying any data. POST – sends data to the application to create something new. PUT – sends data to the application to update an existing resource. Contains a full updated copy of the resource. PATCH – also updates an existing resource, but only contains the changes to be made instead of the entire updated resource. DELETE – sends an instruction to the application to delete an existing resource. In many cases, your requests to a particular API will need to contain both the URL to be accessed and the method to be used. For example, if you want to create a page in Notion via the API, you’ll need to access the https://api.notion.com/v1/pages endpoint using a POST request. You’ll learn much more about APIs simply by working through this project. However, you can also get additional insight with the following resources. First, check out Fireship’s excellent (and short) overview: If you fancy long videos, you may also enjoy freeCodeCamp’s APIs for Beginners course (though you could also just watch the video version of this tutorial near the top of this page! “What If I Don’t Know How to Code?” In this project, we’ll build our application using JavaScript. So if you have a basic understanding of JavaScript, you’ll be more comfortable going through it. However, you don’t need to already know JavaScript to go through this tutorial. My entire goal with this tutorial is to help non-technical people dip their toes into the world of coding and working with the Notion API. I’ve gone to great lengths to make it a truly comprehensive resource. Read this if you’re feeling anxious or overwhelmed about coding If you don’t know how to code – if you get confused and overwhelmed at most coding tutorials – I’ve been in your shoes. At the beginning of last year (2022), I didn’t know how to code. I barely knew what an API was. I tried to watch tutorials, but I’d get confused when the creator would throw around terms like “npm”, “node.js”, and “API endpoint” without explaining them. Eventually, after much Googling and a lot of frustration, things started to click for me. Hopefully I can spare you some of that frustrated Googling (Froogling?) with this tutorial. As you’ll see later, I’ve added lots of toggles just like this one throughout the tutorial. The purpose of these is to give you an explanation for everything if you need it (and keeping these explanations in toggles lets more experienced coders skip past them easily). However, the best piece of advice I can give you for learning how to do is this: Run your code early and often. The true “best” way to learn how to code is to write a lot of code and to get lots of feedback. Luckily, you get feedback pretty quickly when you’re coding; when there’s an error, it’ll be logged in your console or somewhere else. So dive in and get your hands dirty! To build any skill, you need 3 ingredients:1. Quality instruction2. Deliberate practice3. FeedbackMost people don't get nearly enough of #3 because they're too afraid of making mistakes or getting judged.Don't be one of them.Try often, get judged often, learn faster.— Thomas Frank (@TomFrankly) October 20, 2022 As we go through this tutorial, I’ll include asides and primers about all of the tools and concepts we’ll use. However, I’ve also collected them all in this learning path toggle, enabling you to find them all in one place. Full Learning Path and Resource List This project involves working with several tools, two different APIs, and multiple JavaScript programming methods and concepts. Here, I’ve compiled a full list of all of these things, along with some general resources you can use to learn JavaScript more comprehensively. I encourage you to use this as a reference, but don’t let its length intimidate you! If you follow the rest of the tutorial, I’m confident that you can get the entire project working even if you don’t understand everything right away. Once you do, you’ll be in a better position to go back, dig into these resources, and really understand how they all fit together. Tools Used in This Project This is a list of the specific tools and libraries we’ll use in this project. Since we’ll be building in Glitch, you don’t really need to worry about their details – Glitch will take care of most of the work for you. Glitch – a free platform for building websites and web apps. Includes everything – a full code editor, Node.js backend, npm package manager, terminal, and more. Node.js (automatically set up by Glitch) – a runtime for JavaScript. Allows you to run JavaScript code outside of the browser, effectively enabling JavaScript to be used as a back-end (server-side) language. Learn more about Node here. Npm (automatically set up by Glitch) – the Node Package Manager. Allows you to very easily include external code libraries in your project and use them. There are thousands of packages, including one for Notion’s API. PokéAPI – an open-source API that enables you to access pretty much any data related to Pokémon that you could ever want. Notion API – Notion’s official API, which allows you to read, write, update, and delete resources in a Notion workspace. Axios – a free HTTP library that works with Node.js. This is the library we’ll use to access the PokéAPI. Note: You can also build this project on your local machine. I’m using Glitch because it keeps things extremely simple and takes care of the setup. If you want to go the local route, you’ll need a code editor like VS Code. You’ll also need to install Node.js and npm. JavaScript Learning Resources These free courses and general-purpose resources are great for developing a full understanding of JavaScript. JavaScript Algorithms and Data Structures – a full, free, and interactive JavaScript course by freeCodeCamp. This is, IMO, the best beginner resource for learning JavaScript. The course has hundreds of mini-lessons, each of which teaches a concept and then has you actually use it in the in-browser code editor. I have only done the Basic JavaScript and ES6 sections of this course, personally. You absolutely don’t need to finish the entire course to understand this tutorial. That Weird JavaScript Course – Fireship’s great series of YouTube videos on JavaScript. Each is super-entertaining and does a great job at explaining JavaScript at a high level. The Modern JavaScript Tutorial – an excellent written guide to JavaScript. The MDN Web Docs – the definitive technical reference for JavaScript. I’ll be linking to this many, many times in this guide. Beginner JavaScript Notes – a free “cliff’s notes” version of Wes Bos’ paid Beginner JavaScript course. JSFiddle – a tool for running small code snippets in your browser. Great for testing things out without much required overhead. Specific Concepts This is a list of the individual concepts and programming patterns/data structures we’ll use in this tutorial. I’ve listed the actual methods we’ll use separately below. These have been ordered roughly by their difficulty, and I’ve included a recommended understanding level for each. This isn’t a requirement; I think you can work your way through this tutorial and refer to these concepts as you go. It’s more an indication of my own perceived understanding of each concept at the time I built this project. Concept Recommended Understanding Variables – const vs. let Full Data types – string, number, etc Full Variable scope Medium Boolean values – truthiness and falsiness Full Console logging Basic Arrays Basic Objects Basic Accessing object properties Full Functions Basic Conditional statements Medium Ternary syntax (for conditionals) Full For loops Full For…of loops Full Try/catch blocks Basic Requiring modules in Node.js Basic REST APIs Basic Template literals Basic Arrow functions Medium Object destructuring Medium Destructuring nested objects Full Regular expressions Basic Promises Basic Async/await Basic Specific Methods We’ll use several built-in JavaScript methods throughout this tutorial. Below, I’ve linked to the documentation for each one on the MDN Web Docs. These are ordered alphabetically. Array.prototype.find() Array.prototype.join() Array.prototype.map() Array.prototype.pop() Array.prototype.push() setTimeout() String.prototype.replace() String.prototype.split() String.prototype.substring() String.prototype.toUpperCase() How to Go Further If you finish this tutorial and want to push your skills even further, here are a few challenge ideas: Use the Notion API and database relations to display the evolution chain for each Pokémon. Display a table within each Pokémon’s page that contains each move that it can learn. Push the data from your Notion Pokédex to a static website (example: Daniel Shiffman’s Nature of Code site uses Notion as a CMS) Steal My Code and Create a Pokédex Instantly If you just want the code you’ll need to build a Pokédex, you’re in luck! I’ve built this project on Glitch, which is a free platform that allows people to build and share working web apps and sites. Here’s the direct link to my Glitch project. There’s a handy Remix feature that allows you to fully copy my Pokédex project and run it for yourself. All you’ll need to do is create a free Glitch account, hit the Remix button, and follow the instructions in the README.md file. Even if you intend to follow this tutorial and build the project from scratch, I’d encourage you to first Remix mine and see how it works! One of the most powerful ways to learn faster is to prime your brain by skipping ahead and getting a preview of what you’re trying to accomplish. Even if you don’t fully understand it, you’ll be setting your brain up to more readily understand each piece of the process once you go back and start it in earnest. I’ve also meticulously commented my code, so you can work through it and get an explanation of how everything works. To get the script running: Create a Glitch account and hit the Remix button on my project. Duplicate my Pokédex Template into your Notion workspace. Follow the instructions in this section → Create Your Notion Integration Follow the instructions in this section → Set Your Environmental Variables Open the Terminal. Type node index.js and hit Enter. By default, the script will pull the first 10 Pokémon into your Notion database. To change this, modify the start and end variables (lines 65 and 66 in index.js, or 18 and 19 in index-nocomments.js). Full Project Code I’m also going to share the full code for this project right here. As we work through the tutorial, I’ll include smaller code snippets that focus on the specific part we’ll be building at that point. However, you may want to reference the project code in its entirety; when that happens, just open one of these toggles. Full Project Code (No Code Comments) Remember that you can view this code directly on my Glitch project as well! It is located in the index-nocomments.js file. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage(); } getPokemon(); const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Full Project Code (With Comments) Remember that you can view this code directly on my Glitch project as well! It it located in the index.js file. /* Bring in the external packages we'll be using. Axios is an HTTP client that makes working with APIs easier: https://axios-http.com/docs/intro Additionally, we bring in the Notion API client so we can make requests to it. */ const axios = require('axios') const { Client } = require('@notionhq/client') /* Create a new object 'notion' that gives our code access to the Notion credentials set up in the .env file */ const notion = new Client({auth: process.env.NOTION_KEY}) /* Create a blank array in which we'll store an object for each pokemon fetched from the PokeAPI */ const pokeArray = [] /* Create a function for making requests to the PokeAPI. We have to use an asynchronous function becuause axios.get() returns a Promise. Without using an async function, the rest of our code would run before axios gets a response from the PokeAPI. */ async function getPokemon() { /* Define start and end variables for the 'for' loop below. These numbers would usually be set directly in the for loop itself, but I've made them into their own variables so you can easily tweak them. They correspond to actual Pokemon numbers - e.g. 1 = bulbasaur. */ const start = 1 const end = 10 /* This 'for' loop will make the first set of requests to the PokeAPI. We're using a basic 'for (let i = num)' loop because i will correspond to specific Pokemon numbers. So if you only wanted the original 151, you'd set start at 1 and end at 151. */ for (let i = start; i <= end; i++) { /* Use the axios.get() method to make a GET request to the PokeAPI's 'pokemon' endpoint: https://pokeapi.co/docs/v2#pokemon This endpoint allows to to access MOST of the information we need. The only info we can't get from this endpoint is flavor text, generation #, and category (e.g. \"Flame Pokemon\"). For that info, we'll have to query the 'pokemon-species' endpoint later on. Note how we're using a template literal in order to pass our `i` variable's value into the URL. This is what will allow us to call PokeAPI for the correct pokemon on each run of the loop, e.g. https://pokeapi.co/api/v2/pokemon/4 (when i = 4) will get Charmander. */ const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { /* Pokemon have a variable number of types (some have 1, some have 2). The Notion API expects Multi-Select property selections to come in the form of an array of objects, so we need to create an array of objects that we can pass when we're setting the 'Type' Multi-Select property's values. First, we store the types array from PokeAPI in the typesRaw variable. */ const typesRaw = poke.data.types /* Now we'll create a blank array that will contain our type objects, which will be formated specifically so they'll work with the Notion API. */ const typesArray = [] /* Create a for...of loop that will loop through all the elements of typesRaw. For each one, we'll create an object 'typeObj' which is formatted as needed for the Notion API, which which contains ONE of the Pokemon's types. Since the number of loop iterations is defined by the length of the typesRaw array, we'll end up with a new array (typesArray) that contains an object for each of the Pokemon's types. E.G. - Butterfree is Bug-type and Flying-type, so its typesArray will have two elements. */ for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } /* Add the object onto the end of typesArray */ typesArray.push(typeObj) } /* The PokeAPI returns very basic formatting for Pokemon names - e.g. 'Mr. Mime' is formatted as 'mr-mime'. We want to show names with proper punctuation and capitalization in Notion - e.g. 'Mr. Mime'. This is also important for auto-generating links to Bulbapedia, where more information about each Pokemon can be found (this is a basic Pokedex that doesn't include move information, locations, etc.) To accomplish this, we're running the poke.data.species.name object through several functions. First, the split().map().join() combo capitalizes the first letter of each word - e.g. 'mr-mime' becomes 'Mr Mime'. When methods are chained like this, they are executed left-to-right. So the return value of split() is fed into map(), and map()'s return value is fed into join(). Then, we run that result through a gauntlet of replace() calls to deal with edge case Pokemon like Type: Null, Ho-Oh, Mr. Mime, and Nidoran♀ - all of which include punctuation or symbols. Each replace() call looks for a regular expression match and replaces the first one it finds with the next argument. */ const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") /* Define a variable that holds the bulbapedia URL for the Pokemon. Bulbapedia has a very standardized URL scheme for Pokemon, so all we need to do is pass in the processedName variable and then replace any space characters it contains with underscores. All other special characters are left in the URL - even :,é,-,etc. Example URL: https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pokémon) */ const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pokémon)` /* Here we're defining a variable for the sprite using ternary syntax (? and : ) to create a conditional statement. We need to do this because certain Gen VIII Pokemon were introduced in Pokemon Legends: Arceus and do not have a sprite. The PokeAPI has an 'official-artwork' image for EVERY Pokemon, so we'll set the value of sprite to 'official-artwork' if a 'front_default' sprite doesn't exist. (!poke.data.sprites.front_default) is a Boolean check; if the value of this object is null, it'll evaluate to false. */ const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default /* Now we'll construct the object that will hold all of the data about this Pokemon. If you recall, we aren't able to pull generation, flavor text, or category from PokeAPI's 'pokemon' endpoint, so we'll add those to this object later. For now, each object property is being set to the value of the corresponding property returned from our first PokeAPI call. Note how ['official-artwork'] is defined differently. Property key names with dashes or spaces must be called using 'bracket notation' rather than 'dot notation'. */ const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } /* Send a log to the console with each fetched Pokemon's name. Doing this will allow the console to show activity the whole time the script is running. Without it, you'll just see a blank spot in your console while the script takes minutes to run. */ console.log(`Fetched ${pokeData.name}.`) /* Push our pokeData object onto the end of the pokeArray array. This is done each time our loop executes, resulting in an array full of objects - one for each Pokemon that you included in the loop (using the start and end numbers). Each object will look just like the pokeData object definition above, except the properties will contain actual information. If you want to see how these look, add console.log(pokeData) above this line. */ pokeArray.push(pokeData) }) .catch((error) => { /* if axios.get() fails and throws an error, this catch block will catch it and log it in the console. */ console.log(error) }) } /* We now need to call another PokeAPI endpoint to get three more pieces of information about each Pokemon: - Flavor text (e.g. \"Spits fire that is hot enough to melt boulders. Known to cause forest fires unintentionally.\") - Generation (e.g. I, II, III...) - Category (e.g. \"Flame Pokemon\", \"Owl Pokemon\") These must be obtained from the pokemon-species endpoint (https://pokeapi.co/docs/v2#pokemon-species) We now have all of the Pokemon we'll sent to Notion in pokeArray, so we'll now use a for...of loop to loop through that array, get the 'species' info for each element from PokeAPI, and add each piece of info to that pokemon's object in pokeArray. */ for (let pokemon of pokeArray) { /* Just like we did above, here we use axios.get() to call the PokeAPI endpoint we want. Note that this time we're passing the pokemon.number property from the current element of pokeArray (which is stored in the pokemon variable created in this loop) into the PokeAPI URL. */ const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { /* Create a variable to store the pokemon's flavor text. Depending on the pokemon, PokeAPI will have a differing number of flavor text options. These are all stored in an array called flavor_text_entries, and the English-language flavor text might be at any one of the indexes. See for yourself: Go to pokeapi.co and enter 'pokemon-species/charmander' in the testing box. Array index 0 (the first one) contains English-language flavor text. However, try 'pokemon-species/cramorant' and you'll see that the English flavor text doesn't show up until Array index 7. So instead of calling a specific array index, we have to search deeply inside the array's objects to find the one that has a 'language' object, which itself contains a 'name' property with a value of 'en'. To accomplish this, we call the find() method on the flavor_text_entries array, which returns the first array element that satisfies a test condition we'll set up though a function. That function is name === 'en'. To make sure the value of the nested 'name' property is fed into the function as the 'name' varible, we do what is called nested object destructuring. ({language: { name }}) tells find() that for each array element, go into its language object, then into the name property nested within, and pass name's value as the variable for the function. find() returns the full array element that matches the test condition, so we then tack on `.flavor_text` to get the value of its flavor_text property. Finally, we pass the found value through replace(/\\n|\\f|\\r/g, \" \") to replace any newline characters with spaces, resulting in a single line of flavor text. */ const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") /* Here we do the exact same thing as was done with the flavorText variable, except for the 'genus' property, which is PokeAPI's term for the category - e.g. \"Flame Pokemon\" */ const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus /* Now we get the pokemon's generation. It is returned in this format: 'generation-i' - but we want it to simply be 'I', so we run the result through split(/-/), which splits the string into an array using the dash character (-) as the divider. Then we use pop() to \"pop\" the last element of that array off of the array and return it - this will always be the generation number in Roman numerals, e.g. 'iv'. Finally, we pass that value through toUpperCase() to capitalize it - e.g. 'IV'. */ const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() /* Now we add our three new pieces of information to the current pokemon's object by creating three new properties within that object, and then assigning them the values from our three variables above. Note how pokemon['flavor-text'] uses bracket notation; this is required when an object property name has or will have spaces, dashes, or other special characters in it. Dot notation can only be used when property names contain letters, numbers, and underscores. */ pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation /* Add a log entry in the console each time this information is fetched from PokeAPI. */ console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { /* Log any errors thrown by axios.get(), just as in the previous loop block. */ console.log(error) }) } /* Once both loops have finished running, we call the createNotionPage() function which is defined below. It's important to note that we're calling this function within the getPokemon() function. Since getPokemon() is an async function, calling createNotionPage() outside of it (in the global context) will cause createNotionPage() to run before getPokemon() can finish construcing its array of objects. Calling it here forces createNotionPage() to run only after our two loops have completely finished fetching and formatting the data from PokeAPI. */ createNotionPage(); } /* Here's where we actually call the getPokemon() function. When you type `node index.js` in the Terminal to run this script, it immediately runs this function, which kicks off everything else. Note how we've defined additional functions below this; these are totally fine to exist below this line because JavaScript \"hoists\"function definitions to the top when it actually runs a .js file. Look up \"JavaScript Hoisting\" to learn more about this. */ getPokemon(); /* Create a \"wait\" function to comply with Notion API rate-limiting. The Notion API only allows ~3 requests per second, so after we create each new page in our Notion database, we'll call this sleep function and have it wait for 300ms. This will ensure that our app doesn't try to send data to Notion too quickly, which would cause our calls to eventually fail. */ const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; /* Create a function for sending our data to the Notion API. As with getPokemon(), this function has to be async because it is using axios.get(), which is an asynchronous method that returns a Promise first. Therefore, we must await it, and to do that it has to be inside an async function. */ async function createNotionPage() { /* Here's our main loop for the process of sending data to Notion. We already have our array of pokemon objects (pokeArray), so we can use a for...of loop to iterate through it. For each element, we'll construct a new object that formats the data in the way Notion wants. Then we'll create a new page in our Notion database with that data. */ for (let pokemon of pokeArray) { /* Here we'll construct the data object that we'll send to Notion in order to create a new page. This object defines the database in which the page will live (the \"parent\") and sets its icon, cover, and property values. It also adds a few blocks to the page's body, including the flavor text and a link to the pokemon's Bulbapedia page. I won't verbosely comment every piece of this object definition. Instead, I'll encourage you to study it and also point you to a few reference pages that you'll fine invaluable for working with the Notion API: - Property Values: https://developers.notion.com/reference/property-value-object - Block Objects: https://developers.notion.com/reference/block - Create a Page: https://developers.notion.com/reference/post-page Note how, for each block, we're setting the relevant property values to the variables in our pokemon object (except for the database ID, which is set by process.env.NOTION_DATABASE_ID). It's also useful to note that EVERYTHING in Notion is a block. The 'data' object will end up being a block that is recognized by Notion as a page due to the 'parent' value we're giving it (a database), and due to the fact that we're using the notion.pages.create() method to create it. However, you can see below that this block has children, which are blocks that will show up as its page content. Note that you can create 'block children' under nearly any block - not just under a page! See more: https://developers.notion.com/reference/patch-block-children */ const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } /* Here we call our sleep() function, passing it a value of 300 so that the loop \"sleeps\" for 300ms before going onto the next cycle. This ensures that we respect the Notion API's rate limit of ~3 requests per second. */ await sleep(300) /* Finally, we actually create the new page in our Notion database. First, we add a log item to the console for our own benefit. Then we call the notion.pages.create() function, which creates a new page in our database. We pass it our data object (defined above), which contains all of the necessary information. Finally, we store the Notion API's response in the response variable, and log it. */ console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } /* When the entire process is done, this will simply print \"Operation Complete\" in the console. */ console.log(`Operation complete.`) } Bonus: My developer’s take on the getPokemon() function As I mentioned above, I only learned how to code in JavaScript this year, so my skills are not well-honed. Fortunately, that doesn’t matter much. These days, computers are so powerful that simple applications can be built many ways. Even if the code isn’t perfectly-optimized, it’s “good enough” so long as it gets the job done and handles errors well. Still, there are often better ways to do things. To show you an example, below I’m sharing my full-time developer Eli’s take on the getPokemon() function. He readily admits that his code is less readable than mine, but it does result in a 40% reduction in code length. In professional setting, my code above would probably get refactored to look more like his. async function getPokemon() { const replacer = (str) => { const n = { \"Mr M\": \"Mr. M\", \"Mime Jr\": \"Mime Jr.\", \"Mr R\": \"Mr. R\", \"mo O\": \"mo-o\", \"Porygon Z\": \"Porygon-Z\", \"Type Null\": \"Type: Null\", \"Ho Oh\": \"Ho-Oh\", \"Nidoran F\": \"Nidoran♀\", \"Nidoran M\": \"Nidoran♂\", \"Flabebe\": \"Flabébé\", } let pn = Object.keys(n).find((o) => str.includes(o)) return pn ? str.replace(pn, n[str]) : str } let urls = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=50`) .then((r) => r.json()) .then((d) => d.results.map(u => u.url)) let base = await Promise.all(urls.map(async (url) => { let d = await fetch(url).then((r) => r.json()) let name = replacer(d.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1) })[0]) return { name: name, number: d.id, types: d.types.map((t) => t.type.name), height: d.height, weight: d.weight, hp: d.stats[0].base_stat, attack: d.stats[1].base_stat, defense: d.stats[2].base_stat, specialAttack: d.stats[3].base_stat, specialDefense: d.stats[4].base_stat, speed: d.stats[5].base_stat, sprite: d.sprites.front_default, artwork: d.sprites.other['official-artwork'].front_default, bulbURL: `https://bulbapedia.bulbagarden.net/wiki/${name.replace(' ', '_')}_(Pokémon)`, } })) let flav = await Promise.all(base.map(async (p) => { let d = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${p.number}`).then((r) => r.json()) return { flavorText: d.flavor_text_entries.find(({language: {name}}) => name === \"en\"). flavor_text.replace(/\\n|\\f|\\r/g, \" \"), category: d.genera.find(({language: {name}}) => name === \"en\").genus, generation: d.generation.name.split(/-/).pop().toUpperCase() } })) return base.map((b, i) => ({...b, ...flav[i]})) } ​ getPokemon().then((r) => { createNotionPage(r) }) What You’ll Need to Get Started To successfully complete this tutorial, you’ll need a few things: A Notion account. Even the free tier is able to work with the API! A Notion database that you’d like to use for your Pokédex (you can start with my template below). An integration in your Notion account. We’ll create this in the first step of the tutorial. A free Glitch account. This is the platform where we’ll build and run the application. Don’t Want to Use Glitch? You can also build and run this project locally on your own computer. Likewise, you could do things like the pros, pushing your code to Github and then deploying it to a company that can host Node.js apps such as Vercel. The reason I’ve chosen to build this project on Glitch is because it gives you a complete starting point for free. We can code directly in the Glitch editor and then run our code directly in Glitch’s terminal. If you’d rather build this project locally, here are the prep steps you’ll need to take: Get a code editor – I recommend VS Code, as it has a built-in terminal for running your code along with many extensions and a huge community. Install Node.js and npm. The Node.js LTS installer should install both. Refer to this guide to see other ways to install (included the recommended-yet-harder nvm method), and to see how you can check that node and npm are indeed installed on your machine. Follow this guide to set up VS Code for a Node.js project and to move into the correct directory where you want to build your app. Once you have your project set up with a package.json file, type npm install axios in the terminal and hit Enter to add the Axios package to your project. It should show up in the package.json file under dependencies. Likewise, type npm install @notionhq/client in the terminal and hit Enter to install the Notion SDK package. Just like on Glitch, you’ll need to create a .env file in your project and add your authentication details to it. However, Glitch automatically takes care of a few things you’ll have to do manually here. First, type npm install dotenv and hit Enter in the terminal to install the dotenv package and add it to your package.json. (Glitch includes this by default.) In your project’s root directory (the same top-level folder where package.json is contained), create a filed called .env (no other file extension). Add your environment variables to this file and hit Save. Replace these default values with your Notion integration key and your target database’s ID. Refer to the Create a Notion Integration section for more detail on this. NOTION_KEY = blargablargblarg NOTION_DATABASE_ID = blargblarg At the top of your index.js file, you’ll also need to include: require('dotenv').config() This will allow your app to access the variables defined in your .env file. You can test this by adding these lines to your index.js file, then running node index.js in the terminal: console.log(process.env.NOTION_KEY) console.log(process.env.NOTION_DATABASE_ID) If you plan on pushing your code to Github or otherwise using git for version control, you’ll also want to create a .gitignore file in your project’s root directory. Then, add .env to that file and commit your .gitignore to your repo (see this more comprehensive guide for more detail): .env From there, you can follow the rest of the instructions in this tutorial. If you’d like to learn more about .env files and running things locally, see this guide: How to Use Environment Variables in Node You can use any database you want to create your Pokédex, but if you’d like a head start, you can use this free Pokédex Notion template I’ve created for you. The template is an exact copy of my public Pokédex, minus all the actual Pokémon. It comes with all the properties and views pre-configured, so you can skip all of the database setup and get to coding. Since I’m providing this template, I won’t cover the database set up in this tutorial. However, if you want to learn more about setting up Notion databases, check out my beginner’s guide to Notion databases. You may also find my complete Notion formula guide helpful for understanding some of the formulas in this template! Tutorial Overview Before we start coding, let’s do a quick overview and cover what we’ll be accomplishing. We know that we want to pull information about each Pokémon from PokéAPI and then create a new page in our Notion database for each Pokémon – but how exactly will we do that? First, the prep work: We’ll set up our Pokédex database on Notion, create a Notion API integration, and ensure the integration is able to edit the database (covered in the very next section). Once that’s done, we’ll build the script that will actually execute the process of getting the data and sending it to Notion. Let’s break down the process. Don’t worry if you don’t know what GET and POST requests are – I’ll explain them as they come up! For each Pokémon, we’ll send a GET request to PokéAPI. This will contain the URL that maps to the specific Pokémon we want information about – e.g. https://pokeapi.co/api/v2/pokemon/4 (you can paste that link directly in your browser to see the response). PokéAPI will accept our GET request if it is formatted correctly. PokéAPI sends back a response that contains all of the Pokémon data we want, plus other meta info. The response contains way too much data, and it’s not always formatted perfectly. So we’ll do some work to process the response directly on our web server (Glitch/Node.js). For each Pokémon, we’ll create a custom JavaScript object called pokeData that will contain all the info we’ll need. We’ll do the work to extract and format the data from PokéAPI and add it to the pokeData object – including name, height, weight, base stats, artwork, etc. We’ll add each pokeData object to an array called pokeArray. Now we’ll make a POST request to the Notion API for each Pokémon within pokeArray. Assuming our request is formatted correctly and authenticated, Notion will create a new page within our Pokédex database, setting property values and populating the page content with the information we sent over. Finally, the Notion API will send back a response that we’ll simply log. Here’s a graphic that shows the entire process visually (you can also view this directly on Whimsical): Now that you’ve got a map in your head for what we’ll be building, let’s build it! Create a Notion Integration The first thing we’ll do is create an integration within your Notion account. This integration will allow you to work with the Notion API and make changes to your workspace. Note: You’ll also find these instructions in the getting started guide within the Notion API docs. We’ll be referencing these docs a lot later on, and I highly recommend getting familiar with them if you plan on building more Notion API integrations! To start, make sure you’ve duplicated my Pokedex template into your Notion workspace. This template contains all the properties and views you’ll need. Next, you’ll need to create an integration in your Notion account. Click here to go directly to the “My Integrations” area of your account. Alternatively, you can find this page by going to Settings & Members within the Notion app, then navigating to My Connections → Develop or Manage Integrations. Click New Integration. Fill out the Basic Information for your integration. You can leave most of the settings at their defaults, but set these as needed: Name: Any descriptive name. I’ll use “Notion Pokedex Integration” in this guide. Associated workspace: Choose the workspace you want this integration to work with (aka the one that contains your Pokedex database). User capabilities: Set to no user infomation. This project doesn’t need user info, and it’s a good practice to limit integrations to only the capabilities they need. Click Submit. Once the integration has been created, you’ll see a field where you can show your internal integration token. Copy this token to your clipboard; you’ll need it when we start setting up the project in Glitch. Important: Keep this token secret. As this tutorial will show you, an integration token allows external tools and scripts to make changes to your Notion workspace. Show the token, then copy it to your clipboard. Additionally, note where it says, “Only works with [your workspace name] workspace”. If you want to work with another workspace, you’ll need to create another integration. You’ll also be able to see that your integration is set as Internal rather than Public. This is what you want! I’m just pointing it out in case you’re unsure which one should be selected. Add Your Integration to Your Pokedex Database Before we can move on, we need to give your integration permission to edit your database. To do that, head to your Pokedex: Click the ••• icon in the top-right corner. Find the Connections sub-menu. Find and select your integration. You’ll see the following message: Notion Pokedex Integration will have access to this and all child pages. Continue? Click confirm. Once connected, you’ll be able to navigate back to that Connections menu and see your connected integration’s permissions for this page. Note that any child pages/databases of the current page will also be accessible to the integration. Now that your integration can modify your Pokedex page, we can move onto the next step! Create Your Glitch Project We’ll be writing our actual code on Glitch, a free platform that lets you built and run websites and apps in a single, easy-to-use interface. To get started, head to Glitch and create a free account. Next, click New Project. You’ll be given the choice of a few different starter apps, but you should actually click Find More, as the one we want isn’t shown here. From this new page, find the Hello Node! starter project and choose the blank version. While you can use the regular Hello Node! app (and I do in the video tutorial above), it comes with a bunch of extra stuff you don’t need. It also doesn’t come with a .env file by default, whereas the blank version does. Select the blank version of the Hello Node! app. Once done, Glitch will set up a new project that is pre-configured to run Node.js, the server runtime that will allow us to run JavaScript code directly from the terminal (instead of needing to run it in web page). What is Node.js? Node.js is a backend runtime environment that allows JavaScript to be executed outside of the browser. Originally, JavaScript was designed to be a programming language that could only run in a web browser. This was initially done for security reasons back when JavaScript was first being built in the mid-1990’s. Over time, people started using JavaScript for more and more purposes. What was once meant to be a simple scripting language started getting used to build complex web applications. In 2009, Node.js was released in order to allow developers to write the JavaScript syntax they were familiar with in other contexts. Node allows JS code to do all sorts of back-end tasks, like processing user data, reading and writing to file systems, and more. If you want to learn more about Node.js, watch this video: The Glitch app gives you a complete development environment. Here’s a quick tour, going over the most important parts: The editor is where you’ll write your code. As you can see below, it can also render markdown files (.md files) with formatting. The sidebar gives you access to all of the files and assets within your project, and allows you to create more. You can also access your project settings here. The terminal will allow you to run your code. This is where we’ll run your Pokedex script. The main thing you should do right now is create an index.js file. This will be the file where we write our JavaScript code in the next steps. To do this: Click the + icon next to Files in the sidebar. Name the file index.js. Click Add This File. For now, you can leave this file blank. We’ll come back to it soon and start coding, but before that, we need to set up our environment variables and import a couple of packages. Let’s go! Set your Environment Variables For the script to be able to send Pokemon data to your Notion workspace, you’ll need to provide it with two pieces of specific information: Your internal integration token (set when you created your Notion integration earlier) The database ID for your Pokedex database Both of these are private pieces of information that shouldn’t be shared. When developing Node.js apps (which we’re doing here), there’s a best practice for storing private pieces of information with which the program needs to directly interact, and that’s to store them in as environmental variables in a .env file. So that’s exactly what we’ll do now, and we’ll start by gathering these pieces of information. What is a .env file? A .env file is a special file that contains environmental variables. These are often variables that hold sensitive information, such as authentication tokes for API access. .env files are never pushed to version-control systems like git, meaning that programmers and teams can use services like Github and even share open-source code without exposing sensitive information. If you want to learn more, check out this video: You should already have your internal integration key from when you set up your Notion integration; if not, head back to the My Integrations page and copy it. Next, we’ll get your database ID. Obtain Your Database ID Your database ID can be found within the URL of your Notion database. To find it, first navigate to your source database in Notion. If you’re using my Pokedex template, note that the template is a normal page that contains the source database. Click the Open as full page button on the database view to access the source database. Once you’re looking at your source database, copy its URL by going to the ••• menu and clicking Copy Link. Alternatively, you can use the shortcut ⌘/Ctrl + L. Within your database’s URL, your database ID is the string of characters after the final / and before the query symbols ?v=. // Full URL https://www.notion.so/thomasfrank/c9cdd00ed7314f9497f4ab23e9fa0bdd?v=2d6e86289d304cd1ab5ba08a0d9ec1b4 // Database ID c9cdd00ed7314f9497f4ab23e9fa0bdd Copy your database ID and paste it in a temporary holding place along with your internal integration token. P.S. – if you don’t have clipboard history enabled on your computer, now’s a great time to turn it on! On Windows, just hit ⊞ Win + V. If you’re on a Mac, get Raycast; it’s an incredibly powerful launcher tool with built-in clipboard history. Edit the .env File Now that you have your internal integration token and database ID, head back to Glitch. Your project should already have a .env file listed in the sidebar. If not, click the + one more time and create a file called .env. Add these two environmental variables. Ensure the labels are NOTION_KEY and NOTION_DATABASE_ID, but replace the example values with your own. NOTION_KEY=secret_LykgP0z2wvrYCiqAaWKu3j5uSokRvosbsqgWaHIjLw6 NOTION_DATABASE_ID=c9cdd00ed7314f9497f4ab23e9fa0bdd As the dialogue box pictured above will tell you, these environmental variable values will be visible to you and anyone else you specifically invite to edit your project. However, anyone else will merely see the variable names – not the values. That means you’ll be able to safely let people view (or even Remix) your project without revealing them. To learn more about how .env works in Glitch, check out their article on Adding Private Data. Add Your NPM Packages The script we’re building uses two external libraries that do a lot of the heavy lifting. These include The Axios HTTP library The Notion API’s JavaScript SDK Once we start coding, I’ll explain what these libraries actually do in more detail. For now, we simply need to bring them into our project and set up index.js so that our code can access and use them. Luckily, bringing these libraries into our project is very easy. Node.js comes with a package manager called npm, which lets developers quickly import packages (which contain these libraries) into their projects. Normally, a developer would install a package by typing npm install into the terminal along with the name of the package. For example, you could install the dadjoke library into your project by typing: npm install dadjoke You can actually do this on Glitch, and I’ll invite you to do so and then type dadjoke in the terminal to see what happens. For clarity: You do not need the dadjoke library for this project; it’s just a very simple library that you can easily use to test the npm install process. However, Glitch provides an even easier way to install packages. Simply head to your package.json file and click Add Package. From there, you can search for packages and click them to install. Search for and install the following packages. I’ve linked their npm pages below in case you need to double-check that you’re installing the right ones. axios @notionhq/client Once done, you’ll see that your package.json file has been updated with new depencies: \"dependencies\": { \"fastify\": \"^4.4.0\", \"handlebars\": \"^4.7.7\", \"@fastify/view\": \"^7.1.0\", \"@fastify/static\": \"^6.5.0\", \"@fastify/formbody\": \"^7.0.1\", \"axios\": \"^1.3.1\", \"@notionhq/client\": \"^2.2.3\" } Aside: NPM Packages Can Break (Here’s What to Do) As of this writing (Februrary 2023), both of the npm packages we’ll use in this project are in a working state. However, I actually went through the experience of dealing with a broken npm package while making this tutorial. After I filmed the video version in November 2022, Axios had a buggy update that broke its ability to make API calls. To make my script work, I had to manually roll Axios back to the 1.1.3 version. Today, Axios’ current 1.3.1 version is working – so you (hopefully) shouldn’t have any troubles with it as you go through this tutorial. That said, if you find that Axios – or any package – isn’t working in the future, here’s what to do. First, check the package’s Github Issues page to see if others are posting about a potential bug. For example, here’s the Issue I ran into with Axios (you can even see a comment from me in this thread). Checking for Issues on Github can help you confirm that there’s a problem with the package itself, rather than your code. Second, simply roll back to an earlier version of the package and see if that works. Axios’ 1.2 version broke my script, but I was able to roll back to 1.1.3 to get it working again. In Glitch, this is incredibly easy – just go into package.json and change the version number of the package. Refresh the page, and Glitch will take care of the downgrade in the background. Note: If you want to “lock in” a specific version of the package, take care to remove the caret ^ symbol – read up on SemVer if you’re curious about that. E.g. 1.1.3 instead of ^1.1.3. Elsewhere (such as your own machine with Node.js installed), run the npm install command with the version you want specified, like so: npm install [email protected] Even if the package is already installed with a later version, this command will replace it with the older version you specify. More detail on how to do this can be found at this post: How to downgrade an installed npm package – Nathan Sebhastian Learn how you can downgrade an npm package to rollback breaking changes sebhastian.com Now you’ve got the packages installed in your project. Before you can use them, however, you’ll need to “require” them within your index.js file. Head over to index.js and add the following lines to the top of the file (which should currently be blank): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) For our purposes, it’s not incredibly important to know exactly how require() works. But if you’re curious, here’s a great article: Everything you should know about ‘module’ & ‘require’ in Node.js by Srishti Gupta Everything you should know about ‘module’ & ‘require’ in Node.js Modules > Node.js treats each JavaScript file as a separate module. For instance, if you have a file containing some code and this file is named xyz.js, then this file is treated as a module in www.freecodecamp.org Make Your First Call to PokéAPI We’re finally ready to start coding! In this step, we’ll make our first call to PokeAPI and log the name of a Pokemon in the Glitch terminal. First, let’s look at how this actually works. In this Replit embed, I’ve created a very simple script that will call PokeAPI once. Go ahead and hit Run to see what happens. If everything went smoothly, you should see bulbasaur displayed in the terminal. Here’s a look at the code: const axios = require('axios') async function getPokemon() { await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) } getPokemon() This very simple script does three things: Uses require('axios') to make the axios library’s methods available for use in the script Defines an asynchronous function getPokemon(), which will call PokeAPI and console log the name of the first pokemon Calls the getPokemon() function in order to run it Once the function is called, the code inside it runs. Here, we’re only doing two things: Using the axios.get() method to call a specific resource within PokeAPI. In this case, it’s the first entry in the pokemon resource, which contains data about bulbasaur. Once we get the response, we use JavaScript’s built-in console.log() function to display the pokemon’s name in the terminal PokeAPI returns JSON data, so we access specific pieces of that data by using dot notation. To get the name, we have to traverse the JSON data tree. Property accessors – JavaScript | MDN Property accessors provide access to an object’s properties by using the dot notation or the bracket notation. developer.mozilla.org PokeAPI is mainly a learning tool, and they actually have a great interface for exploring the API’s data right on their homepage. I’d encourage you to check it out if you want to understand the JSON data structure found in the response a bit better. Here’s a screenshot showing the name that we’re accessing: Here, you can see that there’s a species object, which contains a property called name. (There’s also a separate name property as well, but I’ve found that the species.name property is more reliable to use). Note: You can see all of the properties accessible via this pokemon endpoint at the endpoint’s page in the official PokéAPI docs. Of course, in the code above, we’re accessing: console.log(poke.data.species.name) So where does the poke.data part come into play? poke is a variable that we declare, which holds the entirety of the response from PokeAPI. Let’s look at the API call: await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) I’ll cover the await part in a second; right now, let’s look at the part that says .then((poke) => ... and break that down. The code axios.get(`https://pokeapi.co/api/v2/pokemon/1`) calls the PokeAPI to get the resource stored at https://pokeapi.co/api/v2/pokemon/1. Once the call is finished, we need to do something with the response. The .then() function allows us to do this. Within it, we’re both defining and calling a function (using an arrow function) which stores the entire response in a variable called poke. It then uses console.log() to log the poke.data.species.name property’s value. Using .then() just keeps our code nice and concise. We could re-write it using an old-school function declaration and get the same result: async function getPokemon() { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/1`) log(poke) } function log (poke) { console.log(poke.data.species.name) } But this is more verbose, so using .then() is preferable. Next, let’s address the data property in poke.data.species.name. We don’t see that on the PokeAPI website’s example response, so where is it coming from? As it turns out, the response we get from PokeAPI contains a lot of information. We get a status code, headers, config information, and a lot of other information that we generally don’t need to worry about (but that’s good to have for debugging in case something goes wrong). The entire response is contained within an object, and inside that object there is another nested object called data. This data object contains all the information that you can see on the PokeAPI homepage’s sample response. More on objects: Objects javascript.info In the accordion block below, I’ve included the entire response that PokeAPI returns for this API call. Take a second to look through it and identify the data object. Full PokeAPI Response (Sample) This is the entire response returned by PokeAPI for this API call. Find the data object within it to see how we’re accessing the pokemon’s name (line 238). Note that, by default, console.log() won’t fully show the details of objects that are nested many layers deep. For that reason, most of the information in the data object is simply labeled [Object]. However, when you access specific properties in your code, you’ll get the actual values. For example, poke.data.species.name has a value of bulbasaur, which we were able to see in the console in the Replit embed above. { status: 200, statusText: 'OK', headers: AxiosHeaders { date: 'Fri, 09 Dec 2022 20:29:25 GMT', 'content-type': 'application/json; charset=utf-8', 'transfer-encoding': 'chunked', connection: 'close', 'access-control-allow-origin': '*', 'cache-control': 'public, max-age=86400, s-maxage=86400', etag: 'W/\"359f3-JlmmuiyGZkKyOFlSvLzln1IpB6Q\"', 'function-execution-id': 'tkmw3o8u9p36', 'strict-transport-security': 'max-age=31556926', 'x-cloud-trace-context': '3dba91851bd1a57c6ea5dade1ac7e883', 'x-country-code': 'US', 'x-orig-accept-language': 'en-US', 'x-powered-by': 'Express', 'x-served-by': 'cache-iad-kiad7000067-IAD', 'x-cache': 'HIT', 'x-cache-hits': '1', 'x-timer': 'S1669043889.601956,VS0,VE1', vary: 'Accept-Encoding,cookie,need-authorization, x-fh-requested-host, accept-encoding', 'alt-svc': 'h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400', 'cf-cache-status': 'HIT', age: '51296', 'server-timing': 'cf-q-config;dur=6.9999987317715e-06', 'report-to': '{\"endpoints\":[{\"url\":\"https:\\\\/\\\\/a.nel.cloudflare.com\\\\/report\\\\/v3?s=4KTK4BOb7zSytazr61FEYksT%2BVDQfvoEhzU6Ph%2FYbVr%2Bc9ZgsACueHvhFQy5%2BsijYeXyqKyD3Vo7sBe%2FieNvBWwCdvO%2B55koSkx9YXvyuZQXrpitHk2UCZt3rUoa\"}],\"group\":\"cf-nel\",\"max_age\":604800}', nel: '{\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}', server: 'cloudflare', 'cf-ray': '77707e289bca208d-IAD', [Symbol(defaults)]: null }, config: { transitional: { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, adapter: [Function: httpAdapter], transformRequest: [ [Function: transformRequest] ], transformResponse: [ [Function: transformResponse] ], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, maxBodyLength: -1, env: { FormData: [Function], Blob: null }, validateStatus: [Function: validateStatus], headers: AxiosHeaders { 'User-Agent': 'axios/1.1.3', 'Accept-Encoding': 'gzip, deflate, br', [Symbol(defaults)]: [Object] }, method: 'get', url: 'https://pokeapi.co/api/v2/pokemon/1', data: undefined }, request: <ref *1> ClientRequest { _events: [Object: null prototype] { abort: [Function (anonymous)], aborted: [Function (anonymous)], connect: [Function (anonymous)], error: [Function (anonymous)], socket: [Function (anonymous)], timeout: [Function (anonymous)], prefinish: [Function: requestOnPrefinish] }, _eventsCount: 7, _maxListeners: undefined, outputData: [], outputSize: 0, writable: true, destroyed: true, _last: true, chunkedEncoding: false, shouldKeepAlive: false, _defaultKeepAlive: true, useChunkedEncodingByDefault: false, sendDate: false, _removedConnection: false, _removedContLen: false, _removedTE: false, _contentLength: 0, _hasBody: true, _trailer: '', finished: true, _headerSent: true, socket: TLSSocket { _tlsOptions: [Object], _secureEstablished: true, _securePending: false, _newSessionPending: false, _controlReleased: true, secureConnecting: false, _SNICallback: null, servername: 'pokeapi.co', alpnProtocol: false, authorized: true, authorizationError: null, encrypted: true, _events: [Object: null prototype], _eventsCount: 9, connecting: false, _hadError: false, _parent: null, _host: 'pokeapi.co', _readableState: [ReadableState], _maxListeners: undefined, _writableState: [WritableState], allowHalfOpen: false, _sockname: null, _pendingData: null, _pendingEncoding: '', server: undefined, _server: null, ssl: null, _requestCert: true, _rejectUnauthorized: true, parser: null, _httpMessage: [Circular *1], [Symbol(res)]: null, [Symbol(verified)]: true, [Symbol(pendingSession)]: null, [Symbol(async_id_symbol)]: 3, [Symbol(kHandle)]: null, [Symbol(kSetNoDelay)]: false, [Symbol(lastWriteQueueSize)]: 0, [Symbol(timeout)]: null, [Symbol(kBuffer)]: null, [Symbol(kBufferCb)]: null, [Symbol(kBufferGen)]: null, [Symbol(kCapture)]: false, [Symbol(kBytesRead)]: 6334, [Symbol(kBytesWritten)]: 175, [Symbol(connect-options)]: [Object], [Symbol(RequestTimeout)]: undefined }, _header: 'GET /api/v2/pokemon/1 HTTP/1.1\\r\\n' + 'Accept: application/json, text/plain, */*\\r\\n' + 'User-Agent: axios/1.1.3\\r\\n' + 'Accept-Encoding: gzip, deflate, br\\r\\n' + 'Host: pokeapi.co\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n', _keepAliveTimeout: 0, _onPendingData: [Function: noopPendingOutput], agent: Agent { _events: [Object: null prototype], _eventsCount: 2, _maxListeners: undefined, defaultPort: 443, protocol: 'https:', options: [Object], requests: {}, sockets: {}, freeSockets: {}, keepAliveMsecs: 1000, keepAlive: false, maxSockets: Infinity, maxFreeSockets: 256, scheduling: 'lifo', maxTotalSockets: Infinity, totalSocketCount: 0, maxCachedSessions: 100, _sessionCache: [Object], [Symbol(kCapture)]: false }, socketPath: undefined, method: 'GET', maxHeaderSize: undefined, insecureHTTPParser: undefined, path: '/api/v2/pokemon/1', _ended: true, res: IncomingMessage { _readableState: [ReadableState], _events: [Object: null prototype], _eventsCount: 5, _maxListeners: undefined, socket: [TLSSocket], httpVersionMajor: 1, httpVersionMinor: 1, httpVersion: '1.1', complete: true, headers: [Object], rawHeaders: [Array], trailers: {}, rawTrailers: [], aborted: false, upgrade: false, url: '', method: null, statusCode: 200, statusMessage: 'OK', client: [TLSSocket], _consuming: true, _dumped: false, req: [Circular *1], responseUrl: 'https://pokeapi.co/api/v2/pokemon/1', redirects: [], [Symbol(kCapture)]: false, [Symbol(RequestTimeout)]: undefined }, aborted: false, timeoutCb: null, upgradeOrConnect: false, parser: null, maxHeadersCount: null, reusedSocket: false, host: 'pokeapi.co', protocol: 'https:', _redirectable: Writable { _writableState: [WritableState], _events: [Object: null prototype], _eventsCount: 3, _maxListeners: undefined, _options: [Object], _ended: true, _ending: true, _redirectCount: 0, _redirects: [], _requestBodyLength: 0, _requestBodyBuffers: [], _onNativeResponse: [Function (anonymous)], _currentRequest: [Circular *1], _currentUrl: 'https://pokeapi.co/api/v2/pokemon/1', [Symbol(kCapture)]: false }, [Symbol(kCapture)]: false, [Symbol(kNeedDrain)]: false, [Symbol(corked)]: 0, [Symbol(kOutHeaders)]: [Object: null prototype] { accept: [Array], 'user-agent': [Array], 'accept-encoding': [Array], host: [Array] } }, data: { abilities: [ [Object], [Object] ], base_experience: 64, forms: [ [Object] ], game_indices: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], height: 7, held_items: [], id: 1, is_default: true, location_area_encounters: 'https://pokeapi.co/api/v2/pokemon/1/encounters', moves: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], name: 'bulbasaur', order: 1, past_types: [], species: { name: 'bulbasaur', url: 'https://pokeapi.co/api/v2/pokemon-species/1/' }, sprites: { back_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/1.png', back_female: null, back_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/shiny/1.png', back_shiny_female: null, front_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png', front_female: null, front_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/1.png', front_shiny_female: null, other: [Object], versions: [Object] }, stats: [ [Object], [Object], [Object], [Object], [Object], [Object] ], types: [ [Object], [Object] ], weight: 69 } } You may have also noticed the async and await keywords shown in our sample script. These have to do with asynchronous JavaScript and Promises, two topics that are intermediate-level in complexity. I’ll explain them in the accordion block below and link you to some useful resources for learning them in more detail, but the gist is this: Axios is a “promise-based” library, and to use it correctly within our script, we need to use async and await. If we don’t, responses might come back from the PokeAPI out-of-order. Of course, there are other JavaScript tools for working with APIs that don’t force you to use Promises (like fetch), but I’m choosing to use Axios for this tutorial because it’s the default option used by Pipedream, which is an amazing automation platform that I’ll be using for upcoming Notion API tutorials. More Detail on Pipedream Pipedream is a code-light platform that I’ll be featuring in upcoming tutorials; it’s generally a much easier tool for working with the Notion API and creating automations compared to what we’re doing here. I’ve used it personally to mirror Notion databases, send YouTube stats to Notion, create a speech-to-text automation, and more. I’m not using it for this tutorial because I want you to be fully aware of what’s happening while you learn the Notion API, and because you may want to go off and build apps on your own tech stack! So this tutorial is sticking to more general purpose tools – but I did want to base it off of Axios so you’ll be fully prepped when you deal with it on Pipedream. More About Async/Await and Promises Axios is a “promise-based” library, which means that when we use the axios.get() method, we get a Promise. In JavaScript, a Promise is essentially an IOU. It’s almost as if JavaScript is handing you a piece of paper that says: “I promise to give you the full results of this API call if it is successful. And if it fails, I’ll give you details about the error. The actual response, be it the successfully-retrieved data from the API or an error message, comes later on once the Promise resolves. In general, this is quite useful because JavaScript is a single-threaded language, which means that it generally can only do one thing at a time. This can become a problem with API calls, because they can often take a (relatively) long time to execute. In a program where lots of things are happening, an API call can block additional code steps that would otherwise execute extremely fast. Promises allow that later code to execute before something like an API call finishes, since the Promise gets returned almost immediately. In complex applications, this means later code steps can do their thing, and then once the Promise resolves, you can take action on the actual response from the API. As I mentioned above, I’m choosing Axios for this project specifically because Pipedream uses it heavily and I’ll be doing lots of Pipedream/Notion API tutorials in the future. However, what we’re doing here doesn’t really need Promises or async/await. Our script is going to get all the information about all the Pokemon before doing anything else, so we would be fine to go with a totally synchronous option here if we wanted. Still, asynchronous JavaScript can be very useful in other cases. If you want to learn more about it, here are some resources. First, I highly recommend watching this talk on the Javascript event loop if you want to understand how JavaScript can be “asynchronous” despite being single-threaded: Next, I’d recommend watching my friend Daniel Shiffman’s series on Promises and async/await: JSInfo also has some great articles on these topics: Promises Async/await With all that preamble out of the way, let’s start coding! In the embedded Replit above, we made a single call to PokeAPI and logged bulbasaur’s name in the terminal. Let’s take that a step further and set the foundation for our script by adding the following code to index.js in our Glitch project (everything from here on out will go in index.js): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Note: From this point on, we’ll often be adding new code in between existing lines. Sometimes we’ll even change existing lines. I’m doing it this way so the learning curve in this tutorial remains gradual. I’ll make sure to highlight those lines in the code blocks that follow this one. Remember, you can always reference the full code (with or without comments) in the Steal My Code section above. In your terminal, type node index.js and then hit Enter to run your script. If you’ve set things up correctly so far, you should get a list of the first 10 Pokemon: This code is very similar to the code in the embedded Replit example above. One change is the addition of these lines: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] The first two are creating a notion variable and bringing in the Notion SDK that we imported earlier, so we can use it within our script. We’ll start using it in earnest below when we send our first page to Notion. We’re also creating an empty array with const pokeArray = []. As I mentioned in the tutorial overview, we’ll be adding an object for each Pokemon to this array. Then, we’ll loop through the array and create a new page in Notion for each of those Pokemon objects. Another big difference is that we’ve added a for loop to the function; now we’re calling the PokeAPI from inside it. Loops: while and for javascript.info This means that we’re making a call to PokeAPI every time the loop executes. Additionally, we’ve tweaked our axios.get() function call slightly. It now reads: axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) We’ve wrapped our PokeAPI URL in template literals (the backticks ``), which allows us to use variables within it. Template literals (Template strings) – JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org We can use ${} to reference a variable within our string; in this case, we’re referencing i, which increases by 1 each time the loop runs. In effect, each execution of the loop calls the next Pokemon from PokeAPI: https://pokeapi.co/api/v2/pokemon/1 https://pokeapi.co/api/v2/pokemon/2 https://pokeapi.co/api/v2/pokemon/3 …and so on. The start and end variables define how many times the loop will run. Currently, we’ve set them so that the loop runs 10 times, but hopefully you can see how tweaking them would let us get all 905 Pokemon! Finally, I’ll point out the addition of the .catch() block of code: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) If our API throws an error for some reason, the catch block will be activated. Right now, we’re just logging the error in the console, but you could add more sophisticated error-handling code if you wanted. Learn more here: Error handling, “try…catch” javascript.info Code Checkpoint At this point, your code should look exactly like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Format the Pokémon Data The next thing we need to do is construct an object that will hold the information about each Pokemon that we want to send to Notion. That information includes: Name Number Type(s) Category – e.g. “Flame Pokemon” or “Seed Pokemon” Generation Height Weight HP Attack Defense Special Attack Special Defense Speed Sprite Official Artwork Flavor text Bulbapedia URL We could declare individual variables for each of these, but a better method is to construct an object and store the values inside it. In JavaScript, an object is a collection of key:value pairs. Object keys always have defined names, and the key:value pairs do not have a specific order (unlike arrays). Objects are heavily used in JavaScript, so check out this primer if you want to learn more about them: Objects javascript.info We’re going to create an object for each Pokemon that will store all of the data we want to send to Notion. For now, we won’t add all of the information. Instead we’ll stick with a few basics – name, number, height/weight, and basic stats. This will keep things simple; we’ll add the other pieces later on. Remove the old console.log() line, and add the highlighted code within your .then() block: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) In the pokeData object declaration, we are creating several keys, such as name, number, height, etc. The value that corresponds to each key is dynamically set by accessing a specific value from the poke object, which contains the entire response from PokéAPI. Later, we’ll access the values of this object in order to send information to Notion. You can see that we’re already doing it once here: console.log(`Fetched ${pokeData.name}.`). After declaring the pokeData object and filling it up with values, we also add the object onto the end of our pokeArray array with pokeArray.push(pokeData). You may remember that we declared that array near the top of our code: const pokeArray = []. The [] symbols define the variable as being an array, but when it was declared, it was empty. In other words, it was an array with no elements inside it. Using the push method, we “push” our pokeData object onto the end of the array. You can learn more about how this method works here: Array.prototype.push() – JavaScript | MDN The push() method adds one or more elements to the end of an array and returns the new length of the array. developer.mozilla.org Before we move on, you should also change your const end = 10 line to const end = 1 for now: async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { This will cause the script to fetch only the first Pokémon, Bulbasaur. Later, we’ll change it to a higher number so we can fetch hundreds of Pokémon – but for now, it’ll keep things simpler if we fetch just one. Once again, run node index.js in your terminal. You should see a result like this: The console.table() method is another useful tool for seeing information in the terminal. It nicely formats data structures like objects, and by using it we can see all of the properties that we created within the pokeData object. I’ve removed the console.table() line from my final code; you can choose whether or not to do the same. Leaving it in won’t change anything, as it’s just a logging tool. Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) }) .catch((error) => { console.log(error) }) } } getPokemon() Create Your First Page with the Notion API Now that we have a tidy little object full of Pokémon data, let’s send it to Notion and create the first page in our Pokédex! To do that, we’ll declare a second function called createNotionPage() at the bottom of our code, beneath the getPokemon() function call. Additionally, we’ll call the createNotionPage() within the getPokemon() function’s declaration, at the very end before its closing curly brace. Go ahead and add the highlighted lines to your code: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } We’ll go through what this code does in a second. For now, we’re going to run the code and see what happens. First, you’ll need to go to your Pokédex database’s ••• menu, go to Group, and set the No Generation option to visible. We currently aren’t passing generation information, so you’ll need to do this in order to see the page you’re about to send to Notion. Next, go ahead and run node index.js in the terminal once more. If your code and .env variables are set up correctly, you should see something similar to this in your terminal: [email protected]:~ 23:48 $ node index.js Fetched bulbasaur. ┌─────────────────┬─────────────┐ │ (index) │ Values │ ├─────────────────┼─────────────┤ │ name │ 'bulbasaur' │ │ number │ 1 │ │ height │ 7 │ │ weight │ 69 │ │ hp │ 45 │ │ attack │ 49 │ │ defense │ 49 │ │ special-attack │ 65 │ │ special-defense │ 65 │ │ speed │ 45 │ └─────────────────┴─────────────┘ Sending bulbasaur to Notion { object: 'page', id: '64499d85-9748-4ddd-a08b-38a8c6dd6a2c', created_time: '2023-02-05T23:49:00.000Z', last_edited_time: '2023-02-05T23:49:00.000Z', created_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, last_edited_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, cover: null, icon: null, parent: { type: 'database_id', database_id: 'c9cdd00e-d731-4f94-97f4-ab23e9fa0bdd' }, archived: false, properties: { Height: { id: 'C%3FgF', type: 'number', number: 7 }, 'Weight (kg)': { id: 'Dn_%5D', type: 'formula', formula: [Object] }, Attack: { id: 'MRaQ', type: 'number', number: 49 }, 'HP Label': { id: 'MdMo', type: 'formula', formula: [Object] }, Weight: { id: 'N%3BN%7B', type: 'number', number: 69 }, 'Stats Meta': { id: 'NZS%7B', type: 'formula', formula: [Object] }, HP: { id: 'Rce%7D', type: 'number', number: 45 }, 'Sp. Attack': { id: 'U%7Bi%40', type: 'number', number: 65 }, 'Defense Label': { id: 'VRMi', type: 'formula', formula: [Object] }, Sprite: { id: '%5BlYm', type: 'files', files: [] }, No: { id: '%5DY%40D', type: 'number', number: 1 }, 'Ht/Wgt Meta': { id: 'cjoi', type: 'formula', formula: [Object] }, Speed: { id: 'dCkj', type: 'number', number: 45 }, 'Height (m)': { id: 'e%5DNz', type: 'formula', formula: [Object] }, Defense: { id: 'iLgx', type: 'number', number: 49 }, 'Height (ft)': { id: 'i%5DgP', type: 'formula', formula: [Object] }, Meta: { id: 'oBLz', type: 'formula', formula: [Object] }, 'No Label': { id: 'oLD%3B', type: 'formula', formula: [Object] }, 'Sp. Defense': { id: 'pmEd', type: 'number', number: 65 }, 'Weight (lbs)': { id: 'qT%5Er', type: 'formula', formula: [Object] }, Generation: { id: 'q%5CeI', type: 'select', select: null }, Type: { id: 'smaD', type: 'multi_select', multi_select: [] }, Category: { id: 'tESh', type: 'rich_text', rich_text: [] }, 'Attack Label': { id: 'xLfc', type: 'formula', formula: [Object] }, Name: { id: 'title', type: 'title', title: [Array] } }, url: 'https://www.notion.so/bulbasaur-64499d8597484ddda08b38a8c6dd6a2c' } Operation complete. You should also see a new Bulbasaur entry in your Pokédex: Congratulations! You’ve just created your first page in Notion using the Notion API. If it didn’t work, make sure you added the line calling createNotionPage() right before the closing } in your getPokemon() function! Now let’s walk through these code additions and see what’s actually happening. The code we added here does five distinct things: Declares the createNotionPage() function. Creates a for...of loop, which allows us to iterate over the elements of pokeArray, performing the same set of actions (defined within the loop) on each one. Defines a data object, which is formatted in the way the Notion API wants, and which is filled with the values of the current object within pokeArray that the loop is working on. Sends a POST request to the https://api.notion.com/v1/pages endpoint of the Notion API in order to create a new page, using the information from the data object Finally, calls the createNotionPage() function from within the getPokemon() function, after everything else in that latter function has finished executing. At this point, the basic structure of the entire script is in place. You can jump back up to the flow chart (or view it on Whimsical in a new tab) to see that entire structure, but here’s a super-quick refresher. When you run node index.js in the terminal, the following process kicks into high gear: Axios and the Notion API client are imported, the notion variable is created, and the pokeArray array is created (initially empty). getPokemon() is called. Within getPokemon(), a loop executes. For each loop iteration, we make a call to PokéAPI for a Pokémon, then place the data we want from the response into an object called pokeData. We then push that pokeData object onto the end of pokeArray. After the loop has finished running as many times as is defined, we call createNotionPage(). Inside createNotionPage(), we have a loop that will execute for each object within pokeArray. Each time, it will take the data from the current object within pokeArray being worked on, place it in the data object, then send that object off to Notion within a request to create a new page. In other words, we go through one loop to called PokéAPI a bunch of times and load up our pokeArray with lots of objects (one for each Pokémon), then we go through another loop a bunch of times to send those objects to our Notion Pokédex. Now that you understand the gist of what’s happening, let’s dig into the actual call being made to the Notion API. First, I’ll briefly cover what’s happening in our for...of loop: for (let pokemon of pokeArray) This is a looping construct that iterates over every element in pokeArray. As you’ll recall, each element in that array is an object, defined by the pokeData object definition, which holds information about each Pokémon. Each time the loop executes, the current element of pokeArray is temporarily stored in the pokemon variable defined in the loop declaration. This means that we can access the Pokémon’s name like so: pokemon.name Earlier in the script, we used pokeData.name to do the same thing. But since we define the variable name as pokemon in the loop declaration, we now use pokemon instead of pokeData. More detail on for…of loops In the code above, you can see that we’re using a for...of loop to iterate over our array: for (let pokemon of pokeArray) { } This is a type of for loop that can iterate over the values of an array or an object (for... in loops can iterate over the keys). You can see the differences between for...of and for...in here: For-In vs For-Of | Kevin Chisholm – Blog blog.kevinchisholm.com In most cases, you want to access the actual values of an object or array, so a for...of loop is cleaner. Note that you could also write a normal for loop, using the array’s length to set the end parameter: for (let i = 0; i < pokeArray.length; i++) { } Since we’re working on an array, these approaches are functionally identical. Next, let’s look at the data object declaration. const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } data is an object that is structured exactly as the Notion API expects. Of course, you may now be wondering… how do I know how to structure the object? That’s where the Notion API documentation comes in – and you’re going to want to get very familiar with it. In this case, I looked at the reference for creating new pages: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com On this page, you can get all the information you need to properly structure your request to the API. Let’s go over a few important parts of this page: First, at the top of the page you’ll see the endpoint URL and the method required for sending this type of request. For creating a page, you send a POST request to https://api.notion.com/v1/pages – or you use a method that does the same for you (e.g. using notion.pages.create() as we are in our script). Second, you’ll see the body parameters that can be sent with the request. You’ll also see the ones that are required – in this case, the parent (which is either a database or an existing page) and the properties. Third, you’ll see the example code area. This shows a sample request, which you can use as a reference for modeling your own request. Additional Example Options Note that you can use the dropdown menus to see other requests. The default example uses the official Notion SDK for JavaScript, which we’re using in this project as well. It provides lots of handy methods for making API requests without writing as much code. However, you can see several other examples. If you change the dropdown from Notion SDK to Axios, for example, you’ll see this code: import axios from 'axios'; const options = { method: 'POST', url: 'https://api.notion.com/v1/pages', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json' } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); My only issue with this example code is that it actually doesn’t give you all of the information you need to make a request using Axios. Perhaps they’ll fix this in the future (you may see different code if you’re reading this well after I publish it), but for now, it’s incomplete. Here’s the full code you’d need to use to create a page using Axios: const axios = require('axios') const options = { method: 'POST', url: 'https://api.notion.com/v1/pages/', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json', Authorization: `Bearer ${process.env.NOTION_KEY}` }, data: { parent: { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, properties: { \"Name\": { \"title\": [ { \"text\": { \"content\": \"Test Page\" } } ] } } } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); The code is quite similar, but you can see that I’ve included two new pieces of information: An Authorization property in the headers object, containing my integration’s secret key A data object that contains both the parent and the properties. Both of these are required, yet they aren’t shown in the Axios example. This is a harsh truth I’ve learned as I’ve gone through my journey of learning APIs; you’re often expected to know a lot of fundamentals, and API documentation often doesn’t hold your hand. This is likely because developers are trying to write mountains of documentation very quickly, and they’re also experienced enough to know the missing pieces by heart. Unfortunately, us noobs are often left scratching our heads as a result! Fourth, you can see examples of responses that the API will send back. Here on the Create a Page doc, there are four possible responses: 200 – a successful response, indicating that the page has been created. 400 – invalid request (can mean several things) 404 – resource does not exist (in this case, the parent) 429 – your application has been rate limited You can see a full list of the error responses that the Notion API may return here: Errors Responses from the API use HTTP response codes are used to indicate general classes of success and error. Error responses contain more detail about the error in the response body, in the “code” and “message” properties. developers.notion.com Using the information on this page – especially the example code – I was able to properly construct the data object. There’s one other page that came in very handy for constructing this request, and that’s the Property Values reference: Property values A property value defines the identifier, type, and value of a page property in a page object. It’s used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with … developers.notion.com Note: This page is currently not shown in the sidebar of the API reference. It’s quite hard to find, and it’s the only page that shows you explicitly how to set property values when creating or updating pages. There is also a Page Property Values page, which is listed in the sidebar, and which has a very similar title – but only shows you the responses that you get when you retrieve property values. Notion is in the middle of merging these two pages, but as of this writing, that process hasn’t been completed yet. This page will show you how to properly construct an object in order to set any kind of property value (that is supported by the API). For example, here’s how you’d set a value in the number-type property called No: \"No\": { \"number\": 42 } Important Note: That first key value (in this case, “No”), must match the name of the property in your database. Using the property references on that page, you’ll be able to figure out how to structure your request and add values to all of the properties in your target database (if indeed you’re creating a page in a database). Finally, we have this small block of code that actually sends the request to Notion: console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) Here, we’re simply using the notion.pages.create() method, passing our data object as the argument. Note that we could have defined the object directly between those parentheses, but I find it cleaner to define it first and then simply pass the variable as the argument. The console.log() lines simply log information in the terminal. Before we move one, I’d like to cover one more quirk from our data object definition: \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, Note how the first line accesses the defense property: pokemon.defense – this method of accessing object properties is called dot notation. It can be used when the property name contains only letter, numbers, or underscores. When a property name contains other characters – such as spaces or dashes – then you must use bracket notation to access it. The line accessing special-attack shows how: pokemon['special-attack']. Learn more here: Property accessors – JavaScript | MDN Property accessors provide access to an object’s properties by using the dot notation or the bracket notation. developer.mozilla.org Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Create Multiple Pages at Once Now that we have the basic structure of our script in place, it’s time to kick things up a notch and fetch multiple Pokémon at once. Fortunately, we already have both of our loops in place! So all we need to do in this step is: Tweak the end variable so that the initial loop runs more than once, and fetches more than one Pokémon Add a “wait” function to prevent our script from getting rate-limited Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Now let’s test this out. First, delete your original Bulbasaur entry from your Pokédex, since it will be recreated. Next, run node index.js in the terminal once more. If everything goes smoothly, you should see a lot of log information in your terminal. Additionally, you should now have ten entries in your Pokédex: Let’s go over what we’ve added. The first change here is pretty simple. We’re just changing const end = 1 to const end = 10, which will cause our initial loop to run ten times. This means that we’ll make ten called to PokéAPI and add ten objects to pokeArray. The other change is the addition of the following code beneath the getPokemon() call: const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; This is a simple function that takes a single argument (a number) and will cause the script to wait that many milliseconds before continuing whenever we call it. You can see that we’re calling it right before sending each page to Notion: await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) JavaScript doesn’t have a built-in sleep() function as some other languages do, but we can use the above code to approximate one. It uses a combination of setTimeout() (a built-in Web API method), a Promise, and async/await to essentially pause the script for the number of milliseconds we specify. More Detail on the sleep() function You don’t really need to understand the nuts and bolts of the sleep() function to use it; you can basically just copy and paste. However, if you’re curious about how and why it works, here’s a brief overview. The built-in setTimeout() function will set a timer and execute a function after the timer is up. Here’s the reference for it: setTimeout() – Web APIs | MDN The global setTimeout() method sets a timer which executes a function or specified piece of code once the timer expires. developer.mozilla.org However, setTimeout() will not delay the execution of the next line of code. We can get around this issue by creating a Promise within our sleep() function, which is only fulfilled after the setTimeout() call inside it has finished running. Then, by calling the function with the await keyword (e.g. await sleep(300)), we effectively cause our script to pause for 300 milliseconds before moving on. The MDN documentation on Promises explains why this works: Promise – JavaScript | MDN The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. developer.mozilla.org You can also get more detail on this sleep() function itself here: JavaScript Sleep: How to Pause Code Execution JavaScript does not have an inbuilt sleep function but thanks to the introduction of promises and async/await, we can implement such sleep in JavaScript. appdividend.com Why are we doing this, though? The reason is that requests to the Notion API are rate-limited, meaning you can’t send a huge number of requests super-quickly to it. Notion is not unique here; almost all APIs have some kind of rate-limiting implemented. The Notion API currently allows an average of three requests per second: The rate limit for incoming requests per integration is an average of three requests per second. Some bursts beyond the average rate are allowed. Read more here: Request limits To ensure a consistent developer experience for all API users, the Notion API is rate limited and basic size limits apply to request parameters. Rate limits Rate-limited requests will return a “rate_limited” error code (HTTP response status 429). The rate limit for incoming requests per integration … developers.notion.com This doc also mentions that a rate-limited request (e.g. one that fails due to hitting the rate limit) will return a 429 error. If you get this, you’re supposed to set up your code to try the request again after a number of milliseconds that is specified in the Retry-After header value in the 429 response. However, a quick-and-dirty way to make sure we never even see a 429 response is to make sure our script never sends requests too quickly. Hence our await sleep(300) line before the actual call to the Notion API – we are waiting 300ms before sending each request, keeping our average very close to that three-requests-per-second limit. There are certainly more sophisticated ways you could handle Notion’s rate limits, which would likely make your application run faster. I’d encourage you to explore them as you continue to learn and build! Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Refine Your Pokémon Data At this point, your script can send basic information about multiple Pokémon to Notion all at once. Now we’ll start the process of adding additional information to each Pokédex entry, as well as refining some of the information we already have. Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } Remember, you can always jump back up to the Steal My Code section to see the final version of the code. This step adds a lot of code, and makes some significant changes to the pokeData object declaration. If you’re starting to feel overwhelmed, now might be a good time to get up and take a short break! I made a video about how breaks are crucial to learning and productivity a while ago, and it even has a Pokémon in the thumbnail… so you know I have to include it here. Once you’re feeling fresh, let’s take some time to go through each of these new additions to our code. At a glance, here’s what we’re accomplishing in this step: Get and store each Pokémon’s type(s) Reformat each Pokémon’s name to look nicer (e.g. changing “mr-mime” to “Mr. Mime”) Construct a valid Bulbapedia URL for each Pokémon, which we’ll later embed in that Pokémon’s page content Get and store the sprite and/or official artwork for each Pokémon Each of these steps has a specific code block. For now, we’re simply getting and formatting this information; we’ll send it to Notion in a later step. First, we get the Pokémon’s type – or multiple types! const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } This presents a bit of a challenge. Pokémon can have up to two types, and PokéAPI returns each Pokémon’s type(s) as an array filled with objects. See for yourself at the official docs for the pokemon endpoint. This means we have to: Dig into each object within the types array and get the name of each type Place to types into a new array of objects, structured in the way that the Notion API requires To do this, we create a typesRaw variable, setting its value to the entire array of types from the API response: poke.data.types. We also create a new empty array called typesArray. Once again, we’re using a for...of loop to iterate over typesRaw. Inside, we declare an object called typeObj, setting its name property to type.type.name. The first type in that object is simply the type variable we defined in the for...of loop declaration, which represents the current object being iterated over. The second is the actual type property, the value of which is an object containing the name property (in addition to a url property that we aren’t using). Next, we format the Pokémon’s name so it looks nicer. This process also has a secondary benefit; it will allow us to construct valid Bulbapedia URLs later. const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") We’re doing a lot here code-wise, but the aims are simple: Capitalize each Pokémon’s name Handle edge cases where we need to add periods, accent characters (é), dashes, colons, or gender symbols (♂, ♀) How this code works This block of code may initially look confusing, as it is quite dense. The reason for this is that I’ve used method chaining to condense it. In JavaScript, you can call methods one after another with periods. This results in code that takes up less space, and for experienced programmers it can often be more readable. However, for a beginner, it may be intimidating. So the best way to explain this code will be to rewrite it as distinct steps on their own lines. Run the code here, then view the source: Here, I have both the distinct steps as well as the method-chained approach in the code. As you can see, both methods give the same exact result. However, using method-chaining takes up far fewer lines. Learn more about method chaining: Here’s what the code actually does, in order: Splits the name into an array of single-word values (will usually create a single-element array, but this is needed for Pokémon like Mr. Mime and Type: Null) Uses map() to iterate over the returned array, executing these steps on each element: Use toUpperCase to capitalize the first letter of the name Concatenate that capitalized letter with the rest of the name (using substring() to get everything except the first letter) Join the elements of that array back together as a single string, separating each with a space character (\" \") Use replace() to handle edge-case replacements, such as replacing “Mr M” with “Mr. M” As for the actual methods being implemented here, I’ll link to the docs for each one: String.prototype.split() Array.prototype.map() String.prototype.toUpperCase() (using bracket notation to access the first character in the string) String.prototype.substring() Array.prototype.join() String.prototype.replace() Third, we construct the Bulbapedia URL: const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` This step is fairly straightforward. We create a variable called bulbURL and set its value by creating a template literal (using the backtick ` characters), which allows us to reference variables within the string. Template literals (Template strings) – JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org Bulbapedia has an extremely rigid structure for its URLs. It’s always the same, except for the Pokémon name: https://bulbapedia.bulbagarden.net/wiki/Charmander_(Pokémon) https://bulbapedia.bulbagarden.net/wiki/Squirtle_(Pokémon) https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pokémon) Thus, our URL structure just needed to use processedName to set the correct URL. The only fancy thing we’re doing here is using replace() to replace any space characters with underscores: `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` More on replace(): String.prototype.replace() – JavaScript | MDN The replace() method returns a new string with one, some, or all matches of a pattern replaced by a replacement. The pattern can be a string or a RegExp, and the replacement can be a string or a function called for each match. If pattern is a string, only the first occurrence will be replaced. The original string is left unchanged. developer.mozilla.org Fourth, we define a variable called sprite that holds either the Pokémon’s sprite or its official artwork: const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default The reason we need to do either/or here is because Pokémon from Pokémon Legends: Arceus and later games don’t have sprites (their models are 3D). As a result, PokéAPI doesn’t have a sprite object for them, meaning we need to grab their official artwork instead. Finally, we add our new key:value pairs to the pokeData object definition: sprite, bulbURL, and typesArray. Additionally, we change the value of the name property to be our new processedName variable. const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } If you’d like to test your code at this point, I’d recommend commenting out the createNotionPage() function call. Adding // to the beginning of that line will turn it into a comment, preventing it from executing. // createNotionPage() Doing this will allow you to see the log information for your code changes without sending more pages to Notion (which we’re not yet ready to do). Run node index.js in the terminal once more, and you should see log information like this: Here, our console.table() reports are now showing our nicely-formatted Pokémon names. We can also see the URLs for the sprite, official artwork, and Bulbapedia page. Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is commented-out at this point; later, we’ll remove the comment symbols to enable it again. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Get Flavor & Generation Data for Each Pokémon In the last step, we added quite a lot of new information to our pokeData object definition. However, we’re still missing a few vital pieces – including each Pokémon’s: Generation (e.g. Gen I, II, III…) Category/Genera (e.g. “Flame Pokémon” or “Dancing Pokémon”) Flavor Text The reason we haven’t gotten these pieces of information up until now is because they’re accessible via a completely different endpoint of PokéAPI: the pokemon-species endpoint. All of our previous information came from the pokemon endpoint. In fact, PokéAPI has several different endpoints under the “Pokémon” umbrella: My guess as to why they’ve designed their API this way is to simply cut down on the amount of information that is returned from a single request. In any case, we need to query the pokemon-species endpoint in order to get these piece of information. To do so, add the following lines to your code, just above your createNotionPage() function call within the getPokemon() function: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } //createNotionPage(); } This code sets up a for...of loop, just as we did when we created our createNotionPage() function (click here to jump back to that section if you need a refresher). Within that loop, we’re using Axios to call the pokemon-species endpoint. Note how we use the pokemon.number property to define the specific URL: await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) Since we’re iterating over each element of pokeArray, we’re just taking the number obtained from our previous call to the normal pokemon endpoint. Once we get the response, we do three things: Declare the flavorText, category, and generation variables, setting their values by accessing the relevant information from the API response and formatting it. Add new properties to our pokeData object, setting their values using the variables we just declared. Log the event in the console. Note that we could easily combine steps #1 and #2 here; we don’t need the interim variables (e.g. flavorText). I’ve only split these steps up to make things clearer. There’s actually a lot going on here, and the steps we have to take to access and format the data in step #1 here are quite technical. Therefore, I’ll put each of them in a toggle that you can read through if you want. Flavor Text and Category To fetch and format the flavor text, we use this line of code: const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") We do nearly the exact same thing to get the category, just without the replace() call at the end: const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus Here I’ll break down the flavorText variable assignment, but it applies to category as well. Once again we’re method-chaining here, using these methods: Array.prototype.find() String.prototype.replace() Here’s the problem we need to solve with flavor text: the pokemon-species endpoint’s response contains an array called flavor_text_entries – which may contain many flavor text objects in different languages. Additionally, the english flavor text is not always at the same index in the array – so we can’t just target a particular index. Instead, we need to search through each object, find the one where the value of flavor_text_entries[X].language.name equals \"en\", and then get the flavor_text property from it. Chespin’s record stores the English flavor text at array element #6. To do this, we use the find() method, which will search through an array and return the first element that satisfies the condition we specify in a testing function. To make this clearer, let’s look at a simple embed that just uses find() to return the flavor_text entry from the array element that contains the English text: In our test function, we’re doing something called nested object destructuring. This will make sense more readily if you understand destructuring in general: Destructuring assignment javascript.info Once you understand destructuring, you can dig into nested object destructuring: Nested Destructuring Learn how to use nested destructuring on nested objects with JavaScript. davidwalsh.name The gist, though, is that instead of setting the entire object we’re currently iterating over as the argument in our test function, we’re “digging into” that object and setting only the nested name property as the argument instead. From there, find() iterates over each element in the flavor_text_entries array until it finds the one where that nested name property’s value is \"en\". Since the matched array element is the return value, we can simply access its flavor_text property (end of this line): const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text Unfortunately, this flavor text often contains lots of newline characters that make the text look very wonky. To deal with that, we finish our method chain with a replace() call: replace(/\\n|\\f|\\r/g, \" \") Here, I’m using a regular expression to replace every instance of a newline character (typically these will be \\n, but they can also be \\f or \\r) with a space character. Here’s how that works: The / characters define the beginning and end of the regular expression to be matched \\n, \\f, and \\r are all the possible “newline” characters that will cause a line break in a string The | character means “or” Finally, the g flag means “match every instance of this expression, not just the first one Regular expressions are a whole subject unto themselves, but if you want to learn them, start here: RegexOne – Learn Regular Expressions – Lesson 1: An Introduction, and the ABCs RegexOne provides a set of interactive lessons and exercises to help you learn regular expressions regexone.com You can find more regular expression resources at the Regex guide in my Notion Formula Reference: Regular Expressions in Notion Formulas – Notion Formula Reference Learn how to use regular expressions in Notion’s test(), replace(), and replaceAll() functions. learn.thomasjfrank.com Generation Getting and formatting the generation is easier than getting the flavor text and category. We use this code: const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() Here we’re fetching the generation, which PokéAPI formats like so: generation-vi. We want a simple Roman numeral, like VI. We also want it capitalized. To do that, we go through this process: split() to split the string into array elements, using the - character as our separator pop() to remove the last element of the returned array and (more importantly) return it toUpperCase() to fully capitalize that returned element Once we have those variables set, we simply create new properties in the current pokemon object (defined earlier by the pokeData definition, then represented as pokemon via the for...of loop definition): pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation As you can see, all we have to do is create the new property with either dot notation or bracket notation, depending on the characters in its name. Read more on this here: How to Add Property to an object in JavaScript? – Scaler Topics In this article by Scaler Topics, we will look at different ways of adding a property to an object in JavaScript using different methods and examples. www.scaler.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Add New Data to the Notion API Call We’re at the last code step! All we need to do now is modify the data object definition within our createNotionPage() function, adding the new pieces of information that we’ve fetched (generation, types, flavor text, art, etc.). Add the highlighted code to your data object definition: async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } In addition to the additions and changes highlighted above, be sure to add commas after the closing } symbols where needed. For example: \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, When defining JavaScript objects or writing JSON, sequential properties must be separated by commas as shown above. If you run into errors when trying to run your code, be sure to check for missing commas. I’ve missed plenty of them in my code before. In this step, we add the following information: Page Icon (Using the sprite) Page Cover (Using the official artwork) Properties: Category (rich text) Type (multi-select) Generation (select) Sprite (file) Child blocks (i.e. page content) Flavor text (quote block) A blank space (text block – for formatting/aesthetics) “View This Pokémon’s Entry on Bulbapedia:” (text block) Bulbapedia URL (bookmark block) We’ve already covered objects quite heavily in this guide, so I won’t spend too much time explaining each addition here. Instead, I’ll point you to the relevant pages in the Notion API reference that explain them. To learn how to set the page icon and page cover, refer to the example code shown on the Create a Page reference: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com Note that images cannot be uploaded to Notion via the API at this time, so you must link to an image hosted externally (as we’re doing here). For the properties, you can currently see how to format your objects when creating and updating pages here: Property values A property value defines the identifier, type, and value of a page property in a page object. It’s used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with … developers.notion.com In the near future, all of this information will be consolidated into the Page Property Values page, which is linked in the reference’s sidebar. To add child blocks/page content, refer to the example code in the Create a Page reference linked above. You can also use the Append Block Children reference to learn how to add new blocks to existing pages and blocks (remember, pages are blocks themselves!): Append block children Creates and appends new children blocks to the parent block_id specified. Returns a paginated list of newly created first level children block objects. Errors Returns a 404 HTTP response if the block specified by id doesn’t exist, or if the integration doesn’t have access to the block. Returns a 400… developers.notion.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. In the next step, we’re remove the // symbols and re-enable that function call. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran♀\") .replace(/Nidoran M/,\"Nidoran♂\") .replace(/Flabebe/,\"Flabébé\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pokémon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pokémon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Run Your Final Test It’s time to actually run your script! Before you do, go into your code and “un-comment” the createNotionPage() function call at the end of your getPokemon() function: console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() This will ensure the createNotionPage() function is actually called, and that your pages get created in your Notion database. Now it’s time for the moment of truth. Run node index.js in your terminal one more time; if all goes well, you should see these full-featured entries flooding into your Pokédex: Since we also set up the Generation information, you’ll also get them neatly grouped under the I group! If you click into each page, you should also see the flavor text and Bulbapedia link: If everything looks good, then you can modify your start and end variables in order to fetch more Pokémon. You already have #1-#10, so now you can set: start = 11 end = 905 Adding Pokémon #906-#1008 As of this writing, PokéAPI has not yet added flavor text, category, or generation information for Pokémon #906-#1,008 (those releases with Scarlet and Violet). Therefore, this script will work flawlessly for all Pokémon up to #905. If you’d like to add the newer Pokémon, you can see “default” values in the data object definition, as shown below. I found that I needed to do this for Category, Flavor Text, and Generation. \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category || \"No Category Information\" } } ] } There are more elegant ways to handle this, but I’ll leave them as an exercise for you to tackle if you’re so inclined! Once you’re modified those variables and ran the script again, you’ll be the proud owner of a full Pokédex in your Notion workspace. Conclusion If you’ve followed this tutorial, you hopefully now have a strong grasp on how to work with the Notion API using JavaScript. What you’ll quickly learn if you start working with other APIs is… you also know how to work with them as well! As I’ve learned, working with one API greatly prepares you for working with almost any other API. From here, you can use your newly-developed programming and API skills to do nearly anything you want. One resource I’ll recommend now is Pipedream, which is a platform that lets you connect APIs and write actual code (unlike no-code tools, such as Make.com). I love Pipedream because it handles all of the server setup and API authentication for you, letting you just worry about your code. They also have an incredibly generous free tier; I can’t imagine ever having to pay for Pipedream. As a result, you’ll see Pipedream-focused tutorials on this site in the future. This tutorial took months to produce; if you enjoyed it, you can support my work by grabbing one of my Notion templates (there are both free and paid options here): The Best Free Notion Templates for Tasks, Projects, Notes, and More If you want to improve your Notion workspace, these advanced, battle-tested templates will help you do it. Made by YouTuber Thomas Frank. thomasjfrank.com You can also join my Notion Tips newsletter below for free; once you’re on it, I’ll send you tons of Notion cheat sheets and goodies. You’ll also be the first to know when I publish new tutorials and templates.","metadata":{"source":"https://thomasjfrank.com/notion-api-crash-course","title":"The Complete Notion API Crash Course for Beginners","date":"2023-02-10T20:53:27+00:00","contentLength":24879}}]