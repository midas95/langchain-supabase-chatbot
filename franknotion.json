[{"pageContent":"This is a complete quick reference or ‚Äúcheat sheet‚Äù for Notion formulas. On this page you‚Äôll find one or more example formulas for every constant, operator, and function available in the Notion formula editor. This cheat sheet is meant to be a quick, easy-to-use bookmark. It is a companion to my complete Notion Formula Reference. There, you‚Äôll find comprehensive technical documentation on Notion formulas, including: Full explanations for every constant, operator, and function Detailed tutorials for creating formula properties and working in the formula editor A full breakdown of Notion formula syntax Advanced guides on Notion regular expressions, formula errors, data type conversion, and more You may also want to check out my Formula Examples Database in Notion itself; there, you‚Äôll find more than 80 example databases demonstrating how to use every formula component listed here. Notion Formula Terms Here are some of the most common terms you‚Äôll run across when working with Notion formulas. Each link here will take you to a full page in the Formula Reference where you can learn more. Property ‚Äì other properties that exist in your Notion database. Constant ‚Äì mathematical constants e and œÄ, plus the Boolean values true and false. Operator ‚Äì symbols that perform operations on 1-3 operands. Includes mathematical operators (such as add), Boolean operators (such as not), and the ternary operator (if). Function ‚Äì pre-defined formulas that you can use to accomplish complex things quickly. Examples include concat (combines strings) and dateAdd (adds x units of time to a date). Arguments are the accepted pieces of data used within functions: // function_name(argument_1, argument_2) divide(10,2) // Output: 5 // Note that spaces between arguments are optional, but // commas are required. concat(\"My\", \" \", \"Chemical\", \" \",\"Romance\") // Output: My Chemical Romance Notion formulas support four distinct data types: String ‚Äì text content Number ‚Äì numeric characters, on which mathematical operations can be performed Boolean/Checkbox ‚Äì true/false values Date ‚Äì date objects Good to know: A Notion formula can only return data of a single type. When working with multiple data types, make sure to use type conversion to convert everything to a single type in order to avoid errors. Constants e The mathematical constant e is known as Euler‚Äôs Number, and approximately equals 2.718281828459045. Full reference: e e // Output: 2.718281828459 500 * e ^ (.3 * 10) // Output: 10042.768461593832 pi The mathematical constant pi (œÄ) equals (roughly) 3.1415926559. Full reference: pi pi // Output: 3.14159265359 pi * 10^2 // Output: 314.159265358979 true The true constant represents the Boolean output true. Its opposite is false. Full reference: true true // Output: true (checked checkbox) true ? \"üòÄ\" : \"üò≠\" // Output: üòÄ false The false constant represents the Boolean output false. Its opposite is true. Full reference: false false // Output: false (unchecked checkbox) false ? \"üòÄ\" : \"üò≠\" // Output: üò≠ Operators if The if() operator allows you to write if-then statements within a Notion formula. Full reference: if // if() syntax if(prop(\"Type\")==\"Mammal\",true,false) // Output: true // ternary syntax prop(\"Type\")==\"Mammal\" ? true : false // Output: true // Nested if statement if( prop(\"Age\") < 13, \"Child\", if( prop(\"Age\") < 19, \"Teenager\", \"Adult\" ) ) add The add (+) operator allows you to: Perform addition on numbers Concatenate strings ‚Äì i.e. combine them (also doable with concat()) Full reference: add Usage: + or add() 2 + 5 // Output: 7 \"Monkey D.\" + \" Luffy\" // Output: Monkey D. Luffy add(4,7) // Output: 11 add(\"Monkey D.\",\" Luffy\") // Output: Monkey D. Luffy subtract The subtract (-) operator allows you to subtract two numbers and return their difference. Full reference: subtract Usage: - or subtract() 12 - 5 // Output: 7 subtract(5,12) // Output: -7 multiply The multiply (*) operator allows you to multiply two numbers together and get their product. Full reference: multiply Usage: * or multiply() 12 * 4 // Output: 48 multiply(12,-4) // Output: -48 divide The divide (/) operator allows you to divide two numbers and get their quotient. Full reference: divide Usage: / or divide() 12 / 4 // Output: 3 divide(12,-4) // Output: -3 pow The power (^) operator (also known as the exponentiation operator) allows you to raise a number to a higher power. Full reference: pow Usage: ^ or pow() 3 ^ 4 // Output: 81 pow(4,3) // Output: 64 2 ^ 2 ^ 3 // Output: 256 - evaluates as 2 ^ (2 ^ 3) mod The remainder (%) operator allows you to get the remainder after dividing the first operand with the second operand. Full reference: mod Usage: % or mod() 19 % 12 // Output: 7 19 mod 12 // Output: 7 mod(-19,12) // Output: -7 unaryMinus The unaryMinus (-) operator negates a number. Full reference: unaryMinus Usage: - or unaryMinus() -42 // Output: -42 -(-42) // Output: 42 unaryMinus(42) // Output: -42 unaryPlus The unaryPlus (+) operator is used to convert Booleans and numeric strings to numbers. Full reference: unaryPlus Usage: + or unaryPlus() +\"42\" // Output: 42 +true // Output: 1 +false // Output: 0 unaryPlus(\"42\") // Output: 42 20 + + \"30\" // Output: 50 -+\"30\" // Output: -30 20 + - + \"30\" // Output? -10 [Notion will rewrite this to 20 + -(+\"30\")] not The not operator inverts the truth value of a Boolean/Checkbox value in a Notion formula. Another way of thinking about it is that it returns true only if its operand is false. It accepts Boolean operands. Full reference: not not true // Output: false not(true) // Output: false not empty(\"Hello\") // Output: true not if(50>40,true,false) // Output: false and The and operator returns true if and only if both of its operands have a true Boolean value. Otherwise, it will return false. It accepts Boolean operands. Full reference: and true and true // Output: true true and false // Output: false and(1>0,0<4) // Output: true if(true and true, \"Happy\", \"Sad\") // Output: \"Happy\" if(true and false, \"Happy\", \"Sad\") // Output: \"Sad\" if(5>4 and 1<3, true, false) // Output: true if(length(\"Monkey D. Luffy\") > 5 and length(\"Monkey D. Luffy\") < 100, true, false) // Output: true 4>2 and 3<4 and 7==7 ? true : false // Output: true or The or operator returns true if either one of its operands is true. It accepts Boolean operands. Full reference: or true or false // Output: true false or true // Output: true false or false // Output: false 10 > 20 or \"Cat\" == \"Cat\" // Output: true 10 > 20 or \"Cat\" == \"Dog\" or true // Output: true equal The equality (==) operator returns true if its operands are equal. It accepts operands of all data types ‚Äì strings, numbers, Booleans, and dates. Full reference: equal 1 == 1 // Output: True equal(1,1) // Output: True 1 == 2 // Output: False \"1\" == 1 // Type mismatch error +\"1\" == 1 // Output: True (uses the unaryPlus operator to convert \"1\" to a number 2^2 == 4 // Output: True length(\"Monkey D. Luffy\") == 15 // Output: True unequal The inequality (!=) operator returns true if its operands are not equal. It accepts operands of all data types ‚Äì strings, numbers, Booleans, and dates. Full reference: unequal 1 != 2 // Output: True 1 != 1 // Output: False unequal(\"Cat\",\"Dog\") // Output: True \"1\" != 2 // Type mismatch error 2^3 != 10 // Output: True larger The larger (>) operator returns true if its left operand is greater than its right operand. It accepts numeric, date, and Boolean operands. Full reference: larger 2 > 1 // Output: true 42 > 50 // Output: false // Boolean values equate to 1 (true) and 0 (false). true > false // Output: true true > true // Output: false // For dates, \"less than\" equates to \"before\". now() > dateSubtract(now(), 1, \"days\") // Output: true largerEq The larger or equal (>=) operator returns true if its left operand is greater than or equal to its right operand. It accepts numeric, date, and Boolean operands. Full reference: largerEq 2 >= 1 // Output: true 42 >= 42 // Output: true // Boolean values equate to 1 (true) and 0 (false). true >= false // Output: true true >= true // Output: true // For dates, \"less than\" equates to \"before\". now() >= now() // Output: true smaller The smaller (<) operator returns true if its left operand is less than its right operand. It accepts numeric, date, and Boolean operands. Full reference: smaller 2 < 1 // Output: false 42 < 50 // Output: true // Boolean values equate to 1 (true) and 0 (false). false < true // Output: true true < true // Output: false // For dates, \"less than\" equates to \"before\". now() < dateAdd(now(), 1, \"months\") // Output: true smallerEq The smaller or equal (<=) operator returns true if its left operand is less than or equal to its right operand. It accepts numeric, date, and Boolean operands. Full reference: smallerEq 2 <= 3 // Output: true 42 <= 42 // Output: true // Boolean values equate to 1 (true) and 0 (false). false <= true // Output: true true <= true // Output: true // For dates, \"less than\" equates to \"before\". now() <= now() // Output: true Functions concat The concat() function concatenates (aka combines) its arguments. It accepts one or more string arguments, and outputs a single combined string. Full reference: concat concat(\"Roronoa \",\"Zoro\") // Output: Roronoa Zoro \"Roronoa \" + \"Zoro\" // Output: Roronoa Zoro concat(\"Chopper\") // Output: Chopper (this is pointless, but it works) concat(\"Monkey\", \" D.\", \"Luffy\", \" will \", \"be\", \" King of the Pirates\") // Output: Monkey D. Luffy will be King of the Pirates // use \"\\n\" to create line breaks concat(\"Luffy \\n\", \"Zoro \\n\", \"Sanji \\n\", \"Nami \\n\") // Output: // Luffy // Zoro // Sanji // Nami join The join() function takes its first argument and inserts it in between each of its additional arguments. It accepts only string arguments. Full reference: join join(\", \",\"Luffy\",\"Zoro\",\"Nami\",\"Chopper\") // Output: Luffy, Zoro, Nami, Chopper // Use \"\\n\" to add line breaks join(\"\\n\",\"Luffy\",\"Zoro\",\"Nami\",\"Chopper\") // Output: // Luffy // Zoro // Nami // Chopper slice The slice() function allows you to ‚Äúslice‚Äù up a string and output a smaller piece of it. Full reference: slice slice(\"Dangerfield\",0,6) // Output: Danger slice(\"Monkey D. Luffy\",0,6) // Output: Monkey slice(\"Monkey D. Luffy\", 10, 15) // Ouput: Luffy slice(\"‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè\",0,6) + slice(\"‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã\",0,6) // Output: ‚óè‚óè‚óè‚óè‚óè‚óã‚óã‚óã‚óã‚óã length The length() function outputs a number that corresponds to the length of a string. Full reference: length length(\"Monkey D. Luffy\") // Output: 15 length(\"Supercalifragilisticexpialidocious\") // Output: 34 length(\"Doctor Doom\") // Output: 11 format The format() function formats its argument as a string. It accepts all data types, including dates, Booleans, numbers, and even strings. Full reference: format format(4) // Output: 4 (as a string) format(5+5) // Output: 10 (as a string) format(true) // Output: true (as a string) format(5>4) // Output: true (as a string) format(now()) // Output: June 20, 2022 2:23 PM (changes with now()'s value) \"There are \" + format(10) + \" Straw Hat members.\" // Output: There are 10 Straw Hat members. toNumber The toNumber() function converts its argument to a number if it can do so. It is useful for converting strings, Booleans, and dates to numbers. Full reference: toNumber toNumber(\"42\") // Output: 42 (number) toNumber(true) // Output: 1 toNumber(false) // Output: 0 toNumber(5>3) // Output: 1 toNumber(now()) // Output: 1655757000000 (changes with now()'s value) contains The contains() function tests whether the first argument contains the second argument. It only accepts strings (or nested functions that output strings). Full reference: contains contains(\"Monkey D. Luffy\", \"Luffy\") // Output: true contains(\"Monkey D. Luffy\", \"keyLuf\") // Output: false // Invalid contains(true, \"true\") // Error: Type mismatch true is not a Text. replace The replace() function searches a string for a pattern (which can be a regular expression), and replaces the first match it finds with another string. For replace(), replaceAll(), and test(), you may also want to refer to my full guide on using regular expressions in Notion. Full reference: replace replace(\"Pogo\",\"Po\",\"Dog\") // Output: Doggo // Matches the first occurrance, unless otherwise specified replace(\"Dogs Dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats Dogs Dogs // $ tells the regex engine \"start from end of line and work backwards\" replace(\"Dogs Dogs Dogs\",\"Dogs$\",\"Cats\") // Output: Dogs Dogs Cats // Matches are case-sensitive replace(\"thomas\",\"t\",\"T\") // Output: Thomas // You can use brackets [] to create a set of characters, // any of which will be matched replaceAll(\"thomas\", \"[Tt]homas\", \"Megatron\") // Output: Megatron // You can also create a group with () and then use the | (OR) operator replaceAll(\"thomas\", \"(T|t)homas\", \"Megatron\") // Megatron // Accepts regex metacharacters, such as \"\\\\b\" which denotes \"word boundary\". // Without \\\\b, this would output \"Thwas is Sparta\" replace(\"This is Sparta\",\"\\\\bis\\\\b\",\"was\") // Output: This was Sparta replaceAll The replaceAll() function searches a string for a pattern (which can be a regular expression), and replaces ALL matches it finds with another string. Full reference: replaceAll replaceAll(\"Dogs Dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats Cats Cats // Matches are case-sensitive replaceAll(\"Dogs dogs Dogs\",\"Dogs\",\"Cats\") // Output: Cats dogs Cats // You can use brackets [] to create a set of characters, // any of which will be matched replaceAll(\"Dogs dogs Dogs\", \"[Dd]ogs\", \"Cats\") // Output: Cats Cats Cats // You can also create a group with () and then use the | (OR) operator replaceAll(\"Dogs dogs Dogs\", \"(D|d)ogs\", \"Cats\") // Cats Cats Cats // Accepts regex metacharacters, such as \"\\\\b\" which denotes \"word boundary\". // Without \\\\b, this would output \"Thwas was Sparta\" replaceAll(\"This is Sparta\",\"\\\\bis\\\\b\",\"was\") // Output: This was Sparta // replaceAll() is a great way to count elements in a string. // Do this by using a regular expression to remove all characters // except the commas that separate the elements (see the example // database below for an in-depth look at this) replaceAll(\"Dog, Cat, Monkey, Bat, Gorilla\",\"[^,]\",\"\") // Output: ,,,, // Apply length() + 1 to get the count! test The test() function allows you to test whether a string contains a substring, the latter of which can be a regular expression. If it does, the function returns true. Full reference: test test(\"Monkey D. Luffy\", \"Luffy\") // Output: true // test() is case-sensitive test(\"Monkey D. Luffy\", \"luffy\") // Output: false // You can use brackets [] to create a set of characters, // any of which will be matched test(\"Monkey D. luffy\", \"[Ll]uffy\") // Output: true // You can also create a group with () and then use the | (OR) operator test(\"Monkey D. luffy\", \"(L|l)uffy\") // Output: true empty The empty() function returns true if its argument is empty, or has a value that equates to empty ‚Äì including 0 and false. Full reference: empty empty(\"\") // Output: true empty(0) // Output: true empty(false) // Output: true // Assume a row where the Name property is currently blank empty(prop(\"Name\")) // Output: true // Assume a row where the Name property contains text not empty(prop(\"Name\")) // Output: true // The same result can be accomplished with conditional operators // (Assume the Name property contains text in this row) empty(prop(\"Name\")) ? false : true // Output: true abs The abs() function calculates the absolute value of a number. Full reference: abs abs(-42) // Output: 42 abs(42) // Output: 42 cbrt The cbrt() function returns the cube root of its argument. cbrt() accepts only numbers. Full reference: cbrt cbrt(8) // Output: 2 cbrt(64) // Output: 4 // Total surface area of cube with Volume 300m¬≥ // using formula 6a¬≤, where a = edge length 6 * cbrt(300)^2 // Output: 268.88428479343 ceil The ceil() function returns the smallest integer that is greater than or equal to its argument. Full reference: ceil ceil(4.2) // Output: 5 ceil(3.845) // Output: 4 ceil(4) // Output: 4 // Calculate the donated change in a round-up donation // Assume prop(\"Subtotal\") is $5.34 ceil(prop(\"Subtotal\")) - prop(\"Subtotal\") // Output: $0.66 exp The exp() function allows you to raise Euler‚Äôs Number e (the base of the natural logarithm) to a higher power and get the output, where the argument is the exponent of e. Full reference: exp exp(2) // Output: 7.389056098931 exp(5) // Output: 148.413159102577 e^5 // Output: 148.413159102577 exp(ln(5)) // Output: 5 ln(exp(5)) // Output 5 floor The floor() function returns the largest integer that is less than or equal to its argument. Full reference: floor floor(4.2) // Output: 4 floor(3.845) // Output: 3 floor(4) // Output: 4 ln The ln() function returns the natural logarithm of a number. Full reference: ln ln(20) // Output: 2.995732273554 ln(e) // Output: 1 log10 The log10() function returns the base-10 logarithm of a number. Full reference: log10 log10(1000) // Output: 3 log10(10) // Output: 1 log2 The log2() function returns the base-2 logarithm of a number. Full reference: log2 log2(64) // Output: 6 log2(2) // Output: 1 max The max() function returns the greatest of one or more numbers. max() accepts only numbers or properties that output numbers (it will not auto-convert Booleans). Full reference: max max(3,5,4) // Output: 5 // Assume prop(\"Num\") contains 20 max(prop(\"Num\"),13,5) // Output: 20 // Other data types must be converted to number max(1,+true,+\"3\",9) // Output: 9 // Here, the + operator (unaryPlus) is used to convert // true and \"3\" to numbers. min The min() function returns the smallest of one or more numbers. min() accepts only numbers or properties that output numbers (it will not auto-convert Booleans). Full reference: min min(4,1,9,-3) // Output: -3 // Assume prop(\"Num\") contains 3 max(prop(\"Num\"),13,5) // Output: 3 // Other data types must be converted to number min(3,8,+false) // Output: 0 // Here, the + operator (unaryPlus) is used to convert // false to a number (0) round The round() function rounds its argument to the nearest integer (whole number). Full reference: round round(4.5) // Output: 5 round(4.49) // Output: 4 round(-4.49) // Output: -4 round(-4.5) // Output: -4 round(-4.51) // Output: -5 // Round to two decimal places round(4.158015*100)/100 // Output: 4.16 // Round to three decimal places round(5145.018394*10000)/10000 // Output: 5145.0184 sign The sign() function returns the sign of its argument. It indicates whether its argument is positive, negative, or zero. Full reference: sign sign(-5) // -1 sign(5) // 1 sign(0) // 0 sign(+\"-1\") // -1 sqrt The sqrt() function returns the square root of its argument. sqrt() accepts only numbers. Full reference: sqrt sqrt(16) // Output: 4 sqrt(100) // Output: 10 sqrt(73-3^2) // Output: 8 start The start() function returns the start date from a date range. It accepts a single date argument. Full reference: start // Assume a property \"Date\" exists, with // a row value of June 23, 2022 ‚Üí June 27, 2022 start(prop(\"Date\")) // Outpuut: June 23, 2022 end The end() function returns the end date from a date range. It accepts a single date argument. Full reference: end // Assume a property \"Date\" exists, with // a row value of June 23, 2022 ‚Üí June 27, 2022 end(prop(\"Date\")) // Outpuut: June 27, 2022 now The now() function returns the current date and time in your local timezone. now() accepts no arguments. Full reference: now now() // Output: June 23, 2022 12:30 PM (at time of writing) timestamp The timestamp() function converts a date argument into its corresponding Unix timestamp (also known as Unix Time or Epoch Time), which is a number. Full reference: timestamp timestamp(now()) // Output: 1656012120000 (will change with the value of now() fromTimestamp The fromTimestamp() function converts a Unix timestamp into a date. Full reference: fromTimestamp // Notion will express this date in your local time zone, so it // may look different if you try this formula out.hin fromTimestamp(1656012840000) // Output: June 23, 2022 7:34 PM (UTC) dateAdd The dateAdd() function accepts a date argument and adds to it, returning a new date. It requires three arguments in the following order: A date (must be an actual date data type) A number A unit Accepted units include: ‚Äúyears‚Äù ‚Äúquarters‚Äù ‚Äúmonths‚Äù ‚Äúweeks‚Äù ‚Äúdays‚Äù ‚Äúhours‚Äù ‚Äúminutes‚Äù ‚Äúseconds‚Äù ‚Äúmilliseconds‚Äù Full reference: dateAdd // Assume a property called \"Date\" with a current row value // of June 1, 2022 dateAdd(prop(\"Date\"),3,\"months\") // Output: September 1, 2022 dateAdd(prop(\"Date\"),5,\"days\") // Output: June 6, 2022 dateSubtract The dateSubtract() function accepts a date argument and subtracts from it, returning a new date. It requires three arguments in the following order: A date (must be an actual date data type) A number A unit Accepted units include: ‚Äúyears‚Äù ‚Äúquarters‚Äù ‚Äúmonths‚Äù ‚Äúweeks‚Äù ‚Äúdays‚Äù ‚Äúhours‚Äù ‚Äúminutes‚Äù ‚Äúseconds‚Äù ‚Äúmilliseconds‚Äù Full reference: dateSubtract // Assume a property called \"Date\" with a current row value // of June 1, 2022 dateSubtract(prop(\"Date\"),3,\"months\") // Output: March 1, 2022 dateSubtract(prop(\"Date\"),5,\"days\") // Output: May 27, 2022 dateBetween The dateBetween() function returns the amount of time between two dates, based on a specified unit of time. The function returns a number, and requires three arguments in the following order: Date 1 (must be a date data type) Date 2 (must be a date data type) A unit Accepted units include: ‚Äúyears‚Äù ‚Äúquarters‚Äù ‚Äúmonths‚Äù ‚Äúweeks‚Äù ‚Äúdays‚Äù ‚Äúhours‚Äù ‚Äúminutes‚Äù ‚Äúseconds‚Äù ‚Äúmilliseconds‚Äù Full reference: dateBetween // Assume now() == June 23, 2022 and Date == June 1, 2022 dateBetween(now(),prop(\"Date\"),\"days\") // Output: 22 // Assume now() == June 23, 2022 and Date == June 30, 2022 dateBetween(now(),prop(\"Date\"),\"days\") // Output: -6 // Assume now() == June 23, 2022 and Date == December 25, 2022 dateBetween(now(),prop(\"Date\"),\"months\") // Output: -6 formatDate The formatDate() function formats a date as a string using the Moment standard time format. Full reference: formatDate formatDate(now(), \"MMMM DD YYYY\") // Output: June 24 2022 formatDate(now(), \"dddd, MMMM DD, YYYY hh:mm A zz\") // Output: Friday, June 24, 2022 10:45 AM MDT formatDate(now(), \"[Month of] MMMM, YYYY\") // Output: Month of June, 2022 Good to know: formatDate() uses Moment.js for date formatting. minute The minute() function returns an integer (number) between 0 and 59 that corresponds to the minute of its date argument. Full reference: minute minute(now()) // Output: 25 (When current time was 11:25 AM) // Assume a propety called Date with a current date of June 24, 2022 11:29 AM minute(prop(\"Date\")) // Output: 29 hour The hour() function returns an integer (number) between 0 and 23 that corresponds to the hour of its date argument. Full reference: hour hour(now()) // Output: 11 (When current time was 11:25 AM) // Assume a propety called Date with a current date of June 24, 2022 11:29 AM hour(prop(\"Date\")) // Output: 11 day The day() function returns an integer (number) between 0 and 6 that corresponds to the day of the week of its date argument: 0 = Sunday 1 = Monday 2 = Tuesday 3 = Wednesdy 4 = Thursday 5 = Friday 6 = Saturday Full reference: day day(now()) // Output: 5 (when now() = June 24, 2022) // Assume a propety called Date with a current date of June 1, 2022 day(prop(\"Date\")) // Output: 3 date The date() function returns an integer (number) between 1 and 31 that corresponds to the day of the month of its date argument. Full reference: date date(now()) // Output: 24 (when now() = June 24, 2022) // Assume a propety called Date with a current date of June 1, 2022 11:29 AM date(prop(\"Date\")) // Output: 1 month The month() function returns an integer (number) between 0 and 11 that corresponds to the month of its date argument. Full reference: month month(now()) // Output: 5 (when now() = June 24, 2022) // Assume a propety called Date with a current date of Jan 1, 2022 month(prop(\"Date\")) // Output: 0 year The year() function returns an integer (number) that corresponds to the year of its date argument. Full reference: year year(now()) // Output: 2022 (When now() = June 24, 2022) // Assume a propety called Date with a current date of June 24, 2022 year(prop(\"Date\")) // Output: 2022 id The id() function returns the current row‚Äôs page ID, which is a unique string. id() accepts no arguments. Full reference: id // Page URL: <https://www.notion.so/thomasfrank/id-c5d67d15854744869cc4a062fb7b1377> id() // Output: c5d67d15854744869cc4a062fb7b1377 Formula Tips Here a few useful tips for working more effectively with formulas: Write Formulas in a Text Editor Full reference: Writing Complex Formulas in VS Code You can write formulas in a text editor like VS Code; this will allow you to use indentation, multiple lines, and comments. When you need to compress your formula for pasting into Notion, simply do a search-and-replace. Search for the following regular expression: (\\n[ ]{2,}|\\n|[/]{2}[^\\n]*) Copy and paste your formula. We‚Äôll compress one of the copies, leaving the other as an easy-to-read reference. Open the find and replace window with Ctrl/‚åò + F and paste the expression into the find field. Paste in the expression above. Click the Use Regular Expression button. Select the entirety of your formula (just one of the copies) Click the Find in Selection button. Ensure the Replace field is blank. Click the Replace All button. Return Empty/Null Values in Notion Formulas Full reference: Return Null/Empty Values in Formulas To return an empty string: \"\" To return an empty number: toNumber(\"\") To return an empty date: fromTimestamp(toNumber(\"\")) There is no possible null/empty state for Booleans/Checkboxes. However, you can convert Booleans to strings with format in order to create a setup where true/false/empty is possible: // Assume \"Checkbox\" is a Boolean/Checkbox property. // Invalid; will throw a Type Mismatch error: if( 1 > 2, prop(\"Checkbox\"), \"\") // Valid. Will output \"true\", \"false\", or an empty value. if( 1 > 2, format(prop(\"Checkbox\")), \"\") If you find this cheat sheet useful, you‚Äôll also love my Notion Tips newsletter! Join to get notified whenever I publish new tutorials, guides, and templates:","metadata":{"source":"https://thomasjfrank.com/notion-formula-cheat-sheet","title":"Notion Formulas: The Ultimate Cheat Sheet (2023)","date":"2022-09-12T19:56:09+00:00","contentLength":4157}},{"pageContent":"The most powerful and flexible tool in Notion is its database feature. Within your Notion workspace, you can create databases that can store almost any kind of data, including text, numbers, file attachments, and more. Databases can be used to create: Task managers (such as Ultimate Tasks) Calendars Note-taking systems CRMs Custom dashboards for sales and performance data ‚Ä¶and much more. Once you understand how to work with databases, you‚Äôll unlock a whole new level of capability inside of Notion. In this Notion Fundamentals lesson, I‚Äôll guide you through all the basics of creating and using databases. Note: This guide is massive, and is intended to be a truly complete tutorial for Notion databases. I encourage you to use the table of contents to jump around! In the video version of this lesson, we‚Äôll be using everything we learn to create a useful example database ‚Äì a simple task manager, which you could include in the personal dashboard that we‚Äôve been building throughout the other lessons in this series. One thing I‚Äôll note before we get started is that I‚Äôve created a completely free task management template called Ultimate Tasks, which has a lot more capabilities than the example we‚Äôll be building here ‚Äì such as sub-tasks, recurring tasks, progress bars for projects, and more. If you‚Äôre looking for a capable task manager for Notion, check it out! The Ultimate Task and Project Management Template for Notion Use this template to move ALL of your task and project management into Notion. Get it Free How to Create a Notion Database The best way to learn is by doing ‚Äì by trying things out, experimenting, and getting your hands dirty. So let‚Äôs start this guide out by covering how to actually create a Notion database. Doing so is simple; just type /database on any Notion page, and you‚Äôll see a list of database options. You can start out by choosing Database ‚Äì Inline, which will create a brand-new database right on that page. Here‚Äôs a very simple example database that lists some of my favorite movies: By default, your new database will be displayed as a table. Notion offers other database layouts, but a table is a great starting point. There are a couple of alternative ways to create a database as well. First, you can create a blank page (see my lesson on creating pages), and then select one of the database options: You can also use the / command to create a database with the specific layout you want. The options include: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view If you create a database block using a layout command, Notion will give you the option to either create a Linked Database (which links to an existing source database), or to create a new database. There are later sections in this guide for both (click to jump to them): Database Layouts Linked Databases For now, it‚Äôs just useful to know the ways you can create new databases. Notion Databases at a Glance Databases store rows (sometimes known as records). And in Notion, those rows are actually Notion pages themselves. The Table layout in Notion displays a database‚Äôs rows as they‚Äôre actually stored in the database (since Notion uses a table-style database structure with rows and columns). In this example, each movie is a row in the database. However, I can open up any one of them and get a Notion page that works just like any other: These pages can hold any type of content you want ‚Äì text, images, and even other Notion databases. Databases also have properties. You can see these at the top of the Hot Fuzz page above, or as columns in the Table view. Properties hold structured information within a database, and typically they‚Äôre set on a per-row basis. Here in the movies database, I have two: Genre ‚Äì a Multi-Select property, which allows one or more tags to be applied to each record Seen Recently ‚Äì a simple Checkbox property Properties have several uses, but their greatest use is in filtering and sorting your data. Here‚Äôs another view of our Movies table, filtered to show only the movies that we haven‚Äôt seen recently: Note how this is a different view of the same database. Our original Table tab doesn‚Äôt contain the same filter. By looking at the same database through different views with unique filters, we can look at the same database in many different ways. This is immensely powerful. Consider a Notes database containing all the notes in your life. That might be thousands of notes! Without any filters, this data would be hard to sift through. But by applying properties, sorts, and filters, you could create all sorts of useful views: All notes created in the last month Notes tagged with ‚ÄúFitness‚Äù All notes, sorted by Date Last Updated Notes related to the Vacation project in your Project Database Notes with a Review Date that falls within the next week Without a database, these types of filters and sorts aren‚Äôt possible in Notion ‚Äì which means you may eventually end up with long lists of pages that can only be sorted by dragging-and-dropping. Hopefully, this introduction has shown you just how powerful databases can be. From here, the rest of this guide is a choose-your-own-adventure: You can scroll up to the video tutorial above, where we‚Äôll create a simple task manager using some slightly more advanced database techniques. Or, you can keep reading this written guide, which will detail all the important Notion database features ‚Äì filters, sorts, grouping, properties, relations, linked databases, and more. What Is a Database? Now that you‚Äôve had a proper introduction to how Notion databases work, I‚Äôd like to touch a bit on what databases actually are before we get into the details of their individual features within Notion. In general, a database is defined as an: ‚Äú‚Ä¶organized collection of data stored and accessed electronically.‚Äù Nearly every program and web app you use relies heavily on databases. If you‚Äôve ever used a digital calendar app like Google Calendar, then you‚Äôve benefited from a database. Behind the scenes, every event on your Google Calendar is a row in a database. These rows have properties, just like the ones you saw in this guide‚Äôs introduction. Some of these include: Event date Location Calendar (Work, Personal, etc.) Google Calendar uses the values stored for these properties in each row to intelligently display your calendar, showing you each event on its correct day slot, displaying the event‚Äôs location, and color-coding each event based on its Calendar. Notion works in much the same way, but it gives you a lot more control over your databases. You can create your own properties, customize them, and set up database views that display your data based on filters, sorts, and more. Here‚Äôs an example: What if I just wanted to see events on my Work calendar in the month of August? In Google Calendar, I‚Äôd toggle all my other calendars to their ‚Äúoff‚Äù state, and navigate to the correct month: In Notion, I could achieve the same result by first ensuring that I have properties in my Events database for Date and Calendar. Then, I could simply create a view with two filters: Where Calendar contains Work Where Date is within August 1 ‚û° August 31 Of course, Notion also includes a Calendar layout, so the date filter might not be necessary. I just wanted to show you how you‚Äôd directly interact with your database properties to create unique, filtered views. Databases vs. Spreadsheets You might have looked at all our example table views in the screenshots and thought, ‚ÄúHey, those look like spreadsheets!‚Äù Indeed, they do look like spreadsheets ‚Äì but they‚Äôre not. There‚Äôs a fundamental difference between spreadsheets and databases. On a spreadsheet, data is contained within cells that have specific X:Y coordinates on a grid, such as B2 or D5. This means that formulas can reference specific cells, like B2+D5 ‚Äì this simple formula will add the values of B2 and D5. Conversely, databases don‚Äôt really have ‚Äúcells‚Äù with X:Y coordinates. Rather, each record has the same number of properties, each of which can be set to a unique value per record. Technically, since most databases are relational and store data in a table with rows and columns, you could feasibly target coordinates on the table. But since databases are built to be flexible, the vast majority of database tools don‚Äôt provide spreadsheet-like cell coordinates for row:property pairs. We can display a database in a grid-like table, but it‚Äôs not actually a grid of cells that we can target. This means we can easily visualize the information in our database in other ways besides a classic table ‚Äì such as a Kanban-style board, where the columns are based on the Assignee property: Spreadsheets and databases do have quite a bit of overlap, though. In a spreadsheet, we can simulate properties by creating a two-dimensional table. And apps like Excel even allow us to sort of treat a spreadsheet like a database through pivot tables and other functions. Likewise, an app such as Notion can let us view a database‚Äôs table structure, which looks like a spreadsheet. The most important thing to know as a Notion user, however, is that we can‚Äôt target individual row:property combinations as if they were cells on a grid. Here on my task table, I couldn‚Äôt write a formula that specifically targets the ‚Äúcell‚Äù with ‚ÄúApril 6‚Äù in it. In Excel, you might think of that location as B3, but there‚Äôs no B3 in Notion. Instead, there‚Äôs a row ‚Äì the ‚ÄúTest Web Parachute‚Äù row ‚Äì and its Due Date property is set to April 6. It‚Äôs also worth noting that ‚ÄúTest Web Parachute‚Äù is itself a specific value in the Name property. In Notion, new databases get a default property called Name, which can‚Äôt be hidden or deleted. But it is still a property ‚Äì just a special property. Its type is ‚ÄúTitle‚Äù, and you can actually open it up to see a brand-new Notion sub-page within your database. If you want to get even nerdier about spreadsheets and databases, check out this article comparing them. With this high degree of control and flexibility, you can use databases to create all sorts of different tools and applications inside of Notion. After all, many software tools are just collections of filtered database views! Consider: Your phone‚Äôs contacts app Task managers like Todoist Websites like IMDB Each of these simply gives you tools to work with one or more databases. As a result, you can create replacements for all of these tools inside of Notion. You can also create hyper-personalized tools that fit the exact information and processes you use for your work. That‚Äôs Notion‚Äôs superpower. It allows you to build tools that don‚Äôt yet exist, tailored to your exact needs. Notion Database Examples Book Tracker Contact Manager Simple Task Manager As we dig into all the particulars of Notion‚Äôs database tools, you might want some example databases to play around with. Here are a few, which will also serve to show you some of the tools you can build within Notion. Simple Task Manager Contact Manager Book Tracker Each of these databases is available as a free template, which means you can duplicate them into your Notion workspace and make changes to the duplicated copy. Learning happens fastest when you take action, so experiment and make some changes! Add some stuff! Let your cat walk on your keyboard for a minute and then try to fix everything that broke! There are 3 ways to make progress in anything:1. Buy new gear.2. Learn academically through books, courses, etc.3. Spend time in deliberate practice.In order of importance:Practice > Learning >>>>> Gear‚Äî Thomas Frank (@TomFrankly) May 29, 2022 I‚Äôll also note that these are very simple example templates. They purposely lack a lot of features so that they‚Äôre easy to understand and edit. I‚Äôve also designed several more robust templates with advanced features. These templates are completely ready to rock, and will instantly upgrade your Notion workspace with useful tools. Check them out on my Notion Templates page. We‚Äôre now ready to start digging into all of the features that Notion databases offer. From here, you may want to use the Table of Contents to the left (or at the top of this article if you‚Äôre on mobile) in order to find the topic you most want to learn about. Database Views A database view is a specific combination of layout, filters, sorts, etc. Note that a database block can contain multiple views. When it does, you‚Äôll see them all listed across the top as tabs: Each of these views pulls from the same database, but each shows a unique set of data based on a combo of sorting, filtering, and layout. You can also add a new view to a database block using the Add view button: For each view, you can access a View Options menu, where you‚Äôll be able to change nearly any setting related to that database view: Here, you‚Äôll have access to nearly every setting inside your database, including: Database name Layout ‚Äì Table, Board, Calendar, etc. Property settings ‚Äì show/hide properties on the current view Filter options Sort options Group options Load Limit ‚Äì sets the max number of rows that will be loaded automatically (you can load additional rows using the Load More button at the bottom of any view) Lock Database/Lock Views ‚Äì On a source database, this will lock the entire database. On a Linked Database, you‚Äôll see Lock Views, which merely locks the Linked Database‚Äôs views from being changed. (Learn more about locking databases) Copy Link to View ‚Äì copies the link to the current database view to your clipboard Duplicate View ‚Äì duplicates the specific view you‚Äôre currently on Delete View ‚Äì deletes the specific view you‚Äôre currently on Layout Types Notion databases can be viewed in several ways. You‚Äôve already seen the Table layout in our examples above, but that‚Äôs just one of six available layouts: Table ‚Äì a traditional, spreadsheet-like view Board ‚Äì a Trello-style ‚ÄúKanban‚Äù view Timeline ‚Äì a Gantt chart view Calendar ‚Äì a no-frills Calendar view List ‚Äì a responsive, mobile-friendly Table alternative Gallery ‚Äì an aesthetic view that‚Äôs great for showcasing images Each one of these layout types gives you a different way of displaying the same information from your database. They each have their own advantages, disadvantages, and features, so try them all out! Add New Pages to a Database You have a few different options for adding new pages to your database. First, you can hit the +New button within your database view. In a Table view, you‚Äôll find it at the bottom of the table: It‚Äôs worth noting that this is the only way to add a row that will conform to the view‚Äôs filters automatically. Example: If the view above had a filter that said ‚ÄúGenre is Action‚Äù, then your new row would automatically be tagged with Action. This is called a forcing function. Click here to jump to the section of the guide on forcing functions. You can also hit the blue New button in the top-right corner of any database view. This will open up a modal window with a blank record in the database. Additionally, you can create new rows in a specific database from anywhere in your Notion workspace by using the + link syntax, then choosing the ‚ÄúNew page in‚Ä¶‚Äù command. For example, I could add a new row to my Movies database from anywhere by typing +Ghost in the Shell, choosing New page in‚Ä¶, and then selecting the Movies database as the destination. Learn more about this in my guide on linking Notion pages together. Finally, you can add new rows to a Notion database through external tools. For example, the official Notion web clipper and the Save to Notion extension can both clip web pages into your Notion workspace. If you want to get more advanced, you can even use the Notion API to add new database rows using thousands of other tools. Database Properties Properties are the columns in a database‚Äôs table structure, and they‚Äôre useful for holding structured information about each row. They let you add dates, checkboxes, tags, numbers, and a lot more to your databases. In a Table view, you‚Äôll see your database‚Äôs properties as columns: In other layouts, you‚Äôll see property values listed on the cards for each row: You can show/hide individual properties on any given view by going to View Options ‚Üí Properties: By opening up a row as a page, you‚Äôll be able to see all of the properties in that row‚Äôs database. You can also easily add new properties here. Notion comes with many different types of properties. Some are writable, meaning you can edit the information they hold on each row. Others are read-only, meaning they hold information that can‚Äôt be edited. Here‚Äôs a table showing all of Notion‚Äôs property types: Property Description R/W Text Holds text, which can be formatted. Writable Number Holds numbers. Can be formatted as a progress bar. Writable Select Holds singular ‚Äútags‚Äù. Writable Multi-Select Can hold multiple ‚Äútags‚Äù. Writable Status Indicates project/task status. Always has a default value. Can show as text or a checkbox. Writable Date Holds dates, which can be displayed absolutely (e.g. ‚Äú03/25/22‚Äù) or relatively (e.g. ‚ÄúTomorrow‚Äù). Writable Person Holds members or guests of the workspace. Writable Files & Media Holds file attachments, including images, audio files, video, etc. Writable Checkbox Holds a simple checkbox. Writable URL Holds a URL, which is clickable. Writable Email Holds an email address. Writable Phone Holds a phone number, which can be called on supported devices. Writable Formula Holds formulas that can process and output data in many ways. Read-Only Relation Relates the row to other rows in the same database or another database. Writable Rollup Pulls in property information from Related rows. Read-Only Created time Holds the date and time of the row‚Äôs creation. Read-Only Created by Holds the workspace user who created the row. Read-Only Last edited time Holds the date and time of the row‚Äôs last edit. Read-Only Last edited by Holds the workspace user who last edited the row. Read-Only One last useful thing to know about properties is that they can be deleted and restored. If you accidentally delete a property, just head to View Options ‚Üí Properties ‚Üí Deleted Properties to find it and restore it (or permanently delete it if you want): Sorting You can sort a database view by any property, in either ascending or descending order. To create a sort: Hit the Sort button at the top of your database block. Select the property by which you‚Äôd like to sort your view. Choose ascending or descending order. Add additional sort criteria if you want. By adding additional properties, you can create even more granular sorts in your database views. In these cases, the database will be sorted by each property in top-to-bottom order. Drag properties around to change the sort order. Here, you can see that I have this shot list database sorted first by Type, then by B-Roll Description. P.S. ‚Äì This shot list database is part of Creator‚Äôs Companion, my all-in-one Notion template for content creators. Check it out if you make videos, blog posts, or social media content. If you create a sort within a database that is shared with others (Team Members or Guests), your sort will initially only be visible to you on your current device. You‚Äôll notice a Save for Everyone button after creating the sort; click it if you want to apply the sort to the database for everyone. You can also click Reset to remove any changes you‚Äôve made, or simply leave things as-is if you want to keep the sort for your eyes only. If you‚Äôre working on a database that‚Äôs private, you won‚Äôt see these options; they only come up on shared databases. Filters Databases often contain huge amounts of data, but you rarely need to see all of it at once. Typically, you just need to see the rows that are relevant to a specific context, like: Tasks that are due today Subscribers who are less than 30 days away from their renewal date Movies in the Action genre This is where filters come in. Filters allow you to limit the rows a view displays, and they‚Äôre among the most useful tools you‚Äôll find in Notion. Just like a sort, you can create a filter by hitting the Filter button at the top of your database block: There are two types of filters in Notion: Simple Filter ‚Äì a singular filter that targets one property Advanced Filter ‚Äì a set of filters or filter groups Simple Filters Simple filters are quick to create and target a single property. To create one, hit the Filter button and then select the property you‚Äôd like to filter by. Filters follow this convention: Property Name ‚Üí [Criteria] ‚Üí Value Here, you can see that I‚Äôm filtering my view by the Genre property, which has the Multi-Select property type: Your criteria options will change depending on the property‚Äôs type. Here, I have four options: Contains Does Not Contain Is Empty Is Not Empty Finally, I can choose one or more values. My completed filter reads: Genre Contains Action, which means my view will only show rows that have Action in their Genre property. Since Genre is a Multi-Select property, rows can also contain other genres. You can add multiple simple filters to a database view, and you‚Äôll see them displayed in a row across the top of your database view when the Filter bar is open. Advanced Filters An Advanced filter is a set of one or more filters that show up in a single dialogue box. Using an advanced filter, you can do something that‚Äôs incredibly useful; you can mix AND/OR operators when working with multiple filters. When you create multiple simple filters, you‚Äôre always using the AND operator between them. For example: ‚ÄúGenre contains Action‚Äù AND ‚ÄúSeen Recently is Checked‚Äù. By creating an advanced filter, you could instead set up this filter combo: ‚ÄúGenre contains Action‚Äù OR ‚ÄúSeen Recently is Checked‚Äù. Note how this drastically changes the rows that show up in this view! Now, a row only has to fit one of the filter criteria. Advanced filters also let you create filter groups. Within an advanced filter, click the Add Filter Rule dropdown and then select Add Filter Group to create one: Filter groups let you mix your AND/OR operators. Normally, once you‚Äôve chosen either AND or OR, you‚Äôre locked into that choice when you add more rules to the filter. However, a filter group gives you a nested box where you can select a new operator. How is this useful? Here‚Äôs an example problem: Say I‚Äôm a movie buff. I want to watch a movie every night, and I have these preferences: I‚Äôm an action movie nut, so I might want to watch an action movie even if I have seen it recently. For other genres, I only want to watch a movie if I haven‚Äôt seen it recently. Using a filter group, I can create a view that fits both of these preferences. In my Movies database, I‚Äôve created the following set of filters: If a row contains the Action genre, it‚Äôll always show up. If it doesn‚Äôt contain the Action genre, it‚Äôll only show up if Seen Recently isn‚Äôt checked. Here‚Äôs another example from my Ultimate Brain template: Ultimate Brain has a robust note-organization structure (modeled on Tiago Forte‚Äôs P.A.R.A. method) with: Higher-level Areas Lower-level Resources Areas can contain Resources, and Notes can exist in Areas or Resources. This means that within an Area, we‚Äôd want to show Notes that exist directly in that Area, or that exist within any Resources underneath that Area. We also want to make sure those Notes aren‚Äôt archived. Using a filter group, I‚Äôve created a combo of AND and OR operators to meet these criteria. This example is more complex than the previous one, but I hope that it illustrates how filters can allow you to create truly useful tools directly within Notion! P.S. ‚Äì If you‚Äôd like to use Notion as a true Second Brain, check out my Ultimate Brain template. It seamlessly combines tasks, notes, projects, goals, and whole-life organization, and it‚Äôs what I use as my own productivity system. Saving Filters As with sorts, filters created in shared databases will initially only affect your account and device. When you create a new filter or change/delete current filters, you‚Äôll see a Save for Everyone button pop up: You can click that to apply the filter for everyone who has access to the database, hit Reset to erase your changes, or just leave things as they are if you want the filter to only affect you. Forcing Functions When you set up a filter in a database view, new rows created in that view must conform to that filter. As a result, creating a new row in a view with filters will automatically set default property values. Here‚Äôs an example: In this view of the Movies database, I‚Äôve created the following filter: Seen Recently is Checked. Note how the new row I‚Äôve added automatically has its Seen Recently checkbox property checked. When filters are used in this way, I call them forcing functions. You can use these in all sorts of ways ‚Äì here are just a few ideas: Add tasks to a task view with a due date set to Today Add notes to a filtered notebook view with a specific tag, such as Lecture or Book Add tasks to a shared task database with a specific Assignee (person property) I‚Äôve made an entire video explaining how these work (and how to use them to your advantage) in a lot more detail: Grouping Notion lets you group rows in a database view based on common values in nearly any property type. Here, I‚Äôve grouped my Movies database view by the Genre property. Now my movie rows are grouped by genre: You can add Grouping to any view layout (except for Calendar) by going to View Options ‚Üí Grouping. From there, you‚Äôll be able to select the property you‚Äôd like to use for grouping: You‚Äôll also find a few other options, such as Hide Empty Groups. Sub-Grouping Notion‚Äôs Board layout has a unique feature: In addition to Grouping, it can have Sub-Grouping as well. Normally, a Board view will display its groups as columns. This is the classic ‚ÄúKanban‚Äù style of grouping that has its origins in Japanese manufacturing, and which was popularized in the U.S. by apps like Trello. By adding sub-grouping, you can group a board view into distinct rows. In this case, the rows aren‚Äôt actual database rows (as in a Table view); they‚Äôre sub-groups based on another property. In the screenshot above, I‚Äôve grouped the Board view by Genre, and then sub-grouped it by a new Select property called Rating. Movies are grouped by their ratings ‚Äì PG, PG-13, R, etc. You can add sub-grouping to a Board view in nearly the same way you‚Äôd add grouping ‚Äì simply navigate to View Options ‚Üí Sub-Group. Relations The Relation property type allows you to relate database rows to each other. These relations can be created: Between rows in the same database Between rows in separate databases This concept can take a bit of time to fully grok, so let me start out with an example. Example 1: Parent and Child Tasks Task managers often have a sub-tasks feature, which lets you nest sub-tasks underneath a top-level ‚Äúparent‚Äù task. Here‚Äôs a task with a couple of sub-tasks in Todoist: When you open the Parent Task 1‚Äôs window as in the image above, how does Todoist know to show you two sub-tasks ‚Äì and not show you any other tasks? Behind the scenes, there‚Äôs a Relation set up in Todoist‚Äôs database. This Relation consists of two properties, which you could think of as columns in a table: Parent Task Sub-Tasks The Parent Task 1 database row has its Sub-Tasks Relation property filled with links to two other database rows: Child Task 1 Child Task 2 Likewise, each Child Task has its Parent Task Relation property filled with a link to the Parent Task 1 row. In this way, Parent Task 1 is related to the two Child Tasks. With this Relation set up, Todoist can simply use a filter (also behind the scenes) to display the correct Child Tasks. Essentially, that filter would read: Where Parent Task contains ‚ÄúParent Task 1‚Äù This filter ensures that only the two Child Tasks show up. If that makes sense so far, let‚Äôs create it in Notion! How to Create a Single-Database Relation A Relation is a type of property, so you can add one to your database by: Adding a new property Selecting the Relation type Selecting the Database you‚Äôd like your Relation property to point towards Choosing whether the Relation should have separate properties Since I‚Äôm creating a Parent Task ‚¨å Sub-Tasks relation, I want to make sure I choose the same database that I‚Äôm currently working with ‚Äì in this case, My Tasks. Next, I‚Äôll choose whether or not I want to create Separate Properties. If I don‚Äôt, I‚Äôll just get a single Relation property called Sub-Tasks. If I do turn it on, I‚Äôll get a second property. Since I do want a second property called Parent Task, I‚Äôll turn on the Separate Properties option and give my second property the correct name: Now that I have my Relation properties, I can model Parent Tasks and Sub-Tasks just like we did earlier with Todoist. Here, I‚Äôve clicked into the Sub-Tasks property within the ‚ÄúTake Grocery Boxes‚Ä¶‚Äù row, and set two other rows as sub-tasks: Build grocery boxes Get rain covers Note how ‚ÄúTake Grocery Boxes‚Ä¶‚Äù automatically shows up in the Parent Task property for each of these sub-tasks. Now that we have these Relations set up, we can do some useful stuff! Here‚Äôs a basic example. I‚Äôve set up a simple filter that says: Where Parent Task contains ‚ÄúTake Grocery Boxes‚Ä¶‚Äù With this filter in place, I can only see the two sub-tasks I created earlier. In the Linked Databases section of this guide, I‚Äôll show you how to set up this same filtered view inside the Parent Task‚Äôs page. This is far more useful, and it models the Todoist example above perfectly. For now, let‚Äôs take Relations one step further by relating two separate databases together. Example 2: Tasks and Projects Task managers also tend to have Projects or Lists that are useful for grouping multiple tasks together. You can see this in Todoist: If we think about the databases that run everything behind the scenes, we realize that there are actually two main databases: Tasks Lists These databases are related to one another. This means that a single row in the Lists database can be related to many rows in the Tasks database. Then, using filters, Todoist can show you a tidy view of the tasks in a specific list, such as House. Guess what? You can do the exact same thing in Notion by creating a multi-database Relation! How to Create a Multi-Database Relation To create a multi-database Relation, we‚Äôll first need two databases to work with. Fortunately, the Simple Task Manager example template already has two: My Tasks My Projects I can create my Relation in either database, but I‚Äôm going to create it in My Tasks. Adding a new Property, I‚Äôll: Name it Project Select the Relation property type Select the My Projects database for the database connection Toggle Show on My Projects to the On position Name my Related Property with the My Projects database as ‚ÄúTasks‚Äù Note how the Relation builder also gives you a preview of what your Relation looks like. Here, you can see that two properties are being created: ‚ÄúProject‚Äù within the My Tasks database ‚Äì which points to the My Projects database ‚ÄúTasks‚Äù within the My Projects database ‚Äì which points to the My Tasks database These two properties are reciprocal, meaning that setting a related row in one will affect the other. In My Projects, the Suit Redesign project contains two related rows from My Tasks: Going over to My Tasks, we can see that both of these rows ‚Äì Design new web shooters and Test web parachute ‚Äì contain Suit Redesign in their Project property. With this Relation set up, I can do some very useful things. For example, I can group this view by my Project property. I can also set up a database view within a Project‚Äôs page that shows only its related tasks. To do that, I‚Äôll need to use a Linked Database. Linked Databases Linked Databases allow you to create a database block that pulls data from an existing source database, which can live elsewhere in your Notion workspace. For example, the main All Tasks database inside my Ultimate Brain template lives inside the Archive: On Ultimate Brain‚Äôs Quick Capture page, there‚Äôs a Linked Database block that uses All Tasks as its source: This means that any rows I add to this linked database view will end up in the All Tasks database. Essentially, you can think of Linked Databases as collections of Views for a database that can live elsewhere in your Notion workspace. Linked Databases are immensely useful. They allow you to create pages and dashboards in Notion that are driven by source databases, but that serve specific contexts. The Quick Capture page shown above is just one example of a context-specific page. Here‚Äôs another one ‚Äì this page only shows tasks that are due on or before tomorrow: Note that this Linked Database view has the source database hidden; this is an option you can turn off or on. How to Create a Linked Database You can create a Linked Database in Notion either by typing /Linked view of a database or by typing any of the following options: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view I‚Äôll go with /Linked view... inside the Suit Redesign project in the My Projects database. That way, I‚Äôll be able to get a view of all the tasks related to this project. The first thing I have to do is select a data source. This is the source database that I want to pull from. In this case, I want to select My Tasks: Next, I‚Äôll be given the option to either copy an existing view from the source database or to create a new empty view. I‚Äôll do the latter so I can completely customize it: From here, I can customize my view just like I would with a normal view inside the source database. All of the options are exactly the same. The only difference is that the Linked Database view comes with the option to show or hide the source database title. Here, I‚Äôve hidden it in order to make my database view look cleaner: The last thing I‚Äôll do here is add a filter to my linked view: Project contains Suit Redesign This will ensure that only tasks related to my Suit Redesign project show up. It also creates a forcing function, ensuring that new rows I add to this view will automatically be related to the Suit Redesign project! With this simple filter in place, my Project page works just like a List in Todoist (or any other task management app). Database Templates Pages inside a Notion database act just like normal Notion pages ‚Äì they give you a blank canvas on which you can add any combination of blocks. But you won‚Äôt always want to start from scratch; sometimes, you‚Äôll want to have a common starting point for certain pages in a database. That‚Äôs where database templates come in. By creating templates in your database, you can automatically generate any page content you want with just one click. Templates can be as simple or as complex as you want them to be. Here‚Äôs a very simple template within my Movies database: ‚Ä¶and here‚Äôs the comprehensive Content Project Template that I use for all of my YouTube videos. In one click, it generates a task list, shot list, script page, research area, multiple checklists, and more: Note how it also sets default values on some of my database‚Äôs properties ‚Äì including the Status, Channel, and #No properties. If you‚Äôre a content creator, you can get access to this template ‚Äì along with a whole suite of dashboards and tools to aid your creation process ‚Äì in my Creator‚Äôs Companion template. It‚Äôs the exact system I use to run my YouTube channels and blogs (including this one). When you have a template created within a database, you‚Äôll see an option to use it whenever you create a new page in that database and open and open it: You can also create a page from an existing template by clicking the arrow next to the blue New button in your database‚Äôs top-right corner, then selecting a template: How to Create a Database Template You can create a new template by clicking the arrow next to the blue New button in the top-right corner of your database, then clicking New Template. From there, you can add any content you want to the template. You can also set default values in properties, which will be applied to any new page that you generate from the template. Default Templates After you‚Äôve create a database template, you can choose to have that template automatically applied to any new pages you create. You can do this in two different ways: Set the template to be applied only on new pages in the current database view Set the template to be applied on pages created in all views of the database To set a template as a default, click the blue arrow next to the New button and find your template. Then click the ‚Ä¢‚Ä¢‚Ä¢ menu next to the template and choose Set as Default. Once done, you‚Äôll see the options I mentioned above: Choose ‚ÄúFor all views‚Äù if you want the template to be applied in all views of the database (i.e. it will always be applied). Choose ‚ÄúOnly on‚Ä¶‚Äù if you want the template to only be applied on the current view of the database. Self-Referential Filters One of the most useful things you can do with a database template is to combine it with a Linked Database and set up what‚Äôs called a self-referential filter. If you wanted to create a database template inside a Projects database, which shows all the tasks related to the current project, you‚Äôd use a self-referential filter for that. Note: Self-referential filters are tools for Notion power users. You should be familiar with Relations and Linked Databases before worrying about them. A self-referential filter is a filter inside a database template that updates itself when you create a new page from that database template. Specifically, a self-referential filter: Is set on a Linked Database that is placed within a database template. Filters a Relation property, which targets the database that contains the database template. Targets the database template itself. Essentially, a self-referential filter helps you filter a linked database view so that it only shows rows that are related to the page that contains that linked database. When you set it up in a database template, you set it to target the template itself ‚Äì but when you create a page from that template, the filter updates itself! Here‚Äôs a look at one in action. Here, I‚Äôm editing the Project Template in the My Projects database. I‚Äôve created a linked database, which points to the My Tasks source database. In the filters, I‚Äôve set up a filter that states: Project contains Project Template This means that only rows with Project Template set in their Project Relation would show up here. Of course, filtering for Project Template wouldn‚Äôt be very helpful. It‚Äôs a template, not an actual project. But watch what happens when I create a new project ‚Äì Suit Redesign ‚Äì and generate its page content from the Project Template: As you can see, my filter has automatically updated itself! Now it reads: Project contains Suit Redesign Crucially, I didn‚Äôt have to edit the filter myself. That‚Äôs the beauty of a self-referential filter; it auto-updates so that it targets your current database page instead of the database template. Rollups The Rollup property type allows you to pull property information from any rows that are connected to your current row through a Relation. You can also perform calculations on that information. To create a Rollup, add a new property just as you‚Äôd do for all other property types. Then set the Relation, Property, and Calculate options (explained below). Here, I have a Rollup called Undone Count in the My Projects database. It‚Äôs configured to show the state of the Done property for each of the rows that are related to my Suit Redesign row: See how the Rollup essentially allows me to pull information about the properties in these related rows? Not only that, but it collects this information in a single area; in other words, the information is ‚Äúrolled up‚Äù! Rollups have three configuration options: Relation ‚Äì the Relation property in your current database that you‚Äôd like to ‚Äúreach through‚Äù Property ‚Äì the Property in the database where the other side of the Relation exists (e.g. my Tasks Relation points to the My Tasks database, so it‚Äôs targeting the Done property of the rows there) Calculate ‚Äì the way in which you‚Äôd like to display the information By default, Rollups will use the Show Original setting within the Calculate dropdown. However, you‚Äôll find lots of other choices depending on the property type that you‚Äôre rolling up. If I set Calculate to Unchecked, I get a count totaling all the unchecked rows related to this project. In this case, both of the related tasks have been done, so the count is 0. Formulas Learn even more about formulas in my comprehensive Notion formula reference guide. Or, if you‚Äôre short on time, check out my one-page Notion formula cheat sheet. The Formula property type allows you to write formulas that can: Pull in data from other properties Format and change data Do complex calculations Run if-then scenarios with multiple potential outcomes Notion‚Äôs formula property is by far its most complex, and there‚Äôs essentially no limit to what you can do with it. Fun fact: My Ultimate Brain template contains a 10,000-character formula that does complex recurring-date calculations directly in Notion! You can create a formula property in Notion in the same way that you‚Äôd create any other property. From there, you can click the property‚Äôs content area to open up an editor where you can write formula code: Underneath the editor, you‚Äôll find a list of properties, functions, and more that you can use to create your formula. These include: Properties ‚Äì includes all the properties in your current database Constants ‚Äì such as e, pi, true, false Operators ‚Äì if, add, subtract, greater than, less than, etc. Functions ‚Äì join, slice, format, toNumber, etc. Since this is an overall guide to Notion databases, I won‚Äôt delve too deeply into how to write formulas here ‚Äì check out the full formula reference guide for that. For this post, I‚Äôll share two example formulas and explanations that will help you get started with writing your own formulas. Both of these can be found in the Simple Task Manager example template! Formula Example 1: Combine Numbers and Text The first formula we‚Äôll cover can be found in the My Projects database within the Simple Task Manager template. The property is called Meta, and it simply takes the number from the Undone Count property and formats it to look nicer. Here‚Äôs the ‚Äúcompact‚Äù version of the formula that you can easily paste into Notion: format(prop(\"Undone Count\")) + \" Tasks Left\" Note: If you paste this formula into a brand-new Notion database, you‚Äôll need the Undone Count property to exist first. Otherwise, you‚Äôll get a Property Not Found error. I prefer to write my formulas in a code editor (such as VS Code) and then make them compact using this Excel Formula Beautifier (which can either ‚Äúbeautify‚Äù code or compress it). As the name implies, it‚Äôs meant for Excel formulas ‚Äì but it works perfectly on Notion formulas as well. In fact, Notion‚Äôs formula syntax is extremely similar to Excel‚Äôs formula syntax. Here‚Äôs a version of the formula that‚Äôs easier to read: format( prop(\"Undone Count\") ) + \" Tasks Left\" The first part of this formula is: format(prop(\"Undone Count\")). It uses the prop() function to pull in the value of the Undone Count property, which is a Rollup (see the Rollup section above to learn more about those). I‚Äôm wrapping prop(\"Undone Count\") within the format() function in order to turn it into a String (which is basically just text). Notion formulas can output four different data types: String (plain text) Number Date Boolean (true/false, shown as a checkbox) However, a single formula can only output one data type. In other words, you can‚Äôt mix data types. Instead, you need to convert data types so that all of your output has the same type. The Undone Count Rollup property outputs a number, but ultimately my formula needs to output a string ‚Äì e.g. ‚Äú3 Tasks Left‚Äù. To achieve that, I use format() to transform that number into a string. It still displays as a number, but since it‚Äôs a plain-text string now, it can no longer be used in calculations (addition, multiplication, etc). Finally, I use the + operator to add my formatted number to this string: Tasks Left. Put them together, and you achieve a data-driven final output, such as: 3 Tasks Left! Formula Example 2: If-Then Statement Next, let‚Äôs look at how you can create variable output in a formula by using an If-Then statement. In the My Tasks database within the Simple Task Manager, I‚Äôve created a formula property called State. This property outputs a different symbol based on the status of the task: ‚è∞ = task is overdue üòÅ = task is done üü¢ = task is due today or later Here‚Äôs the compressed formula code, which you can easily paste into Notion: if(prop(\"Done\") == true, \"üòÅ\", if(dateBetween(now(), prop(\"Due\"), \"days\") > 0, \"‚è∞\", \"üü¢\")) Note: If you paste this formula into a brand-new Notion database, you‚Äôll need the Done and Due properties to exist first. Otherwise, you‚Äôll get a Property Not Found error. And here‚Äôs an expanded version of the formula that‚Äôs easier to read: if( prop(\"Done\") == true, \"üòÅ\", if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"‚è∞\", \"üü¢\" ) ) This formula has an if-then statement with another if-then statement nested inside it. By nesting if-then statements, we can create a formula that has more than two possible outcomes. To help you fully understand this formula, let‚Äôs first break down how if-then statements work. The basic syntax for an if-then statement in Notion is: if([test condition],[outcome if true],[outcome if false]) Essentially, we run a test, then define what do to if that test passes, and what do to if it fails. Here‚Äôs a bare-bones example: if(prop(\"Done\") == true,\"üòÅ\",\"üò°\") The == operator is testing whether the two pieces of information on either side of it are the same. Done is a checkbox property (with the data type boolean), so it outputs true or false. If the output of Done matches true, then the first option will be output: üòÅ. If not, Notion will output the second: üò°. Here‚Äôs where things get interesting ‚Äì either of the output paths in an if-then statement can contain additional functions. This can include more if-then statements! So let‚Äôs walk through the nested if-then statement from our example above: if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"‚è∞\", \"üü¢\" ) This statement will only be evaluated if the outermost if-then statement ‚Äì if(prop(\"Done\") == true ‚Äì returned false. This inner if-then statement tests to see whether the task is overdue or not. To do that, it uses the dateBetween() function, which finds the amount of time between two dates. I‚Äôm passing three arguments to this function: The now() function, which is built into Notion and returns the current date and time prop(\"Due\"), which returns the task‚Äôs due date \"days\", which simply specifies the unit of time dateBetween() should count by Finally, I check if the output of dateBetween() is greater than (>) zero. If it is, then the task is overdue and my formula outputs the ‚è∞ symbol. If not, the task is not overdue and the formula outputs the üü¢ symbol. As you can see, Notion formulas are extremely flexible and powerful. It‚Äôs also worth noting that practicing with Notion formulas is a good first step into actual programming if that‚Äôs something that interests you! Locking Databases Databases can take a long time to configure, and chaos can ensue if someone accidentally deletes a property, changes the settings of a view, or messes with a formula. Fortunately, Notion allows you to lock your databases in order to prevent these kinds of changes. To lock a database, first navigate to its original location. Open up the View Options menu and click Lock Database: When a database is locked, you won‚Äôt be able to make changes to its structure. You‚Äôll still be able to create new rows and set property values, but you won‚Äôt be able to: Add new properties Delete properties Change property settings (e.g. change a formula) Add/edit/delete options from a Select or Multi-Select property Fortunately, if you need to make a change, you can easily unlock the database by clicking the Locked button at the top. Note that you‚Äôll need to navigate to the original database to find this Locked button; you won‚Äôt see it on Linked Databases. Wrapping Up Whew ‚Äì we‚Äôre done. In this guide, we‚Äôve covered every main feature you‚Äôll find within Notion databases. You‚Äôre now ready to go out and start creating your own databases. Using the features we‚Äôve covered here, you‚Äôll be able to create useful tools that fit your individual workflows and tasks like a glove ‚Äì rather than relying on old-school productivity tools that don‚Äôt quite match the way you want to work. To learn even more about Notion, head to the Notion Fundamentals home page to check out all the lessons in this free series. You can also check out my Notion Templates, which can give you a head start and equip your workspace with an advanced task manager, note-taking system, habit tracker, and more. If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-databases-the-ultimate-beginners-guide","title":"Notion Databases: The Ultimate Beginner‚Äôs Guide","date":"2022-06-03T16:37:44+00:00","contentLength":8787}},{"pageContent":"If you plan your YouTube content in Notion, you might be wondering if you can bring the stats from your published videos back into Notion. Wouldn‚Äôt it be cool if you could display your live view counts, likes, and other data right on your Notion dashboard? What if you could pull in your thumbnails and use them as your page covers in Notion? What if you could do it without writing any code? Well, wonder no more ‚Äì all of this is possible! In this tutorial, I‚Äôll show you exactly how you can automatically bring YouTube data into Notion, just like this: Here you can see my list of published videos on my Thomas Frank Explains channel (within my copy of Creator‚Äôs Companion). For each video, I have an updated count for views, likes, and comments ‚Äì pulled directly from YouTube. My page covers are also set using my actual YouTube thumbnails. In this tutorial, I‚Äôll show you the exact, step-by-step instructions for pulling YouTube data into Notion yourself and achieving this exact result. Specifically, we‚Äôll be pulling the following data from YouTube (per-video): Views Likes Comments Publish Date Thumbnail Best of all, you can build this automation for free, for a limited number of videos (see the section on cost considerations for full details). Additionally, you can do it without any coding. This is a 100% no-code tutorial. Choose your adventure: The video above shows this entire process step-by-step, as does the written version below! What You‚Äôll Need to Get Started To successfully finish this tutorial, you‚Äôll need three things (I‚Äôll show you how to get all of these, step-by-step): A Make.com account ‚Äì this is the automation builder we‚Äôll be using to accomplish everything without writing code. A Google Cloud account ‚Äì you‚Äôll use this to interact with the YouTube Data API. A Notion database that contains YouTube video URLs If you already have a Notion database with your own video URLs, you can use that. However, if you‚Äôd like a sample database that you can use for practice, you can use this sample template. Just duplicate it into your workspace and you‚Äôll be ready to go. Before we move on, I‚Äôll note that if you are a serious creator and want a complete Notion system for tracking all of your content, you should check out Creator‚Äôs Companion: Recommended Creator's Companion: The Ultimate Creator Template Want a complete system for all of your channels, blogs, and social media accounts? Creator's Companion is the exact system my team and I use to manager our entire content creation process across all of our channels. Learn More This is the exact template that my team and I use to manage all of our content creation efforts across my YouTube channels and blogs. It allows you to manage the entire creation process, and includes dashboards for: Content calendar (across all channels and mediums) Idea capture Research and scripting B-roll and shot lists Publishing checklist The template also includes access to an active support community, so you can get help with any technical questions you have. I‚Äôve updated our own copy of Creator‚Äôs Companion to pull in live YouTube stats, which allows us to compare our predictions with actual video performance. If you do have Creator‚Äôs Companion, you‚Äôll be able to use this tutorial to do the same thing with your YouTube stats! What You‚Äôll Learn in This Tutorial While this tutorial is primarily intended to help you send YouTube data to Notion, it will also help you learn more about some useful concepts and tools: Notion databases APIs JSON Make.com and no-code automation Once you‚Äôve worked your way through this tutorial, you‚Äôll be able to use these tools and concepts to do a lot more. You‚Äôll understand how to make countless different apps and services talk to each other, enabling you to build tools that don‚Äôt exist yet (without coding). Note: I don‚Äôt assume any prior knowledge of JSON, APIs, or Make.com in this tutorial. If you can follow instructions, you‚Äôll be able to complete this tutorial. I do, however, assume some prior knowledge of Notion databases. If you need a refresher on those, check out my full beginner‚Äôs guide to Notion databases. If you do have prior experience with JSON, APIs, or Make.com, then you can go ahead and skip to the next section and start building right away. If not, fear not! I‚Äôm going to briefly explain each of these concepts here in this section, and I‚Äôll also link you to some useful resources you can use to learn more about each. What is JSON? JSON is a super-flexible, super-useful format for transmitting data between computers. It also happens to be the most important technology that powers Notion. In fact, if you‚Äôre ever hanging out with me and we‚Äôve had enough drinks, you‚Äôll probably hear me call Notion a ‚Äúfancy graphical wrapper for JSON‚Äù, because that‚Äôs basically what it is. But JSON doesn‚Äôt just power Notion; it‚Äôs also the data storage format that nearly every API in the world uses. It‚Äôs flexible, widely-used, and easy to understand. JSON stands for JavaScript Object Notation. Here‚Äôs an example piece of JSON data (which is real data returned by the YouTube Data API): { \"statistics\": { \"viewCount\": \"158907\", \"likeCount\": \"5947\", \"favoriteCount\": \"0\", \"commentCount\": \"241\" } } JSON is built on key:value pairs. An example from the snippet above would be \"viewCount\": \"158907\". \"viewCount\" is the key, and \"158907\" is the value that it points to (which is a string; more on that below the next code example). All JSON data is contained within objects, which are represented by the curly braces ({}). An object is simply an unordered set of key:value pairs. As you can probably tell, the value that corresponds to a key can actually be an object itself! The statistics key corresponds to an object, which itself contains more key:value pairs. Let‚Äôs look at a slightly more complex example, which also comes directly from the YouTube Data API: { \"snippet\": { \"publishedAt\": \"2022-08-12T22:27:41Z\", \"channelId\": \"UCd_WBvzBg1UbHE8j8MIL5Ng\", \"title\": \"10 New Notion Features You Need to Know About!\", \"thumbnails\": { \"default\": { \"url\": \"https://i.ytimg.com/vi/61a1Edq4iBo/default.jpg\", \"width\": 120, \"height\": 90 }, \"medium\": { \"url\": \"https://i.ytimg.com/vi/61a1Edq4iBo/mqdefault.jpg\", \"width\": 320, \"height\": 180 }, \"high\": { \"url\": \"https://i.ytimg.com/vi/61a1Edq4iBo/hqdefault.jpg\", \"width\": 480, \"height\": 360 } }, \"channelTitle\": \"Thomas Frank Explains\", \"tags\": [ \"notion\", \"notionhq\", \"notion app\" ], \"categoryId\": \"27\" } } This block might look intimidating, but in reality it‚Äôs just more of the same thing I shared above. There are more nested levels, and there a couple new elements in the mix. Let‚Äôs first talk about data types. Check out this line: \"title\": \"10 New Notion Features You Need to Know About!\" Since the \"title\" key‚Äôs value is in quotation marks, we know that the value has the string data type. JSON values have one of six different data types: string number Boolean (true/false) empty/null object array We can see another key:value pair in the JSON snippet above: \"width\": 120. This value has the number data type. Boolean values must either contain true or false, without quotation marks. Empty/null values must contain null without quotation marks. We already covered objects, so that just leaves arrays. An array is an ordered list of values. Array values are stored within brackets ([]), and each element is given a number based its position in the array. The number is essentially the key for each value, but it is not explicitly written into the array. It is implied based on the ordering of the elements in the array. We can see an array within the YouTube snippet above: \"tags\": [ \"notion\", \"notionhq\", \"notion app\" ] This array contains strings, but an array can contain data of any type ‚Äì numbers, objects, even nested arrays. Array numbering starts at 0; this is called zero-based indexing. So the string \"notion\" has an index of 0, the string \"notionhq\" has an index of 1, and so on. This introduction is all you‚Äôll really need to understand the JSON we‚Äôll be looking at in this tutorial. However, if you‚Äôd like to learn more, I recommend watching this video: What is an API? An API is essentially a set of tools that let web applications talk to each other. APIs are what allow: Social media scheduling tools like Buffer to post tweets to Twitter Notion to integrate with other tools like Github and Slack Connector tools like Make.com and Zapier to let you build custom connections between web apps API stands for Application Programming Interface. When a web app publishes an API, it is basically providing outside entities with a set of tools they can use to read and/or manipulate data stored on that web app. If you‚Äôre not a coder, you almost never have to think about APIs. They just do their thing in the background, shuttling data back and forth between apps that you use. Even if you use tools like Make.com, Zapier, IFTTT, etc. ‚Äì usually the guts of the APIs you‚Äôre working with are hidden from you. These tools have built integrations that are set up to work with the APIs of the web apps they support, so usually all you need to do is set the options you want. However, in this tutorial, we‚Äôll be working directly with the YouTube Data API. For that reason, it will be helpful if you understand a few key concepts about APIs and how they work. Note: This is a non-comprehensive, purposefully simplified explanation of APIs intended for non-coders. I‚Äôm probably leaving a lot out, but I‚Äôll link to more comprehensive resources at the end of this section. You typically work with APIs by making HTTP requests. This means that your application (in the case of this tutorial, the Make.com automation we‚Äôll be building), accesses a particular URL ‚Äì much like you‚Äôd do in your web browser when you want to visit a website! Note: You may have a conversation in the future about APIs with a nerd who will stress that you access URIs, not URLs. The distinction really does not matter here, but here‚Äôs an article on their differences if you‚Äôre curious. Your request typically needs four pieces of data: The endpoint to be accessed The method to be used A query string containing the details of your request An API key for authentication Let‚Äôs look at an example. The YouTube Data API features many different endpoints (e.g. sets of tools) for working with YouTube data. Note: Remember that this section is a primer; follow the actual tutorial to see all of these concepts in action! One of those endpoints is called Videos: list. It contains a set of methods meant for getting information about one or more videos ‚Äì including view counts, upload date, and more. If you read the JSON summary above, the JSON code snippets you saw were returned by Videos: list. Looking at the Videos: list reference page, we can see a Request section which specifies the HTTP request needed to access this endpoint: GET https://www.googleapis.com/youtube/v3/videos This means that your application has to make a request to https://www.googleapis.com/youtube/v3/videos in order to access information about YouTube videos using this endpoint. The section also specifies the method that must be used to interact with this endpoint: GET. There are five common methods we use to interact with API endpoints: GET ‚Äì used for reading data from the application. It is read-only, so it has no risk of modifying any data. POST ‚Äì sends data to the application to create something new. PUT ‚Äì sends data to the application to update an existing resource. Contains a full updated copy of the resource. PATCH ‚Äì also updates an existing resource, but only contains the changes to be made instead of the entire updated resource. DELETE ‚Äì sends an instruction to the application to delete an existing resource. Videos: list is an endpoint that relays information about existing videos, so it makes sense that it requires the GET method. One cool thing about endpoints that use GET ‚Äì you can usually call them directly from your browser! And when doing so, you don‚Äôt even need to specify ‚ÄúGET‚Äù ‚Äì you can just call the endpoint URL itself. I‚Äôve done this in the screenshot below, using Videos: list to pull information about this video. The YouTube Data API‚Äôs response (in JSON) when I called Videos: list to get information about my video. The blurred section of the URL contains my private API key. Here you can see a JSON response that looks very similar to the one shown above in the JSON primer. Calling this method in the browser is mainly only useful for demonstration and learning purposes; typically, you‚Äôd want to call it from within an application that will then manipulate the data (as we‚Äôll do later in this tutorial). What I‚Äôd like to point out here, though, is the URL itself: https://youtube.googleapis.com/youtube/v3/videos?part=snippet&id=61a1Edq4iBo&key=[MY_API_KEY] This URL contains the two components we haven‚Äôt covered yet: The query string and the API key. I‚Äôve removed my API key for security purposes. API keys should always be kept private. Anyone with access to your API key could access an API essentially posing as you, accessing information that should be only available to you or taking actions on your behalf. Let‚Äôs cover the query string first. This is essentially a set of instructions that tells the endpoint what we want. In this case, our query string is as follows: part=snippet&id=61a1Edq4iBo&key=[MY_API_KEY] This query string contains three details: part=snippet ‚Äì this tells Videos: list that we want the snippet for this video (which contains things like the publish date, title, description, etc.) id=61a1Edq4iBo ‚Äì this is the id of the video we want information about. The id can be found in the video‚Äôs URL: https://www.youtube.com/watch?v=61a1Edq4iBo key=[MY_API_KEY] ‚Äì this passes my API key as part of the request. Without a valid API key, I‚Äôll get a ‚Äúpermission denied‚Äù error instead of the information I want. Error response from the YouTube Data API after I pass it a query string where the key value is ‚Äúnothing‚Äù. So how do I know what to put in my query string? Simple: I check the API documentation. Nearly every API you‚Äôll encounter has documentation you can reference, which specifies the endpoints, methods, and more. Google‚Äôs API docs are particularly helpful becuase they feature a ‚ÄúTry This Method‚Äù tool for each method. Check out the Videos: list page to try it for yourself! After expanding the ‚ÄúTry This Method‚Äù box so it takes up more of the screen, I get this screen: See how this actually helps me to build my query string? In the part field, I specify that I want the snippet. The available options are listed in the method‚Äôs documentation. In the id field, I specify the id of the video I want information about. After executing the request, I can see the actually HTTP request in the HTTP tab. Finally, I can see the JSON response, along with the code 200, which indicates a successful response (400 would indicate failure). Of course, for this API request to be successful, I have to provide an API key. The ‚ÄúTry This Method‚Äù box makes this easy; when you click Execute, the Google API Explorer will ask you to log in with your YouTube account. It will then execute the request without you needing to specify your own specific API key ‚Äì it provides one behind the scenes. This makes trying out API methods very easy. When you‚Äôre actually building automations, you‚Äôll need to provide your own API key or otherwise authenticate yourself. This will be handled differently depending on the API you‚Äôre trying to access. Some APIs will give you a single key; others may provide both a client ID and a secret key. Some applications will also require you to work through the OAuth protocol instead of merely providing an API key. Each API will typically provide details on authentication in its documentation. Here are a couple of examples: YouTube API authentication documentation Notion API authentication documentation Note: When working with no-code automation tools like Make.com, typically the automation builder will handle all of this authentication for you. However, when you need to work with an unsupported tool (such as the YouTube API), you‚Äôll need to use the generic HTTP Request modules they provide ‚Äì and at that point, you‚Äôll need to provide your API key manually. I believe I‚Äôve provided enough of an introduction here to serve the purposes of this tutorial and other no-code use cases you may have. However, if you‚Äôd like to learn more about APIs, check out these resources. First, Fireship has a great (and quick) intro video on APIs: If you want to go even deeper, freeCodeCamp has a wonderfully comprehensive video that will guide you through an entire code-based project: As a non-coder, I‚Äôve always been intimidated by APIs because most tutorials that cover them do so while assuming a certain level of coding knowledge. It actually wasn‚Äôt until I started working with them through no-code tools like Make.com that I started to truly understand how they work. So if you‚Äôre a non-coder and want to understand APIs more deeply, let‚Äôs continue on with this YouTube-to-Notion automation project! What is Make.com? Make.com is what I call an automation builder. It‚Äôs a web app that gives you a visual interface for connecting other web apps together in order to build custom workflows. There are many other automation builders: Zapier IFTTT n8n NoCodeAPI Bardeen I prefer Make.com simply because I‚Äôve found that it has a good combination of power, supported apps, ease-of-use, and price. Best for No-Coders Make.com My favorite no-code automation builder that can create workflows between hundreds of apps. Has a bit of a learning curve, but it significantly more powerful (and cheaper) than Zapier. Has a great free tier too. Sign Up for Free I'll earn a commission if you sign up through this link and upgrade to a paid account (at no extra cost to you). Here‚Äôs a look at Make‚Äôs visual builder interface. In this simple automation, new tasks created in Todoist are sent to a Notion database: When working with Make‚Äôs supported apps, you‚Äôll get pre-made fields that you can use to easily customize your workflows: This makes creating complex automations very easy! Without tools like Make, you‚Äôd have to code your own web application, connect to both APIs (Todoist and Notion) manually, and run the app on a server constantly. Automations can also be significantly more complex than the example above. They can have branching paths, filters, and loops. They can work with complex data, like arrays. Best of all, Make gives you a general-purpose HTTP module (shown above), which you can use to connect to APIs that aren‚Äôt already supported by Make. The best way to learn Make (and any other automation builder) is to build something with it, so let‚Äôs continue with the tutorial! If you feel confident, let‚Äôs start building this automation! Tutorial Summary & Overview Before we dive straight into the details, let‚Äôs take a look at the process from a bird‚Äôs eye view so you know what you‚Äôre working towards. The Goal: Create a no-code automation that brings views, likes, and comments from your YouTube videos into a Notion database on a regular basis. Additionally, pull data from YouTube to set each video‚Äôs publish date and page cover (using the video‚Äôs thumbnail). To accomplish this, we‚Äôll work through the following steps: Set up a Notion database with video URLs and video IDs (the latter generated using a simple formula). Obtain an API key from Google so we can work with the YouTube Data API (in a read-only manner). Create an automation on Make.com that sends YouTube video data to Notion. Here‚Äôs what our Make.com automation will do, specifically: Pull a list of video IDs from Notion Query the YouTube Data API using those video IDs Get view, like, and comments counts, thumbnail URL, and video publish date from the YouTube Data API for each video Send all of this data back to Notion Prepare Your Notion Database Estimated Completion Time: 10-15 Minutes The first step we‚Äôll take is preparing a Notion database that contains the videos we want to track. The steps I‚Äôll demonstrate below will work on any Notion database. You do not need to be using any specific template. In this step, you‚Äôll: Identify the Notion database you want to use for tracking Ensure it contains a list of YouTube videos with live YouTube URLs Add properties for views, likes, comments, and publish date (if needed) Add a formula property that extracts the video ID from each video‚Äôs URL Note: If you want to learn more about Notion databases or need a refresher, check out my complete guide to Notion databases. I‚Äôm going to use a public demo version of my Creator‚Äôs Companion template, which means you‚Äôll be able to visit it and see a working example. If you have Creator‚Äôs Companion, you can simply follow along with the steps I‚Äôll demonstrate here. If not, simply apply the same steps to your custom database. If you‚Äôd like a simple starting point, grab my free example template and then skip to the next section of the tutorial: This example template already has all of the properties we‚Äôll be creating, and it also contains a ‚Äúfinished‚Äù copy of the pictured database that has sample data, publish dates, and thumbnails already filled in. Even if you‚Äôre not using this template, you may want to reference it. Step 1: Add YouTube Video URLs to the Database Create or navigate to a Notion database in your workspace that will be use for tracking your YouTube video stats. Since I‚Äôm building this in Creator‚Äôs Companion, I‚Äôm going to be using its Master Content Tracker database, which is the template‚Äôs central database for all content. Creator‚Äôs Companion uses linked databases to show useful filtered versions of this database within each Channel page. I‚Äôll go into the Channel page for my Thomas Frank Explains YouTube channel and navigate to the Completed Projects section, as I want to track stats for completed, published videos. From here, the crucial part is making sure I have a record for each video I want to track. As you can see, I‚Äôve now got a row for each published video on my channel. Remember, you can view this public demo page yourself to see how everything works! Step 2: Create the Database Properties If your database does not already have them, create the following five properties. Ensure their property types are as list here. Property Name Type Views Number Likes Number Comments Number Publish Date Date URL URL Note: If you are unable to create new properties, your database is likely locked. Here‚Äôs how to lock/unlock any database (as long as you have full access to it). If you‚Äôre using Creator‚Äôs Companion, follow these steps to find your database‚Äôs location and unlock it. Step 3: Add YouTube Video URLs If you haven‚Äôt done so already, add the correct YouTube URL for each video to your Notion database. Each video should be public, or at least unlisted. Private video URLs will not work, as we‚Äôll only be working with public YouTube data in this tutorial. Step 4: Create the ‚ÄúYT ID‚Äù Formula Property Next, create a Formula-type property and name it YT ID. This property will extract each video‚Äôs ID from its URL. Check out my guide on creating formula properties if you need help with this. Paste the following formula code into the formula editor: if(test(prop(\"URL\"), \"youtu.be\"), replace(prop(\"URL\"), \"^.*(?:\\\\.be)/([^?&]*)\\\\?*.*\", \"$1\"), replace(prop(\"URL\"), \"^.*(?:\\\\?v=|shorts/)([^?&]*)\\\\?*.*\", \"$1\")) How this formula works Curious about how this formula works? I‚Äôll break it down for you here. This formula uses the replace() function, which takes in an input string, looks for a sub-string within it, and then replaces that sub-string with a provided replacement string. It also uses the if() function to determine if the URL is one of YouTube‚Äôs shortened ‚Äúshare‚Äù links. If it is, we use a different replace() call than if it isn‚Äôt. Here‚Äôs a super-simple example of replace() that‚Äôs easy to understand: replace(\"The best Ninja Turtle is Raphael.\", \"Raphael\", \"Donatello\") // Output: The best Ninja Turtle is Donatello. However, replace() gets much more useful when you use regular expressions in the second argument. A regular expression is a string of special characters that can make your matching criteria much more flexible. I‚Äôve written a very detailed guide on regular expressions in Notion formulas, so I won‚Äôt cover all their details here. Instead, I‚Äôll simply break down one of the regular expressions used in the YT ID formula. Here it is: replace(prop(\"URL\"), \"^.*(?:\\\\?v=|shorts/)([^?&]*)\\\\?*.*\", \"$1\") The second argument contains the regular expression: ^.*(?:\\\\?v=|shorts/)([^?&]*)\\\\?*.* Here‚Äôs the plain-English version of what this expression is doing: Match the entire input string. After the first instance of either ?v= or shorts/, take all the characters and capture them up until the first instance of a ? character, if it exists. Finally, replace the match (which is the entire input string) with the contents of the capture group. This is the best way to extract a small piece of a string and output it within a Notion formula. Here‚Äôs how our regular expression does it: ^ used at the start of the expression means, ‚ÄúThe match must start from the beginning of the input string.‚Äù . is a special character which means ‚Äúmatch any character (except new lines)‚Äù. * is a quantifier, which tells the regex engine to match zero or more of the preceding element ‚Äì in this case, the . (?:) indicates a non-capturing group. It‚Äôs a group of characters that the regex engine won‚Äôt keep in memory for later reference. \\\\? matches the ? character. Since ? is used as a special character (e.g. (?:)), we have to escape it to tell the regex engine that we want to match an actual ? character. The pipe (|) character indicates either/or. So the engine can match either ?v= or shorts/ in this non-capturing group. () is a capturing group. The regex engine will capture any text in this group and allow us to reference it later. [^?&]* equates to ‚Äúmatch any number of characters that aren‚Äôt ? or &‚Äú. [] defines a character class, and within the brackets, the ^ means ‚Äúnot‚Äù. //?*.* helps us avoid capturing any query strings that might come after the video id in the URL. Capture groups are given a number by default ‚Äì much like items in an array automatically have number references. Our third and final argument within the replace() function is $1. The dollar sign ($) is a special character that tells the regex engine to reference a capture group, and the 1 tells it to reference the first capture group. Of course, we only have one capture group in this example! Using this formula, we‚Äôre able to extract the video‚Äôs ID out of its URL. We can then pass that ID to the YouTube API later in the tutorial. Note: You could also do this part on Make.com, as it comes with a regex-enabled text parser tool. I prefer to do it directly in Notion. If you‚Äôd like to learn more, check out my comprehensive Notion formula reference guide. It‚Äôs a complete technical reference for Notion formulas. Specifically, you should check out: The replace formula Regular expressions in Notion Formulas If you want to push your formula knowledge even further and learn how to solve complex, real-world problems using Notion formulas, check out my 14-day Notion Formula Bootcamp. At this point, your Notion database is prepped and ready to go! Get Your YouTube Data API Key Estimated Completion Time: 5 Minutes The next thing we‚Äôll need is an API key from Google that will allow us to interact with the YouTube Data API. Using it, we‚Äôll be able to send Video IDs from our Notion database to the API, and get back each video‚Äôs publish date, statistics, thumbnail image, and more. In this step, you‚Äôll: Enable Google Cloud on your Google account Create a project Enable the YouTube Data API for that project Obtain an API key Restrict the key so it can only be used via Make.com To get started, head to the Google Cloud Developer Console. Note: Google Cloud is a vast resource that includes access to database tools, APIs, AI tools, and a lot more. Any time you want to work with a Google-owned API (such as the YouTube Data API), you‚Äôll go through Google Cloud. You‚Äôll need to be signed into your Google account. If your account hasn‚Äôt already activated Google Cloud, you‚Äôll be asked to do so before you can start accessing API features. Next, we‚Äôll create a project. This is necessary for enabling access to Google APIs and getting an API key. Click Select Project near the top of the screen. Click New Project. If you don‚Äôt see ‚ÄúSelect a Project‚Äù at the of the screen, click APIs & Services on the lefthand sidebar. You‚Äôll be prompted to create a project there if you don‚Äôt already have one. Give you project a name. Click Create. Note: This will work seamlessly if you‚Äôre using a personal Google/Gmail account. If you‚Äôre logged in with a work account through Google Workspace, then your organization‚Äôs Workspace account will need to be active. Additionally, your organization admin may need to give you account the ability to create new projects. Open the navigation menu Choose APIs & Services, then Enabled APIs & services. Near the top of the screen, click Enable APIs and Services. From the API Library, search for youtube data api v3. Click YouTube Data Api v3 from the search results. It should be the only option. Click Enable to enable access to this API from your account. The YouTube Data API is now enabled on your account, but you‚Äôll still need an API key to work with it. From the navigation menu, click Credentials. Click Create Credentials near the top of the screen. Choose API key. We‚Äôre not building a user-facing application, so there‚Äôs no need to worry about the dialogue that mentions configuring an OAuth consent screen. An API key will be created for you. I‚Äôve blurred mine here for security; copy yours for later use, but don‚Äôt share it with anyone else. For extra security, we‚Äôll also restrict what this key can be used for. Click Edit API key. You can leave Application Restrictions set to None. However, we do want to set up some API Restrictions. Under API Restrictions, choose Restrict key. Search for and select YouTube Data API v3. Click Save. Note: These restrictions are just for extra security. As long as you don‚Äôt share your key, no one else will be able to use it. However, in the event that it is shared, these restrictions limit what it‚Äôs able to do. Now that you‚Äôve set up your API key and ensured it has access to the YouTube Data API, we can move onto the next step! For easy re-access, I recommend bookmarking Google Cloud so you can come back and fetch your API key whenever you need. Build the Make.com Automation Estimated Completion Time: 15-20 Minutes The final step in this process is to create a no-code automation that will get data about each video from the YouTube API and send it to the correct database row in Notion. To accomplish this without coding, we‚Äôll be using Make.com, which is my favorite no-code automation builder. If you don‚Äôt already have an account, you can sign up for free here: Best for No-Coders Make.com My favorite no-code automation builder that can create workflows between hundreds of apps. Has a bit of a learning curve, but it significantly more powerful (and cheaper) than Zapier. Has a great free tier too. Sign Up for Free I'll earn a commission if you sign up through this link and upgrade to a paid account (at no extra cost to you). In this step, you‚Äôll: Create a Make.com account (if you don‚Äôt already have one). Decide how to optimize your automation for update-frequency and cost (it can be done for free, but with limits). Build your automation visually using the Scenario builder. Enable your automation and set it to run on a schedule. During the build process, you‚Äôll do the following: Query your Notion database to get a list of video IDs Send those video IDs to the YouTube API Get information about each video, including view, like, and comment count, publish date, and thumbnail URL Update each video‚Äôs stats in Notion Set each Notion page‚Äôs cover to that video‚Äôs public thumbnail Let‚Äôs get started! Step 1: Create a Make.com Account If you don‚Äôt have a Make.com account, let‚Äôs create one. Enter your new account details. Click the verification link sent to your email in order to enable the account. Once you‚Äôve got your account set up, you can go to Scenarios to start building your automation. Skip down to step 2 of this section to start doing that. However, I‚Äôd recommend first clicking the Free button under Subscription to review the features and limitations of Make.com‚Äôs free account: Make.com Pricing and Cost Considerations Using Make.com, this tutorial can be completed for free! Why not Zapier? A significant reason we‚Äôre not using Zapier for this tutorial is that multi-step workflows are only available on their paid plans (which are also much more expensive than the paid plans of other platforms). Note: I‚Äôll note that I actually use Make.com and Zapier for different purposes, so I have experience with both platforms. Make.com‚Äôs learning curve is significantly higher, but the platform is also more powerful. As I‚Äôve continued to learn more about Make.com and how to use it, I‚Äôve found myself moving automations from Zapier to it. By contrast, Make.com allows you to create workflows with as many steps as you need, even on the free plan. Another reason is that Zapier‚Äôs Notion integration is not as powerful, and since the Notion API‚Äôs launch, Zapier has been much slower to update their integration than other platforms like Make.com and n8n. However, it‚Äôs important to understant that Make.com has limits on how much you can do on its free plan. This is true of all automation builders (the one exception I know of is n8n, but only if you self-host it on your own server or computer). The most important limitation to understand is Make‚Äôs operation limit. On the free plan, you‚Äôre limited to 1,000 operations per month. If you upgrade to the $9/mo Core plan (the one I use), that goes up to 10,000 operations per month. Once you‚Äôre on a paid plan, you can increase that number for an additional fee (20,000/mo, 40,000/mo, and so on). Here‚Äôs how these limits apply to the automation we‚Äôre building here: To query the YouTube API and send data to Notion, it takes 2 operations per video each time you run your scenario. It also takes 2 operations per video to set your Notion page cover using your YouTube thumbnail, though this only needs to be done once per video (and you can simply skip this part if you‚Äôre ok uploading page covers manually). Finally, it takes 1 operation to query your Notion database (to get the list of Video IDs) each time you run your scenario. Since setting the thumbnail only needs to happen once, I consider this automation to cost 2n+1 operations, where n is the number of videos you‚Äôre tracking. If you‚Äôre tracking 50 videos, thats means each run of your automation will cost 101 operations. With 1,000 operations/mo to play with on the free plan, that means you could run the scenario 9 times per month before running out. Given this limitation, here are a few options: Schedule your stats to be updated once a week. That equates to roughly 4 times a month, which should be fine for sitting down and reviewing content performance on a regular basis. Add a ‚ÄúTrack‚Äù checkbox to your database, manually select the videos you want to track, and set the automation to only track those videos. Upgrade to Make.com‚Äôs paid plan to increase your operation limit to 10,000/mo. I‚Äôll leave that up to you to decide! Can this process be made cheaper? Yes! But you‚Äôll need some coding knowledge. The ever-present trade-off when using no-code platforms is that they cost more to use than simply building apps and hooking into APIs yourself. But they‚Äôre far cheaper than hiring a developer, and they allow you to build amazing things without coding knowledge! The closer you get to actually coding, the cheaper you can generally make things on an ongoing basis. If you have some familiarity with JavaScript or Python, this automation can be set up and run much more cheaply using Pipedream. On their free plan, you‚Äôd be able to build the automation shown in this tutorial and run it multiple times a day (even for hundreds of videos). Unlike Make and Zapier, Pipedream is a low-code automation builder. While it has built-in integrations for hundreds of apps and will allow you to set up no-code workflows, the majority of its power lies in the fact that you can add NodeJS or Python modules within your workflows. However, unlike Make.com, Pipedream does not include built-in no-code tools for parsing JSON or looping over arrays. This means that their no-code integrations can do very simple things (such as updating a single Notion database page), but once you want to do more, you need to have some basic/intermediate programming skills. Here‚Äôs a look at one step in my automation: Pipedream requires some knowledge of programming in order to be truly useful. I‚Äôve started to learn Pipedream, and currently have a working version of this tutorial‚Äôs automation that uses JavaScript and works directly with the Notion and YouTube Data APIs. However, I still need to scale it so that it can handle databases with more than 50 videos ‚Äì unlike Make, Pipedream doesn‚Äôt handle pagination or rate-limiting automatically, so I have to modify my code to deal with any and all scale problems. I‚Äôll post a link to my Pipedream workflow when it‚Äôs finished. Until then, I‚Äôd recommend checking out the Pipedream quickstart guide if you want to learn how to use the platform! If you‚Äôd like to start learning JavaScript, here are some free beginner resources I recommend: JavaScript Algorithms and Data Structures on freeCodeCamp That Weird JavaScript Course by Fireship MDN Web Docs JavaScript Reference Beginner JavaScript Notes by Wes Bos Here are a few resources for learning to work directly with the APIs used in this tutorial: Notion API ‚Äì official documentation Notion API ‚Äì Postman (features more detailed examples) YouTube Data API ‚Äì official documentation If you prefer learning with video, Traversy Media published a great video on coding with the Notion API: And here‚Äôs a video from freeCodeCamp that will show you how to work with the YouTube Data API using HTML, CSS, and JavaScript: Step 2: Build Your Make.com Scenario We‚Äôre finally ready to start building our automation. To start, click Create a New Scenario from the top of the Make.com interface. You‚Äôll now be presented with the Make.com Scenario Editor. This is essentially a canvas where you can visually build your automation. To do that, you‚Äôll create modules and connect them together. As a mental primer, here‚Äôs what your final scenario is going to look like: To start building that, let‚Äôs create our first module. Click the big Plus button on the screen. Search for and choose Notion from the menu of app choices. Once done, you‚Äôll see a whole list of actions you can take from within Make.com‚Äôs Notion integration. The first thing we need to do is query your Notion database in order to get a list of the database rows that we want to send to the YouTube API. To do that, choose Search Objects. We now need to connect your Make.com account to your Notion account so the Scenario can access your Notion database. Next to Connection, click Add. Under Connection Type, choose Notion Public. Give your connection a name that you like ‚Äì it doesn‚Äôt need to be anything specific. A Notion authentication window will now pop up. Ensure you‚Äôre signed into the workspace that contains your target Notion database. Click Select pages. Next, select the pages for which you‚Äôd like to grant your Make.com connection access, and click Allow Access. Important: Notion has cascading permissions, meaning child pages inherit the permissions of their parent page. Make sure your target database is contained within the page you select here (or search for it directly). Additionally, understand that your Make.com connection will have permissions to access any other pages underneath the selected page. Here, I‚Äôm adding my Creator‚Äôs Companion Demo to the permissions list. This is a standalone demo version of Creator‚Äôs Companion, so the Master Content Tracker database that I‚Äôm targeting is a child of this page. (If you have the Creator‚Äôs Companion + Ultimate Brain bundle, note that Master Content Tracker has a different location. Refer to this page if you need to reference its location.) Once you‚Äôve done this, you can verify that Make.com has access to your target database like so: Navigate to your database‚Äôs location in Notion. Click the ‚Ä¢‚Ä¢‚Ä¢ icon in the top-left corner. Verify that Make is listed under the Connections sub-heading. Here you can see that Make has permission to read, insert, and update content within this database. Back on Make, let‚Äôs configure this module. Ensure Search Objects is set to Database Items (since we want to pull individual database items with this query). Under Database ID, click Search, and then search for the name of your database and click Ok. If you‚Äôve given Make the correct permissions, it should pull in your database‚Äôs ID automatically. How to Find Your Database ID Manually If the Search dialogue doesn‚Äôt work correctly, you can also enter your database ID manually. Here‚Äôs how to find it. From your Notion database‚Äôs home page (not a page containing a linked database view), click the ‚Ä¢‚Ä¢‚Ä¢ menu and click Copy Link. This will copy the entire URL of your database to the clipboard. It will look something like this: https://www.notion.so/ultimatebrain/8a37b5ad471a4153921eae0aaadb2c20?v=ede300269dd444eabaac7f00542c65c4 Your database ID is the bolded portion of the snippet above ‚Äì it is the string of characters after the final / character and before the ?v= characters. This means that my database‚Äôs ID is: 8a37b5ad471a4153921eae0aaadb2c20 If I paste this string directly into the Notion module in my Make.com Scenario, it‚Äôll work perfectly. Next, we want to filter our query so we only pull database rows where the URL field is filled with a youtube.com URL. To do that, set up a filter: URL (URL) Contains youtube.com Additionally, you can set a limit for the query. Set this number high enough that it‚Äôll fetch all the videos you want to track. Note: The Notion API limits database queries to 100 rows at a time. In order to an integration to pull more, it has to paginate its requests. Fortunately, Make.com‚Äôs Notion integration does this for you, so you can set a limit higher than 100! Next, let‚Äôs test the integration and make sure we get a response from Notion that contains data that we can send to YouTube. Right click the Notion module and click Run this module only. Note: Don‚Äôt skip these test runs while building this automation. They bring in data that you‚Äôll need to reference later on, so you‚Äôll get stuck if you skip them. If the test was successful, you‚Äôll see a green checkmark underneath the Notion module. You can also click the magnifying glass icon in order to see the data that was returned. If you‚Äôve followed everything perfectly so far, you should see a collection of Bundles in the output section of the window that comes up. All about bundles The Notion API technically returns an array of objects; each database row that matches the query we sent is an object, and the objects make up the elements of the array. Make.com converts each element to a bundle. Bundles are then sent one-by-one through the chain of modules you have set up. If you‚Äôre totally new to this concept, I like to think of it as similar to the classic Sega Dreamcast game Chu Chu Rocket. In that game, the player places directional blocks on a grid. Then, a chain of mice starts running. Each mouse has its direction changed the moment it steps on the direction block: Make.com scenarios do the same thing to bundles of data. Each bundle travels into a module; it is then operated upon by the module, and its output gets sent to the next module. If you have a programming background, you can also think of an entire Make scenario like a for‚Ä¶of loop. Typically, 1 operation is counted whenever a module processes an incoming bundle. This means that you can quickly use up your allotted Make.com operations if you‚Äôre building workflows that create lots of bundles. However, you can often make your scenarios more efficient by using their built-in tools, such as the array aggregator. This doesn‚Äôt work well for the YouTube-to-Notion workflow we‚Äôre building here (since we need to send page updates to Notion one-at-a-time), but you may find it useful in other automations! Next, we‚Äôll pull the YT ID property value from each of these Notion bundles and send it to the YouTube API in order to get information about each video. Make.com does not have a built-in YouTube API integration. Fortunately, they provide an HTTP module that we can use to talk to any API. We‚Äôll use that to send our data to YouTube. Specifically, we‚Äôll be calling the Videos:list method, which is used to get information about specific videos. The HTTP module is a general purpose module that you can use to send API calls to any API. It allows you to interact with tools and web apps that Make.com doesn‚Äôt officially support. Learn more about it here. Click the + icon to add another module. Search for and choose the HTTP module. From the menu of actions, choose Make an API Key Auth Request. To interact with the YouTube API, we‚Äôll need to pass the API key we set up earlier with any request we make. Under Credentials, click Add. You‚Äôll now add a new Key to your Make.com account. Note that this will be saved to the Keys menu accessible from the sidebar, and you‚Äôll be able to use it in other scenarios. Enter the following details: Name: Anything you want ‚Äì I like to match it to my Google Cloud project name Key: Your API key from Google Cloud API Key placement: In the query string API Key parameter name: key Click Create. Now we‚Äôll define the endpoint and method for our HTTP request. URL: (click the clipboard icon in this code block to copy) https://www.googleapis.com/youtube/v3/videos Method: GET Next, we‚Äôll set the parameters that will be passed in the query string that get outputted by this HTTP module. Leave Headers blank. This entire request is passed via query string. Under Query String, create two Items. Within Item 1, set Name to part and Value to snippet,statistics. Within Item 2, set Name to id. Click the Value field and find Notion ‚Äì Search Objects ‚Üí properties_value ‚Üí YT ID ‚Üí string. Drag it into the Value field. This process of clicking/dragging elements into fields is called mapping. Click here to learn more about mapping in Make.com. Finally, under Parse Response, choose the Yes option. If you choose No, the HTTP module will output YouTube‚Äôs response as a string (and a very long one at that). To properly interact with the data in the next step, it needs to be formatted as JSON. Choosing Yes will tell Make to automatically output the response as JSON. Let‚Äôs test the workflow we have so far: Near the bottom of the screen, click the Save Icon to save your work. Click Run Once. If your test was successful, you should be able to click the magnifying glass icon on the HTTP module and see one operation per bundle that was sent from the Notion module. You can even toggle into the Output bundles. Under Data ‚Üí items ‚Üí 1 ‚Üí snippet, you‚Äôll be able to see your video‚Äôs title and some other info! Now we can send this data back to Notion in order to update your video statistics there! From the HTTP module, click the + icon to add another module. Select Notion. Select Update a Database Item. Set the following details: Enter a Database ID: Enter manually Database ID: Find and click Notion ‚Äì Search Objects ‚Üí Parent ‚Üí Database ID Page ID: Find and click Notion ‚Äì Search Objects ‚Üí Page ID Next, we‚Äôll define the properties to be updated. We‚Äôll set the property name, type, and value it should recieve. For each Value, click the field and map the indicated value listed below by clicking it. Item 1: Key: Views Value Type: Number Value: Click and Drag: HTTP ‚Üí Data ‚Üí items ‚Üí statistics ‚Üí viewCount Item 2: Key: Likes Value Type: Number Value: Click and Drag: HTTP ‚Üí Data ‚Üí items ‚Üí statistics ‚Üí likeCount Item 3: Key: Comments Value Type: Number Value: Click and Drag: HTTP ‚Üí Data ‚Üí items ‚Üí statistics ‚Üí commentCount Item 4: Key: Publish Date Value Type: Date Value: Click and Drag: HTTP ‚Üí Data ‚Üí items ‚Üí snippet ‚Üí publishedAt Everything else can be left blank. Click Ok when done. Fields screenshots Items 1 and 2: Items 3 and 4: Save your automation and then click Run Once again. If you‚Äôve set everything up correctly, you should now see your view, like, and comment counts (and your publish dates) updated in Notion! Here‚Äôs the Completed Projects section of my demo template, complete with updated stats! Next, we‚Äôll modify our automation so that it also sets each Notion page‚Äôs cover using your actual video thumbnails from YouTube. This involves adding another Notion module to our scenario, since the Update a Database Item module doesn‚Äôt give us access to the Page Cover property. However, another Notion module means another operation for each bundle. Operations are limited, and since thumbnails don‚Äôt change often, you‚Äôll probably want to set the page cover only once. To do that, we‚Äôll first add a Router to the automation. This allows you to add conditional logic to your workflow; bundles will travel down each path in a Router, but only if they fit the filter criteria of each path (if there is any). Right-click the dotted line between the HTTP module and the final Notion module. Click Add a Router. Click the Router to add another path. On the new path, add a new module. Select Notion, then select Update a Page. Note how I‚Äôve dragged my modules around to create a branching < shape. Within the Update a Page module, set the following: Page ID: Notion ‚Äì Search Objects ‚Üí Page ID Cover URL Link: HTTP ‚Üí Data ‚Üí items ‚Üí snippet ‚Üí thumbnails ‚Üí maxres ‚Üí URL Click Ok. This module will now pull your video‚Äôs thumbnail URL directly from YouTube and set it as your video‚Äôs page cover in Notion. Finally, let‚Äôs set up a filter to make sure this only happens if the page cover hasn‚Äôt been pulled from YouTube already. Click the dotted line between the Router and the Update a Page module you just set up. Label the filter: Only if thumbnail isn't set (or something else descriptive). Leave Fallback Route on No. Now set the Condition fields: Notion ‚Äì Search Objects ‚Üí Cover ‚Üí External ‚Üí URL Text operators: Does not contain (case insensitive) HTTP ‚Üí Data ‚Üí items ‚Üí id Finally, click Ok. Each video‚Äôs thumbnail URL is derived from the video‚Äôs ID, which can be found within the video‚Äôs actual URL. For example: Video: https://www.youtube.com/watch?v=61a1Edq4iBo Thumbnail: https://i.ytimg.com/vi/61a1Edq4iBo/maxresdefault.jpg Here‚Äôs how your final setup should look: Step 3: Enable and Schedule the Scenario If you‚Äôve followed all the steps I‚Äôve laid out, your scenario is now completely set up! All that remains to be done now is to save your work, enable the scenario, and set a schedule for it. Near the bottom of the screen, set the following options: Click the Save Icon. Set a schedule for your scenario. I‚Äôve chosen Each Monday at 12:00 PM here ‚Äì this means the scenario will run once a week. Turn the scenario On. You‚Äôre free to set the schedule however you like; just keep in mind the operation limits of your Make.com plan when doing so. Remember that each run of the scenario will take 2n+1 operations, where n is the number of videos you‚Äôre updating. And runs that involve thumbnail updates will take 1 additional operation per video that gets passes through the thumbnail filter. Final Result Here‚Äôs the result of this process applied to my demo copy of Creator‚Äôs Companion: If you‚Äôd like to check out these stats live, here‚Äôs the direct link to this Thumbnail View in my demo. If you‚Äôre curious about how I got these stat counts that start with emojis, they‚Äôre the result of a small formula! Here‚Äôs the actual formula code: \"üëÄ: \" + replace(replace(format(prop(\"Views\")), \"(\\\\d{1})(\\\\d{3})$\", \"$1,$2\"), \"(\\\\d{1})(\\\\d{3},\\\\d{3})\", \"$1,$2\") You can learn how this formula works by checking out the replace and regular expression guides in my Notion Formula Reference. Hopefully you‚Äôve found this tutorial helpful, and hopefully it has also shown you the vast potential of these no-code tools! By combining Notion with tools like Make, you can connect to hundreds of other web apps and do basically anything you want. I‚Äôm planning to create lots of other no-code automation tutorials in the future. If you want to be the first to know when they go live, join my Notion Tips newsletter. Once you join, all also send you a handy link to all my free templates and Notion reference guides!","metadata":{"source":"https://thomasjfrank.com/notion-automation-youtube-data","title":"How to Send YouTube Data to Notion (No Code) ‚Äì Notion API Tutorial","date":"2022-10-11T23:30:24+00:00","contentLength":9445}},{"pageContent":"This tutorial will show you the exact, step-by-step process to create recurring tasks in Notion and completely automate them. That means you‚Äôll be able to check off a task, and everything else simply happens for you ‚Äì the due date gets moved, the Done checkbox becomes un-checked, and the task is ready and waiting for you the next time you need to do it. Yes, seriously. The method I‚Äôll show you in this article requires no coding and can be done for free. Additionally, once you‚Äôve completed the initial setup, you‚Äôre good to go ‚Äì your recurring tasks will just work. Here‚Äôs a breakdown of what we‚Äôll be doing: Set up recurring tasks inside of Notion Automate those recurring tasks using Pipedream (free) The automation here is driven by the Notion API, and by some code that I‚Äôve written for you. All in all, this automation should take you no more than 10 minutes to set up. Let‚Äôs go! Note: A previous version of this workflow used Make.com, and required a lot more manual setup. While I don‚Äôt recommend using that version, I‚Äôve kept the written instructions for it in a toggle section below. Click here to jump to it if you need it. Set up Recurring Tasks in Notion Before you can automate your recurring tasks, you‚Äôll need to set up a system to add recur settings to those tasks in the first place ‚Äì e.g. ‚ÄúEvery other day‚Äù, or ‚ÄúEvery 2 months‚Äù. Fortunately, we‚Äôve done this work for you. My team and I have added a set of powerful recurring task features to Ultimate Tasks, my free task manager template. I recommend starting by adding the template to your workspace: The Ultimate Task and Project Management Template for Notion Use this template to move ALL of your task and project management into Notion. Get it Free Ultimate Tasks also has a ton of other features that will allow you to manage your tasks and projects completely in Notion: Projects (with built-in progress bars) Sub-Tasks Smart Lists (Today, Next 7 Days, etc.) Cold Tasks (long-overdue tasks get out of your way) Ultimate Tasks also comes with a detailed wiki that includes tutorials and deeply detailed reference docs. For the rest of the tutorial, I‚Äôll assume you‚Äôre using Ultimate Tasks (or its big brother, Ultimate Brain). However, if you want to implement the recurring tasks features from Ultimate Tasks into your own template, you can see all of them in my Advanced Recurring Task Dates template. This template exists as an educational proof-of-concept, so it‚Äôs less useful as an actual task manager. Add Recur Intervals to Your Tasks To set up a recur interval for a task, open the task as a page. You‚Äôll see a Due Date property, as well as three properties for setting up a recurring task: These give you all the tools you need to set almost any recur interval you could want. Recur Interval ‚Äì A simple number property that works with Recur Unit. Recur Unit ‚Äì The available recur units, including Day(s) Week(s) Month(s) Month(s) on the Last Day Month(s) on the Last Weekday Month(s) on the First Weekday Year(s) Days (Only if Set to 1 Day(s)) ‚Äì this will let you set a task to recur on specific days on the week ‚Äì e.g. Mon/Wed/Fri Recur Unit must be set to Day(s) and Recur Interval must be set to 1. Once you set up a recur interval, you‚Äôll also see a property called Next Due. This shows the next due date for the recurring task. Example Recur Settings Here are a few examples of recur intervals you could set up using these three properties: Due Every 3 Days: Recur Interval : 3 Recur Unit: Day(s) Due Every 2 Months on the Last Weekday Recur Interval: 2 Recur Unit: Month(s) on the Last Weekday Due Every Tuesday and Thursday Recur Interval: 1 Recur Unit: Day(s) Days (Only if Set to 1 Day(s)): Tuesday, Thursday As you can see, there are many combinations of these three properties that will let you create most of the useful recur intervals that you could create in other apps like Todoist, Asana, or ClickUp. Completing Recurring Tasks Manually You can ‚Äúcomplete‚Äù a recurring task directly inside of Notion simply by changing the Due Date property to the date displayed in the Next Due property after you finish the task. Note that you do not need to click the Done checkbox property in this case, as it won‚Äôt do anything. If you want to be able to click Done and have the task automatically update its Due Date, then continue on to the next portion of the tutorial. Set Up Automated Recurring Tasks in Notion Using the Notion API, we can automate all sorts of processes inside of Notion that used to be done manually. This includes processing recurring tasks! If you‚Äôre curious about the details, I‚Äôve written about them in the two toggle sections below. Feel free to read those; otherwise, you can skip them and get right to building. What is an API? Essentially, an app can have an API (Application Programming Interface) that allows outsiders ‚Äì including indie developers and even other apps ‚Äì to work with certain pieces of its code. Here‚Äôs an example of an API in action. In Slack, I can use the Giphy extension ‚Äì which leverages the Giphy API ‚Äì to paste a gif right in one of my conversations. There are several tools ‚Äì we can call them integration builders ‚Äì that let you connect different app APIs together. Some focus on providing a set of no-code tools, allowing you to build automations without coding at all. These include Zapier, IFTTT, Make.com, and others. Others are code-light; they provide some no-code tools, but also allow you to write your own code ‚Äì without having to worry about things like authentication, security, and server infrastructure. Pipedream is one of those tools, and it‚Äôs the one I personally use to build all my automations ‚Äì and to build automations that I can share with you in these tutorials. How This Automation Works If you‚Äôre curious, here‚Äôs how the automation of recurring tasks works ‚Äì both in Notion an in basically any productivity app. When you set up a recurring task and check it off as ‚ÄúDone‚Äù, here‚Äôs what happens from the app‚Äôs perspective: The user has checked ‚ÄúDone‚Äù, so run the recurring tasks script Update the Due Date as specified by the user‚Äôs recur interval (e.g. ‚Äúevery other day‚Äù) Uncheck the ‚ÄúDone‚Äù box There‚Äôs another way an app could handle recurring tasks: Instead of editing the task you checked off, it could create a duplicate of that task with the new due date. However, most productivity apps use the method I‚Äôve just described instead. My Ultimate Tasks template contains all the logic needed to calculate the Next Due Date right within the template itself. This is very useful ‚Äì it allows you to use the manual method of updating recurring tasks if you want, but it also saves us the trouble of adding very complex date calculation code to our automation. Here‚Äôs all that our automation will be doing. Step 1: Search through your tasks database in Notion, looking for tasks that have been marked Done and that have a date displayed in the Next Due property. Step 2: For each found task that fits those two criteria, update the Due Date property to have the date displayed in the Next Due property, and then un-check the Done checkbox property. That‚Äôs it! In the next section of the guide, I‚Äôll walk you through the exact steps to setting up your automated recurring tasks workflow. Automated Recurring Tasks with Pipedream Now that your tasks database in Notion is all set up, all that‚Äôs left to do is create that automation that will actually process your completed recurring tasks. I‚Äôve built this workflow for you in Pipedream, an automation builder that allows developers to build and share workflows with others. Since Pipedream allows me to use code to build workflows, I‚Äôm able to build truly custom tools that fit the exact needs of Notion users. (When I was using no-code builders like Zapier and Make, there were often a lot of limitations in my workflows ‚Äì hence why I‚Äôve switched to Pipedream). To get started, click the link below to import my recurring tasks workflow into your Pipedream account. If you don‚Äôt already have an account, you‚Äôll be prompted to create one. And yes, it‚Äôs free! Essential Notion ‚Äì Automated Recurring Tasks This workflow adds completely automated recurring tasks to Notion. Use This Workflow This workflow is 100% free to use, and this link adds extra perks over the normal free Pipedream account. However, I'll earn a commission if you click this link and upgrade to a paid Pipedream account (at no extra cost to you). Full disclosure: I‚Äôm both a heavy Pipedream user and an affiliate. If you use my link and decide to upgrade to a paid plan, I‚Äôll earn a commission (and if you do, thank you! It helps support my work). That said, Pipedream has a very generous free plan. You can do a lot more with their free plan than you can with the free plans of other automation builders. And when you use my link, your Free plan gets even better. Normally, Pipedream‚Äòs free plan limits you to 3 connected apps ‚Äì but my link raises that limit to 5 connected apps, allowing you to build even more automations before needing to upgrade. Once you‚Äôve added the workflow to your account, follow the instructions in this brief video to get it all set up. That‚Äôs it! (Legacy) Set Your Time Zone Note: The Pipedream workflow I shared above completely takes care of this step for you. I‚Äôve left these instructions here for anyone using the old Make version of the workflow, but I highly recommend upgrading to the Pipedream version. For automated recurring tasks to work, you‚Äôll first need to set up a UTC Offset property in your Notion workspace. Why do I need to set a UTC Offset? Feel free to skip this, but here‚Äôs a technical explanation for those who are curious. When a Notion formula outputs a date, the Notion API will always see that date from the perspective of UTC time. This presents a problem, because our Next Due formula has advanced logic that takes into account whether or not a task was overdue when it was completed. Most task management apps do this, including Todoist and Asana. If they didn‚Äôt, then you can run into a situation like this: A task is due Jan 1, and is set to recur every 3 days. Normally, it should be next due on Jan 4. You ignore it for a long time, and finally check it off on May 6. Now it shows as due Jan 4 ‚Äì still way, way overdue. A smarter task manager would realize that the task is overdue and take this into account. Instead of updating the due date to Jan 4, it should update it to be due on May 7. Our Next Due formula does this, which is great‚Ä¶ except it clashes with the Notion API‚Äôs insistence on seeing the output of Next Due in UTC time. Here‚Äôs the problem‚Ä¶ UTC time is often in a different day than your local time zone is. For example, if it‚Äôs 7pm in Denver on May 6, it‚Äôs actually 2am in UTC time‚Ä¶ on May 7, the next day. This means that the your automated recurring tasks script (which we‚Äôll build below) looks at the output of Next Due using the Notion API‚Ä¶ and sees the task as overdue. You checked the task off on time (at 7pm), but the API sees it as 2am the next day. Note: Our recurring tasks solution doesn‚Äôt officially support task times. They‚Äôll work most of the time, but there are weird situations where they won‚Äôt (such as the day that Daylight Savings Time happens). But even without times on your tasks, the API looking at your workspace from UTC time-perspective can cause it to see your workspace from the perspective of the next day (or the previous, if you‚Äôre east of the UTC time zone and it‚Äôs very early in the morning). That‚Äôs where our UTC Offset property comes in. Since I‚Äôm in Denver, I set my offset to -7, which subtracts 7 hours from the output of Next Due (but only if it‚Äôs being viewed from the perspective of UTC time ‚Äì we thought ahead on that one). This means the Notion API now sees the output of Next Due the same way we see it. In other words, the offset forces the API to look at Next Due as if it were in my local time zone (Denver). Fortunately, Ultimate Tasks, Ultimate Brain, and my Advanced Recurring Tasks proof-of-concept templates all come with a UTC Offset property by default, so all you‚Äôll need to do is edit it so that it matches your time zone. If you happen to be using an older version of one of my templates that doesn‚Äôt contain this property, please see this upgrade guide to learn how to add it. A UTC offset is just the number hours that your local time zone is behind or ahead of UTC (Coordinated Universal Time). I live in Denver, Colorado, so my standard UTC offset (when not affected by Daylight Savings Time, the scourge of the modern world) is -7. Hence, you see -7 in the UTC Offset property above. You can find your own UTC Offset at the Time and Date website. Type in your location, then find the UTC Offset for your standard (not Daylight Savings) time zone. Here, you can see that I‚Äôve identified UTC-7 as my offset. By default, my templates have their UTC Offset property set to 0. You‚Äôll want to change it to match your actual UTC Offset. In your All Tasks database, find the UTC Offset property by opening up any task and then clicking the more properties button: You‚Äôll find UTC Offset in under the ‚è± Recurring Divider property: Edit UTC Offset so it contains your standard UTC offset (again, not your daylight savings time offset). If you‚Äôre unable to edit this value, you‚Äôll need to unlock the database you‚Äôre working on first. With your UTC Offset set, you‚Äôre now ready to build your automation! (Legacy) Automated Recurring Tasks with Make.com Note: These are the instructions for the previous version of this workflow, which used Make.com instead of Pipedream. These instructions will still work, but the setup takes much longer and is much more error-prone. I highly recommend using the Pipedream version above ‚Äì it‚Äôs free, and I have lots of other custom Notion automations for Pipedream in the works! Make.com is a powerful integration builder that gives you near-direct access to Notion‚Äôs API (as well as the APIs for many other apps). Best for No-Coders Make.com My favorite no-code automation builder that can create workflows between hundreds of apps. Has a bit of a learning curve, but it significantly more powerful (and cheaper) than Zapier. Has a great free tier too. Sign Up for Free I'll earn a commission if you sign up through this link and upgrade to a paid account (at no extra cost to you). Here are the steps you need to follow to create your recurring tasks automation using Make.com. First, create a Make.com account if you don‚Äôt have one. You can stick with the free plan, as it‚Äôll work perfectly for our purposes. The only thing to be aware of regarding the free plan is its Operation limit. The free plan limits you to 1,000 operations per month. We‚Äôve found that it costs one operation each time you run the script (called a Scenario) we‚Äôll be building, as well as one operation per recurring task that is updated. By default, Make.com will set your Scenario to run every 15 minutes ‚Äì however, that would result in 2,976 operations per month ‚Äì without counting the operations needed to actually update your tasks! For that reason, I set my Scenario to run once a day at 11:55pm (it needs to be before midnight). That‚Äôs 31 max operations per month, leaving 969 left over to update my tasks (and I don‚Äôt have even close to 969 recurring tasks in a month). Armed with that knowledge, head to your Scenarios tab and Create a New Scenario. Click the large + button and search for Notion. From the list of actions that pops up, select Search Objects. This will create the first part of a two-step automation that will help us automatically process recurring tasks. The next step is to connect your Scenario to your Notion account. Click the Add button under Connection: Ensure Notion Public is selected under Connection Type. The Connection Name doesn‚Äôt matter, so you can leave it as My Public Notion Connection if you want. Now you‚Äôll authenticate with Notion. Be sure you‚Äôve selected the correct Workspace that contains your copy of Ultimate Tasks, then hit Select Pages. Next, select your copy of Ultimate Tasks, or a page that contains it. Remember that Notion has cascading permissions, which means that sub-pages inherit the permissions of their parent page unless you change them manually. This works in our favor, as what we really need to give Make.com access to is the All Tasks database contained within Ultimate Tasks. Once you‚Äôve selected the correct page, click Allow Access. Now we need to get the Database ID from our All Tasks database. This will tell our Scenario precisely with database to search. You can find your Database ID by navigating to your All Tasks database within Ultimate Tasks. Important: You must be on the actual All Tasks database page. Ensure that you‚Äôre not merely on another page that contains a Linked Database view. Copy the URL of the All Tasks database to your clipboard. You can do this with Ctrl/‚åò + L or by hitting the three-dot menu in the top-right corner and then clicking Copy Link. From there, you can find the Database ID by copying the part of the URL directly after the / character in notion.so/ and before the ? character: Here‚Äôs my database‚Äôs URL: https://www.notion.so/97a4d9506d1840d2a00e186a3d2d632f?v=2cf8cd2d0caa47fd88e61de05cf9ee59 Which means my Database ID is: 97a4d9506d1840d2a00e186a3d2d632f Head back to your Scenario. Ensure that Search Objects is set to Database Items, and then paste your Database ID into the Database ID field. Note: The example ID shown in this post will not work for you ‚Äì your Database ID must be from your own All Tasks database. Next, add three Filters, ensuring the second and third are added as AND rules. Filter 1: Done (Checkbox) Equals True (drag the pink true Keyword from the popup. Ensure the gear-icon tab is active.) Filter 2: Next Due (Formula) Formula sub-heading ‚Üí Text ‚Äì Is not empty (boolean) ‚Äì Important: Select this option from under the Formula subheading in the dropdown menu. True (drag the pink true Keyword from the popup. Ensure the gear-icon tab is active.) Filter 3: Next Due (Formula) Formula sub-heading ‚Üí String ‚Äì Does not equal Paste Error in Recur Interval: Non-Whole or Negative Number in the third field. This is an error that Next Due will display in Notion if you happen to set your Recur Interval property to an incorrect number, like 1.5 or -42. Finally, set the Limit to 100 and hit OK. Before we move onto the next step, head back to your copy of Ultimate Tasks and ensure there is at least one recurring task that has been marked Done. Your Make.com Scenario needs to find at least one Done recurring task in order to complete the search we just set up and grab data that we‚Äôll need to finish building the automation. Once you‚Äôve done this, head back to your Scenario and hit the Run Once button in the bottom-left corner. Additionally, hit the Save icon in order to save your work. If everything worked as expected, you should see a green checkmark under your Notion icon, as well as a number in the upper corner (this is the number of Done recurring tasks that the search found in your All Tasks database). Additionally, there should be no errors displayed in the Log. If there are, the most likely error is that you didn‚Äôt have a recurring task in your All Tasks database that was marked Done before you hit Run Once. In this case, mark a recurring task Done and then hit Run Once again. Next, we‚Äôll create the second half of our Scenario which will actually update our All Tasks database and process the completed recurring tasks that were found in the search. To the right of your Notion icon, click Add Another Module. Click Notion, then choose Update a Database Item from the list of actions. Under Enter a Database ID, change the dropdown option to Enter Manually. Paste the same Database ID from before (the one from your All Tasks page URL) in the Database ID field. Next, drag the id object from the pop-up and drop it into the Page ID field. Note: The id object may also be called Page ID. I‚Äôve seen it listed both ways, but it works either way. Next, click Add Item under Fields. For Item 1, set it up as follows: Key: Due (simply type this ‚Äì it‚Äôs the name of your Due property in Ultimate Tasks) Value Type: Date In the Start Time field, do the following: First, click over to the calendar menu icon in the popup, then drag in the parseDate(;) function to the Start Time field. Next, click back to the star menu icon in the popup. Under properties_value and then Next Due, find the string object and drag it between the ( and ; in parseDate(;). Finally, between the ; and ) symbols in parseDate(;), paste MMMM DD, YYYY. The other fields ‚Äì End Time and Include Time ‚Äì can be left blank. This function simply updates the Due Date property in Ultimate Tasks with the date displayed in Next Due. Remember: Next Due is the Formula property that does all of the recurring date calculation directly in Notion for us! Add one more item with the following values: Key: Done Value Type: Checkbox Value: No This part of the function will automatically uncheck the Done checkbox. Hit OK. There‚Äôs just one more thing to do. Click the three dots between your two Scenario steps to create a filter. Give it the following settings: Label: Check Results Condition: Drag the id object into this field. Note: It may also be called Page ID. Criteria: Exists This filter will keep the Scenario from throwing an error (and sending you an annoying email) in the event that it doesn‚Äôt find any completed recurring tasks when it performs its search. At this point, you can hit Run Once in order to test your script. Watch your All Tasks database: Any Done recurring tasks should be automatically un-checked and have their Due dates updated. Once you‚Äôve verified the test was successful, there‚Äôs one quick step left before we approach the finish line. Right-click the very first module you set up in the beginning‚Äîthe Notion Search Objects module‚Äîand click Add error handler. In the box that pops up, click Commit. This will tell Make that the scenario has completed successfully, even if the Search Objects module fails to find anything. You wouldn‚Äôt normally want to silence error messages, so it‚Äôs important that this step comes last, after everything‚Äôs already working. The reason we need to do this is that a scheduled Make scenario automatically turns off if it gives an error too many times in a row. Since the Search Objects module fails if it doesn‚Äôt find anything, this would happen if you just happened to go a few days without completing any of your recurring tasks, and you‚Äôd have to come back to Make.com to turn it on again. With that out of the way, it‚Äôs time to set your Scenario‚Äôs schedule. I recommend running it once per day to minimize the actions it takes up. Note that your Scenario must run during the current day, so I recommend setting it to 11:55pm. This way, your scheduled Scenario runs will only use a maximum of 31 Operations per month (one per day), leaving 969 (1,000 ‚Äì 31) leftover to process your completed recurring tasks. Note that on Make.com‚Äôs free plan, 15 minutes is the smallest interval you can use for your Scenarios. Keep this in mind when building other Scenarios that may need more frequent updating or faster response times. Finally, switch the Scenario to On, and save your work. (Legacy) Adjust Your Template Settings Note: The Pipedream workflow I‚Äôve shared above takes care of this step for you automatically. I‚Äôve only left these instructions up for people using the old Make version of the workflow. The last thing you may want to do is edit the Type property in your All Tasks database if you‚Äôre using Ultimate Tasks or Ultimate Brain. Replace its formula with this one: if(empty(prop(\"Recur Interval\")), \"‚è≥One-Time\", \"‚è≥One-Time\") These templates contain filters that will prevent tasks with a Type of üîÑRecurring from leaving your task views when the Done checkbox is checked. This is a bit of error-prevention, since many users don‚Äôt know that checking Done on a recurring task won‚Äôt do anything by default. But now that you‚Äôve set up automatic recurring tasks, checking Done actually does do something! So we can now get rid of this error-checking, and the easiest way to do it is to edit the Type formula as described above. Otherwise, you‚Äôd have to go around and edit the filters in every view of Ultimate Tasks. Wrap-Up and More Resources That‚Äôs the end of this tutorial, but if you want to learn more and take your Notion workspace to the next level, check out some of my other tutorials: Notion API Guide: Integrate with 3,000+ Apps (With NO Code) How to Build a Personal Dashboard in Notion Synced Blocks in Notion: Everything You Need to Know Also, if you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-automated-recurring-tasks","title":"The Best Way to Create Recurring Tasks in Notion (2023)","date":"2022-03-24T17:25:06+00:00","contentLength":4568}},{"pageContent":"If you want to learn how to work directly with the Notion API, this tutorial will teach you how to do it ‚Äì even if you‚Äôre a beginner with no coding experience. In this tutorial, you‚Äôll learn: What the Notion API is and what it can do What an API is (in general) How to create a Notion API integration inside your Notion workspace How to send data to Notion via the Notion API How to create new pages in a Notion database via the Notion API How to read, understand, and actually use API documentation Lots of beginner-to-intermediate level JavaScript The Notion API already has great documentation, so here I‚Äôll be teaching you how to actually use the API by walking you step-by-step through a fun example project ‚Äì building a complete Pok√©dex in Notion! Many people have built Pok√©dexes in Notion by hand, but we‚Äôll build ours with zero manual data entry. Everything will be handled by the Notion API and a small JavaScript application that we‚Äôll build, which will automatically create an entry for each Pok√©mon. Here‚Äôs a look at the final product (you can also view this Pok√©dex directly on Notion): Each Pok√©mon has its own database entry with art, stats, description, and more. This is a great introductory project for learning how to work with the Notion API. And once you‚Äôve completed it, you‚Äôll have the knowledge and skill to do nearly anything else with the API. I have many more API tutorials planned, so if you‚Äôd like to get notified when they go live, join my Notion Tips newsletter. You won‚Äôt need any special software for this project ‚Äì we‚Äôll do everything in the browser using free tools. We‚Äôll even code in the browser (of course, you can use your own local code editor if you want). I‚Äôve also included deep explanations (in handy collapsible toggles) and external links that explain everything, so you‚Äôll be able to use this as a true zero-to-hero path for learning Notion‚Äôs API. There‚Äôs even a fully mapped-out learning path below. Every Pok√©mon will get its own Notion database entry that includes its stats (HP, attack, defense, etc), types, flavor text, artwork, and more. We‚Äôll accomplish this by building a simple JavaScript application that pulls all of this data from Pok√©API, a free and open-source resource with an immense amount of information on all things Pok√©mon. Our app will then format the data and send it to Notion. Note: This tutorial is meant for those who want to work directly with the Notion API using a programming language like JavaScript. If you‚Äôd like to work with the Notion API using no-code tools (like Make.com), check out this tutorial instead: How to Send YouTube Data to Notion (No Code) ‚Äì Notion API Tutorial A step-by-step guide for importing YouTube views, likes, and other statistics directly into Notion ‚Äì automatically, with no coding required. thomasjfrank.com What is the Notion API? To kick this off, let‚Äôs talk a bit about what the Notion API actually is. The Notion API is a set of tools that allow you to connect your Notion workspace to other apps and services outside of Notion (including apps you build yourself). Using the API, you could: Add new rows to a sales database in Notion when customers make purchases on your online store (using a platform like Lemon Squeezy or Shopify) Auto-transcribe voice notes using a service like Deepgram and send the transcript to a Notion page (tutorial on this coming soon! Join the newsletter to get notified.) Use Notion as a CMS for blog posts and display them on a custom-built website (like Braydon Coyer does ‚Äì though you can also use Notaku for this instead of building a site from scratch) ‚Ä¶and much more. The possibilities are basically endless. The Notion API provides endpoints for many major functions, including: Querying, creating, and updating databases Retrieving, creating, updating, and archiving pages Retrieving, creating, updating, and deleting blocks Appending child blocks to a parent block Listing workspace users and retrieving specific user information Creating and retrieving comments All API requests to the Notion API must be sent to the base URL https://api.notion.com, which you‚Äôll see as the first part of the listed endpoint for any action you‚Äôd want to take. For example, if you wanted to query a database, you‚Äôd send a POST request to: https://api.notion.com/v1/databases/{database_id}/query Notion requires all API requests to be made over HTTPS, and they must be authenticated properly. To make API requests to your workspace, you‚Äôll first need to create an integration (we‚Äôll cover this later), then give that integration explicit access to pages in your workspace. Notion also provides a JavaScript SDK for working with the API. As you‚Äôll see later in the tutorial, it‚Äôs easy to add this to your project, and it gives you access to handy methods that make API requests easy to construct in your code. If you‚Äôd like a more thorough overview, check out the official API documentation‚Äôs introduction. However, I think you‚Äôll get a better grasp on the API by actually working with it ‚Äì so let‚Äôs start doing that! If you do happen to want a primer or refresher on what an API is (in general), check out the toggle block below. What is an API? (General API Definition & Primer) APIs (Application Programming Interfaces) are sets of tools that allow different web services to talk to each other over the HTTP protocol. An API can allow one service to read data from another one; alternatively, it can allow one service to create new data at another service, update existing data, or even delete data. You‚Äôll often see another acronym used to describe these four potential operations: CRUD. Create Read Update Delete APIs are what allow you to posts Giphy GIFs directly in Slack. They enable those awesome link previews that you can create in a Notion page. And they are the many engines under the hood of connector tools like Zapier and Make.com. APIs typically consist of one or more URLs, to which your application can make HTTP(S) requests in order to do one or more CRUD operations. These URLs are often called endpoints. Note: You may have a conversation in the future about APIs with a nerd who will stress that you access URIs, not URLs. The distinction really does not matter here, but here‚Äôs an article on their differences if you‚Äôre curious. In most cases, APIs will have separate endpoints for each type of operation you can do. In other words, you‚Äôll almost never use the same endpoint to both read data and delete data. To see how an API actually works, let‚Äôs look at an example from PokeAPI ‚Äì the API we‚Äôll be working with later in the tutorial. One of PokeAPI‚Äôs endpoints is the pokemon endpoint, accessible via either one of these URL schemes: https://pokeapi.co/api/v2/pokemon/[pokemon name] https://pokeapi.co/api/v2/pokemon/[pokemon number] To access information about Charmander, you‚Äôd either use https://pokeapi.co/api/v2/pokemon/charmander or https://pokeapi.co/api/v2/pokemon/4. Since PokeAPI doesn‚Äôt require any special kind of authentication, you can even visit these URLs in your browser. Here‚Äôs a link you can try. However, you‚Äôll quickly realize that visiting that URL in the browser isn‚Äôt very useful; you‚Äôre just presented with a huge string of JSON. I‚Äôll cover JSON more thoroughly later, but you can watch this video now if you‚Äôre curious about what it is and how it works: However, if you make that request from a program, you can use additional code to process that JSON response and do really useful things. For example, you could write code that goes through all that data, pulls out the Pokemon‚Äôs name, and displays it. I show this example later in this guide (click here to jump to it), so I won‚Äôt repost it here. Of course, you can do much more than just display the Pokemon‚Äôs name. Once you have the information, you can do basically anything with it, so long as you know how to write the required code. That‚Äôs the power of an API: It allows you to do CRUD operations, and then combine them with any sort of code you want to write. The applications are basically limitless. To wrap up this small primer, I‚Äôll go over the five most common HTTP methods available to you when working with APIs. You‚Äôll see these all the time, so it‚Äôs good to be familiar with them. GET ‚Äì used for reading data from the application. It is read-only, so it has no risk of modifying any data. POST ‚Äì sends data to the application to create something new. PUT ‚Äì sends data to the application to update an existing resource. Contains a full updated copy of the resource. PATCH ‚Äì also updates an existing resource, but only contains the changes to be made instead of the entire updated resource. DELETE ‚Äì sends an instruction to the application to delete an existing resource. In many cases, your requests to a particular API will need to contain both the URL to be accessed and the method to be used. For example, if you want to create a page in Notion via the API, you‚Äôll need to access the https://api.notion.com/v1/pages endpoint using a POST request. You‚Äôll learn much more about APIs simply by working through this project. However, you can also get additional insight with the following resources. First, check out Fireship‚Äôs excellent (and short) overview: If you fancy long videos, you may also enjoy freeCodeCamp‚Äôs APIs for Beginners course (though you could also just watch the video version of this tutorial near the top of this page! ‚ÄúWhat If I Don‚Äôt Know How to Code?‚Äù In this project, we‚Äôll build our application using JavaScript. So if you have a basic understanding of JavaScript, you‚Äôll be more comfortable going through it. However, you don‚Äôt need to already know JavaScript to go through this tutorial. My entire goal with this tutorial is to help non-technical people dip their toes into the world of coding and working with the Notion API. I‚Äôve gone to great lengths to make it a truly comprehensive resource. Read this if you‚Äôre feeling anxious or overwhelmed about coding If you don‚Äôt know how to code ‚Äì if you get confused and overwhelmed at most coding tutorials ‚Äì I‚Äôve been in your shoes. At the beginning of last year (2022), I didn‚Äôt know how to code. I barely knew what an API was. I tried to watch tutorials, but I‚Äôd get confused when the creator would throw around terms like ‚Äúnpm‚Äù, ‚Äúnode.js‚Äù, and ‚ÄúAPI endpoint‚Äù without explaining them. Eventually, after much Googling and a lot of frustration, things started to click for me. Hopefully I can spare you some of that frustrated Googling (Froogling?) with this tutorial. As you‚Äôll see later, I‚Äôve added lots of toggles just like this one throughout the tutorial. The purpose of these is to give you an explanation for everything if you need it (and keeping these explanations in toggles lets more experienced coders skip past them easily). However, the best piece of advice I can give you for learning how to do is this: Run your code early and often. The true ‚Äúbest‚Äù way to learn how to code is to write a lot of code and to get lots of feedback. Luckily, you get feedback pretty quickly when you‚Äôre coding; when there‚Äôs an error, it‚Äôll be logged in your console or somewhere else. So dive in and get your hands dirty! To build any skill, you need 3 ingredients:1. Quality instruction2. Deliberate practice3. FeedbackMost people don't get nearly enough of #3 because they're too afraid of making mistakes or getting judged.Don't be one of them.Try often, get judged often, learn faster.‚Äî Thomas Frank (@TomFrankly) October 20, 2022 As we go through this tutorial, I‚Äôll include asides and primers about all of the tools and concepts we‚Äôll use. However, I‚Äôve also collected them all in this learning path toggle, enabling you to find them all in one place. Full Learning Path and Resource List This project involves working with several tools, two different APIs, and multiple JavaScript programming methods and concepts. Here, I‚Äôve compiled a full list of all of these things, along with some general resources you can use to learn JavaScript more comprehensively. I encourage you to use this as a reference, but don‚Äôt let its length intimidate you! If you follow the rest of the tutorial, I‚Äôm confident that you can get the entire project working even if you don‚Äôt understand everything right away. Once you do, you‚Äôll be in a better position to go back, dig into these resources, and really understand how they all fit together. Tools Used in This Project This is a list of the specific tools and libraries we‚Äôll use in this project. Since we‚Äôll be building in Glitch, you don‚Äôt really need to worry about their details ‚Äì Glitch will take care of most of the work for you. Glitch ‚Äì a free platform for building websites and web apps. Includes everything ‚Äì a full code editor, Node.js backend, npm package manager, terminal, and more. Node.js (automatically set up by Glitch) ‚Äì a runtime for JavaScript. Allows you to run JavaScript code outside of the browser, effectively enabling JavaScript to be used as a back-end (server-side) language. Learn more about Node here. Npm (automatically set up by Glitch) ‚Äì the Node Package Manager. Allows you to very easily include external code libraries in your project and use them. There are thousands of packages, including one for Notion‚Äôs API. Pok√©API ‚Äì an open-source API that enables you to access pretty much any data related to Pok√©mon that you could ever want. Notion API ‚Äì Notion‚Äôs official API, which allows you to read, write, update, and delete resources in a Notion workspace. Axios ‚Äì a free HTTP library that works with Node.js. This is the library we‚Äôll use to access the Pok√©API. Note: You can also build this project on your local machine. I‚Äôm using Glitch because it keeps things extremely simple and takes care of the setup. If you want to go the local route, you‚Äôll need a code editor like VS Code. You‚Äôll also need to install Node.js and npm. JavaScript Learning Resources These free courses and general-purpose resources are great for developing a full understanding of JavaScript. JavaScript Algorithms and Data Structures ‚Äì a full, free, and interactive JavaScript course by freeCodeCamp. This is, IMO, the best beginner resource for learning JavaScript. The course has hundreds of mini-lessons, each of which teaches a concept and then has you actually use it in the in-browser code editor. I have only done the Basic JavaScript and ES6 sections of this course, personally. You absolutely don‚Äôt need to finish the entire course to understand this tutorial. That Weird JavaScript Course ‚Äì Fireship‚Äôs great series of YouTube videos on JavaScript. Each is super-entertaining and does a great job at explaining JavaScript at a high level. The Modern JavaScript Tutorial ‚Äì an excellent written guide to JavaScript. The MDN Web Docs ‚Äì the definitive technical reference for JavaScript. I‚Äôll be linking to this many, many times in this guide. Beginner JavaScript Notes ‚Äì a free ‚Äúcliff‚Äôs notes‚Äù version of Wes Bos‚Äô paid Beginner JavaScript course. JSFiddle ‚Äì a tool for running small code snippets in your browser. Great for testing things out without much required overhead. Specific Concepts This is a list of the individual concepts and programming patterns/data structures we‚Äôll use in this tutorial. I‚Äôve listed the actual methods we‚Äôll use separately below. These have been ordered roughly by their difficulty, and I‚Äôve included a recommended understanding level for each. This isn‚Äôt a requirement; I think you can work your way through this tutorial and refer to these concepts as you go. It‚Äôs more an indication of my own perceived understanding of each concept at the time I built this project. Concept Recommended Understanding Variables ‚Äì const vs. let Full Data types ‚Äì string, number, etc Full Variable scope Medium Boolean values ‚Äì truthiness and falsiness Full Console logging Basic Arrays Basic Objects Basic Accessing object properties Full Functions Basic Conditional statements Medium Ternary syntax (for conditionals) Full For loops Full For‚Ä¶of loops Full Try/catch blocks Basic Requiring modules in Node.js Basic REST APIs Basic Template literals Basic Arrow functions Medium Object destructuring Medium Destructuring nested objects Full Regular expressions Basic Promises Basic Async/await Basic Specific Methods We‚Äôll use several built-in JavaScript methods throughout this tutorial. Below, I‚Äôve linked to the documentation for each one on the MDN Web Docs. These are ordered alphabetically. Array.prototype.find() Array.prototype.join() Array.prototype.map() Array.prototype.pop() Array.prototype.push() setTimeout() String.prototype.replace() String.prototype.split() String.prototype.substring() String.prototype.toUpperCase() How to Go Further If you finish this tutorial and want to push your skills even further, here are a few challenge ideas: Use the Notion API and database relations to display the evolution chain for each Pok√©mon. Display a table within each Pok√©mon‚Äôs page that contains each move that it can learn. Push the data from your Notion Pok√©dex to a static website (example: Daniel Shiffman‚Äôs Nature of Code site uses Notion as a CMS) Steal My Code and Create a Pok√©dex Instantly If you just want the code you‚Äôll need to build a Pok√©dex, you‚Äôre in luck! I‚Äôve built this project on Glitch, which is a free platform that allows people to build and share working web apps and sites. Here‚Äôs the direct link to my Glitch project. There‚Äôs a handy Remix feature that allows you to fully copy my Pok√©dex project and run it for yourself. All you‚Äôll need to do is create a free Glitch account, hit the Remix button, and follow the instructions in the README.md file. Even if you intend to follow this tutorial and build the project from scratch, I‚Äôd encourage you to first Remix mine and see how it works! One of the most powerful ways to learn faster is to prime your brain by skipping ahead and getting a preview of what you‚Äôre trying to accomplish. Even if you don‚Äôt fully understand it, you‚Äôll be setting your brain up to more readily understand each piece of the process once you go back and start it in earnest. I‚Äôve also meticulously commented my code, so you can work through it and get an explanation of how everything works. To get the script running: Create a Glitch account and hit the Remix button on my project. Duplicate my Pok√©dex Template into your Notion workspace. Follow the instructions in this section ‚Üí Create Your Notion Integration Follow the instructions in this section ‚Üí Set Your Environmental Variables Open the Terminal. Type node index.js and hit Enter. By default, the script will pull the first 10 Pok√©mon into your Notion database. To change this, modify the start and end variables (lines 65 and 66 in index.js, or 18 and 19 in index-nocomments.js). Full Project Code I‚Äôm also going to share the full code for this project right here. As we work through the tutorial, I‚Äôll include smaller code snippets that focus on the specific part we‚Äôll be building at that point. However, you may want to reference the project code in its entirety; when that happens, just open one of these toggles. Full Project Code (No Code Comments) Remember that you can view this code directly on my Glitch project as well! It is located in the index-nocomments.js file. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage(); } getPokemon(); const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Full Project Code (With Comments) Remember that you can view this code directly on my Glitch project as well! It it located in the index.js file. /* Bring in the external packages we'll be using. Axios is an HTTP client that makes working with APIs easier: https://axios-http.com/docs/intro Additionally, we bring in the Notion API client so we can make requests to it. */ const axios = require('axios') const { Client } = require('@notionhq/client') /* Create a new object 'notion' that gives our code access to the Notion credentials set up in the .env file */ const notion = new Client({auth: process.env.NOTION_KEY}) /* Create a blank array in which we'll store an object for each pokemon fetched from the PokeAPI */ const pokeArray = [] /* Create a function for making requests to the PokeAPI. We have to use an asynchronous function becuause axios.get() returns a Promise. Without using an async function, the rest of our code would run before axios gets a response from the PokeAPI. */ async function getPokemon() { /* Define start and end variables for the 'for' loop below. These numbers would usually be set directly in the for loop itself, but I've made them into their own variables so you can easily tweak them. They correspond to actual Pokemon numbers - e.g. 1 = bulbasaur. */ const start = 1 const end = 10 /* This 'for' loop will make the first set of requests to the PokeAPI. We're using a basic 'for (let i = num)' loop because i will correspond to specific Pokemon numbers. So if you only wanted the original 151, you'd set start at 1 and end at 151. */ for (let i = start; i <= end; i++) { /* Use the axios.get() method to make a GET request to the PokeAPI's 'pokemon' endpoint: https://pokeapi.co/docs/v2#pokemon This endpoint allows to to access MOST of the information we need. The only info we can't get from this endpoint is flavor text, generation #, and category (e.g. \"Flame Pokemon\"). For that info, we'll have to query the 'pokemon-species' endpoint later on. Note how we're using a template literal in order to pass our `i` variable's value into the URL. This is what will allow us to call PokeAPI for the correct pokemon on each run of the loop, e.g. https://pokeapi.co/api/v2/pokemon/4 (when i = 4) will get Charmander. */ const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { /* Pokemon have a variable number of types (some have 1, some have 2). The Notion API expects Multi-Select property selections to come in the form of an array of objects, so we need to create an array of objects that we can pass when we're setting the 'Type' Multi-Select property's values. First, we store the types array from PokeAPI in the typesRaw variable. */ const typesRaw = poke.data.types /* Now we'll create a blank array that will contain our type objects, which will be formated specifically so they'll work with the Notion API. */ const typesArray = [] /* Create a for...of loop that will loop through all the elements of typesRaw. For each one, we'll create an object 'typeObj' which is formatted as needed for the Notion API, which which contains ONE of the Pokemon's types. Since the number of loop iterations is defined by the length of the typesRaw array, we'll end up with a new array (typesArray) that contains an object for each of the Pokemon's types. E.G. - Butterfree is Bug-type and Flying-type, so its typesArray will have two elements. */ for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } /* Add the object onto the end of typesArray */ typesArray.push(typeObj) } /* The PokeAPI returns very basic formatting for Pokemon names - e.g. 'Mr. Mime' is formatted as 'mr-mime'. We want to show names with proper punctuation and capitalization in Notion - e.g. 'Mr. Mime'. This is also important for auto-generating links to Bulbapedia, where more information about each Pokemon can be found (this is a basic Pokedex that doesn't include move information, locations, etc.) To accomplish this, we're running the poke.data.species.name object through several functions. First, the split().map().join() combo capitalizes the first letter of each word - e.g. 'mr-mime' becomes 'Mr Mime'. When methods are chained like this, they are executed left-to-right. So the return value of split() is fed into map(), and map()'s return value is fed into join(). Then, we run that result through a gauntlet of replace() calls to deal with edge case Pokemon like Type: Null, Ho-Oh, Mr. Mime, and Nidoran‚ôÄ - all of which include punctuation or symbols. Each replace() call looks for a regular expression match and replaces the first one it finds with the next argument. */ const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") /* Define a variable that holds the bulbapedia URL for the Pokemon. Bulbapedia has a very standardized URL scheme for Pokemon, so all we need to do is pass in the processedName variable and then replace any space characters it contains with underscores. All other special characters are left in the URL - even :,√©,-,etc. Example URL: https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pok√©mon) */ const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pok√©mon)` /* Here we're defining a variable for the sprite using ternary syntax (? and : ) to create a conditional statement. We need to do this because certain Gen VIII Pokemon were introduced in Pokemon Legends: Arceus and do not have a sprite. The PokeAPI has an 'official-artwork' image for EVERY Pokemon, so we'll set the value of sprite to 'official-artwork' if a 'front_default' sprite doesn't exist. (!poke.data.sprites.front_default) is a Boolean check; if the value of this object is null, it'll evaluate to false. */ const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default /* Now we'll construct the object that will hold all of the data about this Pokemon. If you recall, we aren't able to pull generation, flavor text, or category from PokeAPI's 'pokemon' endpoint, so we'll add those to this object later. For now, each object property is being set to the value of the corresponding property returned from our first PokeAPI call. Note how ['official-artwork'] is defined differently. Property key names with dashes or spaces must be called using 'bracket notation' rather than 'dot notation'. */ const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } /* Send a log to the console with each fetched Pokemon's name. Doing this will allow the console to show activity the whole time the script is running. Without it, you'll just see a blank spot in your console while the script takes minutes to run. */ console.log(`Fetched ${pokeData.name}.`) /* Push our pokeData object onto the end of the pokeArray array. This is done each time our loop executes, resulting in an array full of objects - one for each Pokemon that you included in the loop (using the start and end numbers). Each object will look just like the pokeData object definition above, except the properties will contain actual information. If you want to see how these look, add console.log(pokeData) above this line. */ pokeArray.push(pokeData) }) .catch((error) => { /* if axios.get() fails and throws an error, this catch block will catch it and log it in the console. */ console.log(error) }) } /* We now need to call another PokeAPI endpoint to get three more pieces of information about each Pokemon: - Flavor text (e.g. \"Spits fire that is hot enough to melt boulders. Known to cause forest fires unintentionally.\") - Generation (e.g. I, II, III...) - Category (e.g. \"Flame Pokemon\", \"Owl Pokemon\") These must be obtained from the pokemon-species endpoint (https://pokeapi.co/docs/v2#pokemon-species) We now have all of the Pokemon we'll sent to Notion in pokeArray, so we'll now use a for...of loop to loop through that array, get the 'species' info for each element from PokeAPI, and add each piece of info to that pokemon's object in pokeArray. */ for (let pokemon of pokeArray) { /* Just like we did above, here we use axios.get() to call the PokeAPI endpoint we want. Note that this time we're passing the pokemon.number property from the current element of pokeArray (which is stored in the pokemon variable created in this loop) into the PokeAPI URL. */ const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { /* Create a variable to store the pokemon's flavor text. Depending on the pokemon, PokeAPI will have a differing number of flavor text options. These are all stored in an array called flavor_text_entries, and the English-language flavor text might be at any one of the indexes. See for yourself: Go to pokeapi.co and enter 'pokemon-species/charmander' in the testing box. Array index 0 (the first one) contains English-language flavor text. However, try 'pokemon-species/cramorant' and you'll see that the English flavor text doesn't show up until Array index 7. So instead of calling a specific array index, we have to search deeply inside the array's objects to find the one that has a 'language' object, which itself contains a 'name' property with a value of 'en'. To accomplish this, we call the find() method on the flavor_text_entries array, which returns the first array element that satisfies a test condition we'll set up though a function. That function is name === 'en'. To make sure the value of the nested 'name' property is fed into the function as the 'name' varible, we do what is called nested object destructuring. ({language: { name }}) tells find() that for each array element, go into its language object, then into the name property nested within, and pass name's value as the variable for the function. find() returns the full array element that matches the test condition, so we then tack on `.flavor_text` to get the value of its flavor_text property. Finally, we pass the found value through replace(/\\n|\\f|\\r/g, \" \") to replace any newline characters with spaces, resulting in a single line of flavor text. */ const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") /* Here we do the exact same thing as was done with the flavorText variable, except for the 'genus' property, which is PokeAPI's term for the category - e.g. \"Flame Pokemon\" */ const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus /* Now we get the pokemon's generation. It is returned in this format: 'generation-i' - but we want it to simply be 'I', so we run the result through split(/-/), which splits the string into an array using the dash character (-) as the divider. Then we use pop() to \"pop\" the last element of that array off of the array and return it - this will always be the generation number in Roman numerals, e.g. 'iv'. Finally, we pass that value through toUpperCase() to capitalize it - e.g. 'IV'. */ const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() /* Now we add our three new pieces of information to the current pokemon's object by creating three new properties within that object, and then assigning them the values from our three variables above. Note how pokemon['flavor-text'] uses bracket notation; this is required when an object property name has or will have spaces, dashes, or other special characters in it. Dot notation can only be used when property names contain letters, numbers, and underscores. */ pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation /* Add a log entry in the console each time this information is fetched from PokeAPI. */ console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { /* Log any errors thrown by axios.get(), just as in the previous loop block. */ console.log(error) }) } /* Once both loops have finished running, we call the createNotionPage() function which is defined below. It's important to note that we're calling this function within the getPokemon() function. Since getPokemon() is an async function, calling createNotionPage() outside of it (in the global context) will cause createNotionPage() to run before getPokemon() can finish construcing its array of objects. Calling it here forces createNotionPage() to run only after our two loops have completely finished fetching and formatting the data from PokeAPI. */ createNotionPage(); } /* Here's where we actually call the getPokemon() function. When you type `node index.js` in the Terminal to run this script, it immediately runs this function, which kicks off everything else. Note how we've defined additional functions below this; these are totally fine to exist below this line because JavaScript \"hoists\"function definitions to the top when it actually runs a .js file. Look up \"JavaScript Hoisting\" to learn more about this. */ getPokemon(); /* Create a \"wait\" function to comply with Notion API rate-limiting. The Notion API only allows ~3 requests per second, so after we create each new page in our Notion database, we'll call this sleep function and have it wait for 300ms. This will ensure that our app doesn't try to send data to Notion too quickly, which would cause our calls to eventually fail. */ const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; /* Create a function for sending our data to the Notion API. As with getPokemon(), this function has to be async because it is using axios.get(), which is an asynchronous method that returns a Promise first. Therefore, we must await it, and to do that it has to be inside an async function. */ async function createNotionPage() { /* Here's our main loop for the process of sending data to Notion. We already have our array of pokemon objects (pokeArray), so we can use a for...of loop to iterate through it. For each element, we'll construct a new object that formats the data in the way Notion wants. Then we'll create a new page in our Notion database with that data. */ for (let pokemon of pokeArray) { /* Here we'll construct the data object that we'll send to Notion in order to create a new page. This object defines the database in which the page will live (the \"parent\") and sets its icon, cover, and property values. It also adds a few blocks to the page's body, including the flavor text and a link to the pokemon's Bulbapedia page. I won't verbosely comment every piece of this object definition. Instead, I'll encourage you to study it and also point you to a few reference pages that you'll fine invaluable for working with the Notion API: - Property Values: https://developers.notion.com/reference/property-value-object - Block Objects: https://developers.notion.com/reference/block - Create a Page: https://developers.notion.com/reference/post-page Note how, for each block, we're setting the relevant property values to the variables in our pokemon object (except for the database ID, which is set by process.env.NOTION_DATABASE_ID). It's also useful to note that EVERYTHING in Notion is a block. The 'data' object will end up being a block that is recognized by Notion as a page due to the 'parent' value we're giving it (a database), and due to the fact that we're using the notion.pages.create() method to create it. However, you can see below that this block has children, which are blocks that will show up as its page content. Note that you can create 'block children' under nearly any block - not just under a page! See more: https://developers.notion.com/reference/patch-block-children */ const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } /* Here we call our sleep() function, passing it a value of 300 so that the loop \"sleeps\" for 300ms before going onto the next cycle. This ensures that we respect the Notion API's rate limit of ~3 requests per second. */ await sleep(300) /* Finally, we actually create the new page in our Notion database. First, we add a log item to the console for our own benefit. Then we call the notion.pages.create() function, which creates a new page in our database. We pass it our data object (defined above), which contains all of the necessary information. Finally, we store the Notion API's response in the response variable, and log it. */ console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } /* When the entire process is done, this will simply print \"Operation Complete\" in the console. */ console.log(`Operation complete.`) } Bonus: My developer‚Äôs take on the getPokemon() function As I mentioned above, I only learned how to code in JavaScript this year, so my skills are not well-honed. Fortunately, that doesn‚Äôt matter much. These days, computers are so powerful that simple applications can be built many ways. Even if the code isn‚Äôt perfectly-optimized, it‚Äôs ‚Äúgood enough‚Äù so long as it gets the job done and handles errors well. Still, there are often better ways to do things. To show you an example, below I‚Äôm sharing my full-time developer Eli‚Äôs take on the getPokemon() function. He readily admits that his code is less readable than mine, but it does result in a 40% reduction in code length. In professional setting, my code above would probably get refactored to look more like his. async function getPokemon() { const replacer = (str) => { const n = { \"Mr M\": \"Mr. M\", \"Mime Jr\": \"Mime Jr.\", \"Mr R\": \"Mr. R\", \"mo O\": \"mo-o\", \"Porygon Z\": \"Porygon-Z\", \"Type Null\": \"Type: Null\", \"Ho Oh\": \"Ho-Oh\", \"Nidoran F\": \"Nidoran‚ôÄ\", \"Nidoran M\": \"Nidoran‚ôÇ\", \"Flabebe\": \"Flab√©b√©\", } let pn = Object.keys(n).find((o) => str.includes(o)) return pn ? str.replace(pn, n[str]) : str } let urls = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=50`) .then((r) => r.json()) .then((d) => d.results.map(u => u.url)) let base = await Promise.all(urls.map(async (url) => { let d = await fetch(url).then((r) => r.json()) let name = replacer(d.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1) })[0]) return { name: name, number: d.id, types: d.types.map((t) => t.type.name), height: d.height, weight: d.weight, hp: d.stats[0].base_stat, attack: d.stats[1].base_stat, defense: d.stats[2].base_stat, specialAttack: d.stats[3].base_stat, specialDefense: d.stats[4].base_stat, speed: d.stats[5].base_stat, sprite: d.sprites.front_default, artwork: d.sprites.other['official-artwork'].front_default, bulbURL: `https://bulbapedia.bulbagarden.net/wiki/${name.replace(' ', '_')}_(Pok√©mon)`, } })) let flav = await Promise.all(base.map(async (p) => { let d = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${p.number}`).then((r) => r.json()) return { flavorText: d.flavor_text_entries.find(({language: {name}}) => name === \"en\"). flavor_text.replace(/\\n|\\f|\\r/g, \" \"), category: d.genera.find(({language: {name}}) => name === \"en\").genus, generation: d.generation.name.split(/-/).pop().toUpperCase() } })) return base.map((b, i) => ({...b, ...flav[i]})) } ‚Äã getPokemon().then((r) => { createNotionPage(r) }) What You‚Äôll Need to Get Started To successfully complete this tutorial, you‚Äôll need a few things: A Notion account. Even the free tier is able to work with the API! A Notion database that you‚Äôd like to use for your Pok√©dex (you can start with my template below). An integration in your Notion account. We‚Äôll create this in the first step of the tutorial. A free Glitch account. This is the platform where we‚Äôll build and run the application. Don‚Äôt Want to Use Glitch? You can also build and run this project locally on your own computer. Likewise, you could do things like the pros, pushing your code to Github and then deploying it to a company that can host Node.js apps such as Vercel. The reason I‚Äôve chosen to build this project on Glitch is because it gives you a complete starting point for free. We can code directly in the Glitch editor and then run our code directly in Glitch‚Äôs terminal. If you‚Äôd rather build this project locally, here are the prep steps you‚Äôll need to take: Get a code editor ‚Äì I recommend VS Code, as it has a built-in terminal for running your code along with many extensions and a huge community. Install Node.js and npm. The Node.js LTS installer should install both. Refer to this guide to see other ways to install (included the recommended-yet-harder nvm method), and to see how you can check that node and npm are indeed installed on your machine. Follow this guide to set up VS Code for a Node.js project and to move into the correct directory where you want to build your app. Once you have your project set up with a package.json file, type npm install axios in the terminal and hit Enter to add the Axios package to your project. It should show up in the package.json file under dependencies. Likewise, type npm install @notionhq/client in the terminal and hit Enter to install the Notion SDK package. Just like on Glitch, you‚Äôll need to create a .env file in your project and add your authentication details to it. However, Glitch automatically takes care of a few things you‚Äôll have to do manually here. First, type npm install dotenv and hit Enter in the terminal to install the dotenv package and add it to your package.json. (Glitch includes this by default.) In your project‚Äôs root directory (the same top-level folder where package.json is contained), create a filed called .env (no other file extension). Add your environment variables to this file and hit Save. Replace these default values with your Notion integration key and your target database‚Äôs ID. Refer to the Create a Notion Integration section for more detail on this. NOTION_KEY = blargablargblarg NOTION_DATABASE_ID = blargblarg At the top of your index.js file, you‚Äôll also need to include: require('dotenv').config() This will allow your app to access the variables defined in your .env file. You can test this by adding these lines to your index.js file, then running node index.js in the terminal: console.log(process.env.NOTION_KEY) console.log(process.env.NOTION_DATABASE_ID) If you plan on pushing your code to Github or otherwise using git for version control, you‚Äôll also want to create a .gitignore file in your project‚Äôs root directory. Then, add .env to that file and commit your .gitignore to your repo (see this more comprehensive guide for more detail): .env From there, you can follow the rest of the instructions in this tutorial. If you‚Äôd like to learn more about .env files and running things locally, see this guide: How to Use Environment Variables in Node You can use any database you want to create your Pok√©dex, but if you‚Äôd like a head start, you can use this free Pok√©dex Notion template I‚Äôve created for you. The template is an exact copy of my public Pok√©dex, minus all the actual Pok√©mon. It comes with all the properties and views pre-configured, so you can skip all of the database setup and get to coding. Since I‚Äôm providing this template, I won‚Äôt cover the database set up in this tutorial. However, if you want to learn more about setting up Notion databases, check out my beginner‚Äôs guide to Notion databases. You may also find my complete Notion formula guide helpful for understanding some of the formulas in this template! Tutorial Overview Before we start coding, let‚Äôs do a quick overview and cover what we‚Äôll be accomplishing. We know that we want to pull information about each Pok√©mon from Pok√©API and then create a new page in our Notion database for each Pok√©mon ‚Äì but how exactly will we do that? First, the prep work: We‚Äôll set up our Pok√©dex database on Notion, create a Notion API integration, and ensure the integration is able to edit the database (covered in the very next section). Once that‚Äôs done, we‚Äôll build the script that will actually execute the process of getting the data and sending it to Notion. Let‚Äôs break down the process. Don‚Äôt worry if you don‚Äôt know what GET and POST requests are ‚Äì I‚Äôll explain them as they come up! For each Pok√©mon, we‚Äôll send a GET request to Pok√©API. This will contain the URL that maps to the specific Pok√©mon we want information about ‚Äì e.g. https://pokeapi.co/api/v2/pokemon/4 (you can paste that link directly in your browser to see the response). Pok√©API will accept our GET request if it is formatted correctly. Pok√©API sends back a response that contains all of the Pok√©mon data we want, plus other meta info. The response contains way too much data, and it‚Äôs not always formatted perfectly. So we‚Äôll do some work to process the response directly on our web server (Glitch/Node.js). For each Pok√©mon, we‚Äôll create a custom JavaScript object called pokeData that will contain all the info we‚Äôll need. We‚Äôll do the work to extract and format the data from Pok√©API and add it to the pokeData object ‚Äì including name, height, weight, base stats, artwork, etc. We‚Äôll add each pokeData object to an array called pokeArray. Now we‚Äôll make a POST request to the Notion API for each Pok√©mon within pokeArray. Assuming our request is formatted correctly and authenticated, Notion will create a new page within our Pok√©dex database, setting property values and populating the page content with the information we sent over. Finally, the Notion API will send back a response that we‚Äôll simply log. Here‚Äôs a graphic that shows the entire process visually (you can also view this directly on Whimsical): Now that you‚Äôve got a map in your head for what we‚Äôll be building, let‚Äôs build it! Create a Notion Integration The first thing we‚Äôll do is create an integration within your Notion account. This integration will allow you to work with the Notion API and make changes to your workspace. Note: You‚Äôll also find these instructions in the getting started guide within the Notion API docs. We‚Äôll be referencing these docs a lot later on, and I highly recommend getting familiar with them if you plan on building more Notion API integrations! To start, make sure you‚Äôve duplicated my Pokedex template into your Notion workspace. This template contains all the properties and views you‚Äôll need. Next, you‚Äôll need to create an integration in your Notion account. Click here to go directly to the ‚ÄúMy Integrations‚Äù area of your account. Alternatively, you can find this page by going to Settings & Members within the Notion app, then navigating to My Connections ‚Üí Develop or Manage Integrations. Click New Integration. Fill out the Basic Information for your integration. You can leave most of the settings at their defaults, but set these as needed: Name: Any descriptive name. I‚Äôll use ‚ÄúNotion Pokedex Integration‚Äù in this guide. Associated workspace: Choose the workspace you want this integration to work with (aka the one that contains your Pokedex database). User capabilities: Set to no user infomation. This project doesn‚Äôt need user info, and it‚Äôs a good practice to limit integrations to only the capabilities they need. Click Submit. Once the integration has been created, you‚Äôll see a field where you can show your internal integration token. Copy this token to your clipboard; you‚Äôll need it when we start setting up the project in Glitch. Important: Keep this token secret. As this tutorial will show you, an integration token allows external tools and scripts to make changes to your Notion workspace. Show the token, then copy it to your clipboard. Additionally, note where it says, ‚ÄúOnly works with [your workspace name] workspace‚Äù. If you want to work with another workspace, you‚Äôll need to create another integration. You‚Äôll also be able to see that your integration is set as Internal rather than Public. This is what you want! I‚Äôm just pointing it out in case you‚Äôre unsure which one should be selected. Add Your Integration to Your Pokedex Database Before we can move on, we need to give your integration permission to edit your database. To do that, head to your Pokedex: Click the ‚Ä¢‚Ä¢‚Ä¢ icon in the top-right corner. Find the Connections sub-menu. Find and select your integration. You‚Äôll see the following message: Notion Pokedex Integration will have access to this and all child pages. Continue? Click confirm. Once connected, you‚Äôll be able to navigate back to that Connections menu and see your connected integration‚Äôs permissions for this page. Note that any child pages/databases of the current page will also be accessible to the integration. Now that your integration can modify your Pokedex page, we can move onto the next step! Create Your Glitch Project We‚Äôll be writing our actual code on Glitch, a free platform that lets you built and run websites and apps in a single, easy-to-use interface. To get started, head to Glitch and create a free account. Next, click New Project. You‚Äôll be given the choice of a few different starter apps, but you should actually click Find More, as the one we want isn‚Äôt shown here. From this new page, find the Hello Node! starter project and choose the blank version. While you can use the regular Hello Node! app (and I do in the video tutorial above), it comes with a bunch of extra stuff you don‚Äôt need. It also doesn‚Äôt come with a .env file by default, whereas the blank version does. Select the blank version of the Hello Node! app. Once done, Glitch will set up a new project that is pre-configured to run Node.js, the server runtime that will allow us to run JavaScript code directly from the terminal (instead of needing to run it in web page). What is Node.js? Node.js is a backend runtime environment that allows JavaScript to be executed outside of the browser. Originally, JavaScript was designed to be a programming language that could only run in a web browser. This was initially done for security reasons back when JavaScript was first being built in the mid-1990‚Äôs. Over time, people started using JavaScript for more and more purposes. What was once meant to be a simple scripting language started getting used to build complex web applications. In 2009, Node.js was released in order to allow developers to write the JavaScript syntax they were familiar with in other contexts. Node allows JS code to do all sorts of back-end tasks, like processing user data, reading and writing to file systems, and more. If you want to learn more about Node.js, watch this video: The Glitch app gives you a complete development environment. Here‚Äôs a quick tour, going over the most important parts: The editor is where you‚Äôll write your code. As you can see below, it can also render markdown files (.md files) with formatting. The sidebar gives you access to all of the files and assets within your project, and allows you to create more. You can also access your project settings here. The terminal will allow you to run your code. This is where we‚Äôll run your Pokedex script. The main thing you should do right now is create an index.js file. This will be the file where we write our JavaScript code in the next steps. To do this: Click the + icon next to Files in the sidebar. Name the file index.js. Click Add This File. For now, you can leave this file blank. We‚Äôll come back to it soon and start coding, but before that, we need to set up our environment variables and import a couple of packages. Let‚Äôs go! Set your Environment Variables For the script to be able to send Pokemon data to your Notion workspace, you‚Äôll need to provide it with two pieces of specific information: Your internal integration token (set when you created your Notion integration earlier) The database ID for your Pokedex database Both of these are private pieces of information that shouldn‚Äôt be shared. When developing Node.js apps (which we‚Äôre doing here), there‚Äôs a best practice for storing private pieces of information with which the program needs to directly interact, and that‚Äôs to store them in as environmental variables in a .env file. So that‚Äôs exactly what we‚Äôll do now, and we‚Äôll start by gathering these pieces of information. What is a .env file? A .env file is a special file that contains environmental variables. These are often variables that hold sensitive information, such as authentication tokes for API access. .env files are never pushed to version-control systems like git, meaning that programmers and teams can use services like Github and even share open-source code without exposing sensitive information. If you want to learn more, check out this video: You should already have your internal integration key from when you set up your Notion integration; if not, head back to the My Integrations page and copy it. Next, we‚Äôll get your database ID. Obtain Your Database ID Your database ID can be found within the URL of your Notion database. To find it, first navigate to your source database in Notion. If you‚Äôre using my Pokedex template, note that the template is a normal page that contains the source database. Click the Open as full page button on the database view to access the source database. Once you‚Äôre looking at your source database, copy its URL by going to the ‚Ä¢‚Ä¢‚Ä¢ menu and clicking Copy Link. Alternatively, you can use the shortcut ‚åò/Ctrl + L. Within your database‚Äôs URL, your database ID is the string of characters after the final / and before the query symbols ?v=. // Full URL https://www.notion.so/thomasfrank/c9cdd00ed7314f9497f4ab23e9fa0bdd?v=2d6e86289d304cd1ab5ba08a0d9ec1b4 // Database ID c9cdd00ed7314f9497f4ab23e9fa0bdd Copy your database ID and paste it in a temporary holding place along with your internal integration token. P.S. ‚Äì if you don‚Äôt have clipboard history enabled on your computer, now‚Äôs a great time to turn it on! On Windows, just hit ‚äû Win + V. If you‚Äôre on a Mac, get Raycast; it‚Äôs an incredibly powerful launcher tool with built-in clipboard history. Edit the .env File Now that you have your internal integration token and database ID, head back to Glitch. Your project should already have a .env file listed in the sidebar. If not, click the + one more time and create a file called .env. Add these two environmental variables. Ensure the labels are NOTION_KEY and NOTION_DATABASE_ID, but replace the example values with your own. NOTION_KEY=secret_LykgP0z2wvrYCiqAaWKu3j5uSokRvosbsqgWaHIjLw6 NOTION_DATABASE_ID=c9cdd00ed7314f9497f4ab23e9fa0bdd As the dialogue box pictured above will tell you, these environmental variable values will be visible to you and anyone else you specifically invite to edit your project. However, anyone else will merely see the variable names ‚Äì not the values. That means you‚Äôll be able to safely let people view (or even Remix) your project without revealing them. To learn more about how .env works in Glitch, check out their article on Adding Private Data. Add Your NPM Packages The script we‚Äôre building uses two external libraries that do a lot of the heavy lifting. These include The Axios HTTP library The Notion API‚Äôs JavaScript SDK Once we start coding, I‚Äôll explain what these libraries actually do in more detail. For now, we simply need to bring them into our project and set up index.js so that our code can access and use them. Luckily, bringing these libraries into our project is very easy. Node.js comes with a package manager called npm, which lets developers quickly import packages (which contain these libraries) into their projects. Normally, a developer would install a package by typing npm install into the terminal along with the name of the package. For example, you could install the dadjoke library into your project by typing: npm install dadjoke You can actually do this on Glitch, and I‚Äôll invite you to do so and then type dadjoke in the terminal to see what happens. For clarity: You do not need the dadjoke library for this project; it‚Äôs just a very simple library that you can easily use to test the npm install process. However, Glitch provides an even easier way to install packages. Simply head to your package.json file and click Add Package. From there, you can search for packages and click them to install. Search for and install the following packages. I‚Äôve linked their npm pages below in case you need to double-check that you‚Äôre installing the right ones. axios @notionhq/client Once done, you‚Äôll see that your package.json file has been updated with new depencies: \"dependencies\": { \"fastify\": \"^4.4.0\", \"handlebars\": \"^4.7.7\", \"@fastify/view\": \"^7.1.0\", \"@fastify/static\": \"^6.5.0\", \"@fastify/formbody\": \"^7.0.1\", \"axios\": \"^1.3.1\", \"@notionhq/client\": \"^2.2.3\" } Aside: NPM Packages Can Break (Here‚Äôs What to Do) As of this writing (Februrary 2023), both of the npm packages we‚Äôll use in this project are in a working state. However, I actually went through the experience of dealing with a broken npm package while making this tutorial. After I filmed the video version in November 2022, Axios had a buggy update that broke its ability to make API calls. To make my script work, I had to manually roll Axios back to the 1.1.3 version. Today, Axios‚Äô current 1.3.1 version is working ‚Äì so you (hopefully) shouldn‚Äôt have any troubles with it as you go through this tutorial. That said, if you find that Axios ‚Äì or any package ‚Äì isn‚Äôt working in the future, here‚Äôs what to do. First, check the package‚Äôs Github Issues page to see if others are posting about a potential bug. For example, here‚Äôs the Issue I ran into with Axios (you can even see a comment from me in this thread). Checking for Issues on Github can help you confirm that there‚Äôs a problem with the package itself, rather than your code. Second, simply roll back to an earlier version of the package and see if that works. Axios‚Äô 1.2 version broke my script, but I was able to roll back to 1.1.3 to get it working again. In Glitch, this is incredibly easy ‚Äì just go into package.json and change the version number of the package. Refresh the page, and Glitch will take care of the downgrade in the background. Note: If you want to ‚Äúlock in‚Äù a specific version of the package, take care to remove the caret ^ symbol ‚Äì read up on SemVer if you‚Äôre curious about that. E.g. 1.1.3 instead of ^1.1.3. Elsewhere (such as your own machine with Node.js installed), run the npm install command with the version you want specified, like so: npm install [email protected] Even if the package is already installed with a later version, this command will replace it with the older version you specify. More detail on how to do this can be found at this post: How to downgrade an installed npm package ‚Äì Nathan Sebhastian Learn how you can downgrade an npm package to rollback breaking changes sebhastian.com Now you‚Äôve got the packages installed in your project. Before you can use them, however, you‚Äôll need to ‚Äúrequire‚Äù them within your index.js file. Head over to index.js and add the following lines to the top of the file (which should currently be blank): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) For our purposes, it‚Äôs not incredibly important to know exactly how require() works. But if you‚Äôre curious, here‚Äôs a great article: Everything you should know about ‚Äòmodule‚Äô & ‚Äòrequire‚Äô in Node.js by Srishti Gupta Everything you should know about ‚Äòmodule‚Äô & ‚Äòrequire‚Äô in Node.js Modules > Node.js treats each JavaScript file as a separate module. For instance, if you have a file containing some code and this file is named xyz.js, then this file is treated as a module in www.freecodecamp.org Make Your First Call to Pok√©API We‚Äôre finally ready to start coding! In this step, we‚Äôll make our first call to PokeAPI and log the name of a Pokemon in the Glitch terminal. First, let‚Äôs look at how this actually works. In this Replit embed, I‚Äôve created a very simple script that will call PokeAPI once. Go ahead and hit Run to see what happens. If everything went smoothly, you should see bulbasaur displayed in the terminal. Here‚Äôs a look at the code: const axios = require('axios') async function getPokemon() { await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) } getPokemon() This very simple script does three things: Uses require('axios') to make the axios library‚Äôs methods available for use in the script Defines an asynchronous function getPokemon(), which will call PokeAPI and console log the name of the first pokemon Calls the getPokemon() function in order to run it Once the function is called, the code inside it runs. Here, we‚Äôre only doing two things: Using the axios.get() method to call a specific resource within PokeAPI. In this case, it‚Äôs the first entry in the pokemon resource, which contains data about bulbasaur. Once we get the response, we use JavaScript‚Äôs built-in console.log() function to display the pokemon‚Äôs name in the terminal PokeAPI returns JSON data, so we access specific pieces of that data by using dot notation. To get the name, we have to traverse the JSON data tree. Property accessors ‚Äì JavaScript | MDN Property accessors provide access to an object‚Äôs properties by using the dot notation or the bracket notation. developer.mozilla.org PokeAPI is mainly a learning tool, and they actually have a great interface for exploring the API‚Äôs data right on their homepage. I‚Äôd encourage you to check it out if you want to understand the JSON data structure found in the response a bit better. Here‚Äôs a screenshot showing the name that we‚Äôre accessing: Here, you can see that there‚Äôs a species object, which contains a property called name. (There‚Äôs also a separate name property as well, but I‚Äôve found that the species.name property is more reliable to use). Note: You can see all of the properties accessible via this pokemon endpoint at the endpoint‚Äôs page in the official Pok√©API docs. Of course, in the code above, we‚Äôre accessing: console.log(poke.data.species.name) So where does the poke.data part come into play? poke is a variable that we declare, which holds the entirety of the response from PokeAPI. Let‚Äôs look at the API call: await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) I‚Äôll cover the await part in a second; right now, let‚Äôs look at the part that says .then((poke) => ... and break that down. The code axios.get(`https://pokeapi.co/api/v2/pokemon/1`) calls the PokeAPI to get the resource stored at https://pokeapi.co/api/v2/pokemon/1. Once the call is finished, we need to do something with the response. The .then() function allows us to do this. Within it, we‚Äôre both defining and calling a function (using an arrow function) which stores the entire response in a variable called poke. It then uses console.log() to log the poke.data.species.name property‚Äôs value. Using .then() just keeps our code nice and concise. We could re-write it using an old-school function declaration and get the same result: async function getPokemon() { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/1`) log(poke) } function log (poke) { console.log(poke.data.species.name) } But this is more verbose, so using .then() is preferable. Next, let‚Äôs address the data property in poke.data.species.name. We don‚Äôt see that on the PokeAPI website‚Äôs example response, so where is it coming from? As it turns out, the response we get from PokeAPI contains a lot of information. We get a status code, headers, config information, and a lot of other information that we generally don‚Äôt need to worry about (but that‚Äôs good to have for debugging in case something goes wrong). The entire response is contained within an object, and inside that object there is another nested object called data. This data object contains all the information that you can see on the PokeAPI homepage‚Äôs sample response. More on objects: Objects javascript.info In the accordion block below, I‚Äôve included the entire response that PokeAPI returns for this API call. Take a second to look through it and identify the data object. Full PokeAPI Response (Sample) This is the entire response returned by PokeAPI for this API call. Find the data object within it to see how we‚Äôre accessing the pokemon‚Äôs name (line 238). Note that, by default, console.log() won‚Äôt fully show the details of objects that are nested many layers deep. For that reason, most of the information in the data object is simply labeled [Object]. However, when you access specific properties in your code, you‚Äôll get the actual values. For example, poke.data.species.name has a value of bulbasaur, which we were able to see in the console in the Replit embed above. { status: 200, statusText: 'OK', headers: AxiosHeaders { date: 'Fri, 09 Dec 2022 20:29:25 GMT', 'content-type': 'application/json; charset=utf-8', 'transfer-encoding': 'chunked', connection: 'close', 'access-control-allow-origin': '*', 'cache-control': 'public, max-age=86400, s-maxage=86400', etag: 'W/\"359f3-JlmmuiyGZkKyOFlSvLzln1IpB6Q\"', 'function-execution-id': 'tkmw3o8u9p36', 'strict-transport-security': 'max-age=31556926', 'x-cloud-trace-context': '3dba91851bd1a57c6ea5dade1ac7e883', 'x-country-code': 'US', 'x-orig-accept-language': 'en-US', 'x-powered-by': 'Express', 'x-served-by': 'cache-iad-kiad7000067-IAD', 'x-cache': 'HIT', 'x-cache-hits': '1', 'x-timer': 'S1669043889.601956,VS0,VE1', vary: 'Accept-Encoding,cookie,need-authorization, x-fh-requested-host, accept-encoding', 'alt-svc': 'h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400', 'cf-cache-status': 'HIT', age: '51296', 'server-timing': 'cf-q-config;dur=6.9999987317715e-06', 'report-to': '{\"endpoints\":[{\"url\":\"https:\\\\/\\\\/a.nel.cloudflare.com\\\\/report\\\\/v3?s=4KTK4BOb7zSytazr61FEYksT%2BVDQfvoEhzU6Ph%2FYbVr%2Bc9ZgsACueHvhFQy5%2BsijYeXyqKyD3Vo7sBe%2FieNvBWwCdvO%2B55koSkx9YXvyuZQXrpitHk2UCZt3rUoa\"}],\"group\":\"cf-nel\",\"max_age\":604800}', nel: '{\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}', server: 'cloudflare', 'cf-ray': '77707e289bca208d-IAD', [Symbol(defaults)]: null }, config: { transitional: { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, adapter: [Function: httpAdapter], transformRequest: [ [Function: transformRequest] ], transformResponse: [ [Function: transformResponse] ], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, maxBodyLength: -1, env: { FormData: [Function], Blob: null }, validateStatus: [Function: validateStatus], headers: AxiosHeaders { 'User-Agent': 'axios/1.1.3', 'Accept-Encoding': 'gzip, deflate, br', [Symbol(defaults)]: [Object] }, method: 'get', url: 'https://pokeapi.co/api/v2/pokemon/1', data: undefined }, request: <ref *1> ClientRequest { _events: [Object: null prototype] { abort: [Function (anonymous)], aborted: [Function (anonymous)], connect: [Function (anonymous)], error: [Function (anonymous)], socket: [Function (anonymous)], timeout: [Function (anonymous)], prefinish: [Function: requestOnPrefinish] }, _eventsCount: 7, _maxListeners: undefined, outputData: [], outputSize: 0, writable: true, destroyed: true, _last: true, chunkedEncoding: false, shouldKeepAlive: false, _defaultKeepAlive: true, useChunkedEncodingByDefault: false, sendDate: false, _removedConnection: false, _removedContLen: false, _removedTE: false, _contentLength: 0, _hasBody: true, _trailer: '', finished: true, _headerSent: true, socket: TLSSocket { _tlsOptions: [Object], _secureEstablished: true, _securePending: false, _newSessionPending: false, _controlReleased: true, secureConnecting: false, _SNICallback: null, servername: 'pokeapi.co', alpnProtocol: false, authorized: true, authorizationError: null, encrypted: true, _events: [Object: null prototype], _eventsCount: 9, connecting: false, _hadError: false, _parent: null, _host: 'pokeapi.co', _readableState: [ReadableState], _maxListeners: undefined, _writableState: [WritableState], allowHalfOpen: false, _sockname: null, _pendingData: null, _pendingEncoding: '', server: undefined, _server: null, ssl: null, _requestCert: true, _rejectUnauthorized: true, parser: null, _httpMessage: [Circular *1], [Symbol(res)]: null, [Symbol(verified)]: true, [Symbol(pendingSession)]: null, [Symbol(async_id_symbol)]: 3, [Symbol(kHandle)]: null, [Symbol(kSetNoDelay)]: false, [Symbol(lastWriteQueueSize)]: 0, [Symbol(timeout)]: null, [Symbol(kBuffer)]: null, [Symbol(kBufferCb)]: null, [Symbol(kBufferGen)]: null, [Symbol(kCapture)]: false, [Symbol(kBytesRead)]: 6334, [Symbol(kBytesWritten)]: 175, [Symbol(connect-options)]: [Object], [Symbol(RequestTimeout)]: undefined }, _header: 'GET /api/v2/pokemon/1 HTTP/1.1\\r\\n' + 'Accept: application/json, text/plain, */*\\r\\n' + 'User-Agent: axios/1.1.3\\r\\n' + 'Accept-Encoding: gzip, deflate, br\\r\\n' + 'Host: pokeapi.co\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n', _keepAliveTimeout: 0, _onPendingData: [Function: noopPendingOutput], agent: Agent { _events: [Object: null prototype], _eventsCount: 2, _maxListeners: undefined, defaultPort: 443, protocol: 'https:', options: [Object], requests: {}, sockets: {}, freeSockets: {}, keepAliveMsecs: 1000, keepAlive: false, maxSockets: Infinity, maxFreeSockets: 256, scheduling: 'lifo', maxTotalSockets: Infinity, totalSocketCount: 0, maxCachedSessions: 100, _sessionCache: [Object], [Symbol(kCapture)]: false }, socketPath: undefined, method: 'GET', maxHeaderSize: undefined, insecureHTTPParser: undefined, path: '/api/v2/pokemon/1', _ended: true, res: IncomingMessage { _readableState: [ReadableState], _events: [Object: null prototype], _eventsCount: 5, _maxListeners: undefined, socket: [TLSSocket], httpVersionMajor: 1, httpVersionMinor: 1, httpVersion: '1.1', complete: true, headers: [Object], rawHeaders: [Array], trailers: {}, rawTrailers: [], aborted: false, upgrade: false, url: '', method: null, statusCode: 200, statusMessage: 'OK', client: [TLSSocket], _consuming: true, _dumped: false, req: [Circular *1], responseUrl: 'https://pokeapi.co/api/v2/pokemon/1', redirects: [], [Symbol(kCapture)]: false, [Symbol(RequestTimeout)]: undefined }, aborted: false, timeoutCb: null, upgradeOrConnect: false, parser: null, maxHeadersCount: null, reusedSocket: false, host: 'pokeapi.co', protocol: 'https:', _redirectable: Writable { _writableState: [WritableState], _events: [Object: null prototype], _eventsCount: 3, _maxListeners: undefined, _options: [Object], _ended: true, _ending: true, _redirectCount: 0, _redirects: [], _requestBodyLength: 0, _requestBodyBuffers: [], _onNativeResponse: [Function (anonymous)], _currentRequest: [Circular *1], _currentUrl: 'https://pokeapi.co/api/v2/pokemon/1', [Symbol(kCapture)]: false }, [Symbol(kCapture)]: false, [Symbol(kNeedDrain)]: false, [Symbol(corked)]: 0, [Symbol(kOutHeaders)]: [Object: null prototype] { accept: [Array], 'user-agent': [Array], 'accept-encoding': [Array], host: [Array] } }, data: { abilities: [ [Object], [Object] ], base_experience: 64, forms: [ [Object] ], game_indices: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], height: 7, held_items: [], id: 1, is_default: true, location_area_encounters: 'https://pokeapi.co/api/v2/pokemon/1/encounters', moves: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], name: 'bulbasaur', order: 1, past_types: [], species: { name: 'bulbasaur', url: 'https://pokeapi.co/api/v2/pokemon-species/1/' }, sprites: { back_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/1.png', back_female: null, back_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/shiny/1.png', back_shiny_female: null, front_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png', front_female: null, front_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/1.png', front_shiny_female: null, other: [Object], versions: [Object] }, stats: [ [Object], [Object], [Object], [Object], [Object], [Object] ], types: [ [Object], [Object] ], weight: 69 } } You may have also noticed the async and await keywords shown in our sample script. These have to do with asynchronous JavaScript and Promises, two topics that are intermediate-level in complexity. I‚Äôll explain them in the accordion block below and link you to some useful resources for learning them in more detail, but the gist is this: Axios is a ‚Äúpromise-based‚Äù library, and to use it correctly within our script, we need to use async and await. If we don‚Äôt, responses might come back from the PokeAPI out-of-order. Of course, there are other JavaScript tools for working with APIs that don‚Äôt force you to use Promises (like fetch), but I‚Äôm choosing to use Axios for this tutorial because it‚Äôs the default option used by Pipedream, which is an amazing automation platform that I‚Äôll be using for upcoming Notion API tutorials. More Detail on Pipedream Pipedream is a code-light platform that I‚Äôll be featuring in upcoming tutorials; it‚Äôs generally a much easier tool for working with the Notion API and creating automations compared to what we‚Äôre doing here. I‚Äôve used it personally to mirror Notion databases, send YouTube stats to Notion, create a speech-to-text automation, and more. I‚Äôm not using it for this tutorial because I want you to be fully aware of what‚Äôs happening while you learn the Notion API, and because you may want to go off and build apps on your own tech stack! So this tutorial is sticking to more general purpose tools ‚Äì but I did want to base it off of Axios so you‚Äôll be fully prepped when you deal with it on Pipedream. More About Async/Await and Promises Axios is a ‚Äúpromise-based‚Äù library, which means that when we use the axios.get() method, we get a Promise. In JavaScript, a Promise is essentially an IOU. It‚Äôs almost as if JavaScript is handing you a piece of paper that says: ‚ÄúI promise to give you the full results of this API call if it is successful. And if it fails, I‚Äôll give you details about the error. The actual response, be it the successfully-retrieved data from the API or an error message, comes later on once the Promise resolves. In general, this is quite useful because JavaScript is a single-threaded language, which means that it generally can only do one thing at a time. This can become a problem with API calls, because they can often take a (relatively) long time to execute. In a program where lots of things are happening, an API call can block additional code steps that would otherwise execute extremely fast. Promises allow that later code to execute before something like an API call finishes, since the Promise gets returned almost immediately. In complex applications, this means later code steps can do their thing, and then once the Promise resolves, you can take action on the actual response from the API. As I mentioned above, I‚Äôm choosing Axios for this project specifically because Pipedream uses it heavily and I‚Äôll be doing lots of Pipedream/Notion API tutorials in the future. However, what we‚Äôre doing here doesn‚Äôt really need Promises or async/await. Our script is going to get all the information about all the Pokemon before doing anything else, so we would be fine to go with a totally synchronous option here if we wanted. Still, asynchronous JavaScript can be very useful in other cases. If you want to learn more about it, here are some resources. First, I highly recommend watching this talk on the Javascript event loop if you want to understand how JavaScript can be ‚Äúasynchronous‚Äù despite being single-threaded: Next, I‚Äôd recommend watching my friend Daniel Shiffman‚Äôs series on Promises and async/await: JSInfo also has some great articles on these topics: Promises Async/await With all that preamble out of the way, let‚Äôs start coding! In the embedded Replit above, we made a single call to PokeAPI and logged bulbasaur‚Äôs name in the terminal. Let‚Äôs take that a step further and set the foundation for our script by adding the following code to index.js in our Glitch project (everything from here on out will go in index.js): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Note: From this point on, we‚Äôll often be adding new code in between existing lines. Sometimes we‚Äôll even change existing lines. I‚Äôm doing it this way so the learning curve in this tutorial remains gradual. I‚Äôll make sure to highlight those lines in the code blocks that follow this one. Remember, you can always reference the full code (with or without comments) in the Steal My Code section above. In your terminal, type node index.js and then hit Enter to run your script. If you‚Äôve set things up correctly so far, you should get a list of the first 10 Pokemon: This code is very similar to the code in the embedded Replit example above. One change is the addition of these lines: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] The first two are creating a notion variable and bringing in the Notion SDK that we imported earlier, so we can use it within our script. We‚Äôll start using it in earnest below when we send our first page to Notion. We‚Äôre also creating an empty array with const pokeArray = []. As I mentioned in the tutorial overview, we‚Äôll be adding an object for each Pokemon to this array. Then, we‚Äôll loop through the array and create a new page in Notion for each of those Pokemon objects. Another big difference is that we‚Äôve added a for loop to the function; now we‚Äôre calling the PokeAPI from inside it. Loops: while and for javascript.info This means that we‚Äôre making a call to PokeAPI every time the loop executes. Additionally, we‚Äôve tweaked our axios.get() function call slightly. It now reads: axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) We‚Äôve wrapped our PokeAPI URL in template literals (the backticks ``), which allows us to use variables within it. Template literals (Template strings) ‚Äì JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org We can use ${} to reference a variable within our string; in this case, we‚Äôre referencing i, which increases by 1 each time the loop runs. In effect, each execution of the loop calls the next Pokemon from PokeAPI: https://pokeapi.co/api/v2/pokemon/1 https://pokeapi.co/api/v2/pokemon/2 https://pokeapi.co/api/v2/pokemon/3 ‚Ä¶and so on. The start and end variables define how many times the loop will run. Currently, we‚Äôve set them so that the loop runs 10 times, but hopefully you can see how tweaking them would let us get all 905 Pokemon! Finally, I‚Äôll point out the addition of the .catch() block of code: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) If our API throws an error for some reason, the catch block will be activated. Right now, we‚Äôre just logging the error in the console, but you could add more sophisticated error-handling code if you wanted. Learn more here: Error handling, ‚Äútry‚Ä¶catch‚Äù javascript.info Code Checkpoint At this point, your code should look exactly like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Format the Pok√©mon Data The next thing we need to do is construct an object that will hold the information about each Pokemon that we want to send to Notion. That information includes: Name Number Type(s) Category ‚Äì e.g. ‚ÄúFlame Pokemon‚Äù or ‚ÄúSeed Pokemon‚Äù Generation Height Weight HP Attack Defense Special Attack Special Defense Speed Sprite Official Artwork Flavor text Bulbapedia URL We could declare individual variables for each of these, but a better method is to construct an object and store the values inside it. In JavaScript, an object is a collection of key:value pairs. Object keys always have defined names, and the key:value pairs do not have a specific order (unlike arrays). Objects are heavily used in JavaScript, so check out this primer if you want to learn more about them: Objects javascript.info We‚Äôre going to create an object for each Pokemon that will store all of the data we want to send to Notion. For now, we won‚Äôt add all of the information. Instead we‚Äôll stick with a few basics ‚Äì name, number, height/weight, and basic stats. This will keep things simple; we‚Äôll add the other pieces later on. Remove the old console.log() line, and add the highlighted code within your .then() block: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) In the pokeData object declaration, we are creating several keys, such as name, number, height, etc. The value that corresponds to each key is dynamically set by accessing a specific value from the poke object, which contains the entire response from Pok√©API. Later, we‚Äôll access the values of this object in order to send information to Notion. You can see that we‚Äôre already doing it once here: console.log(`Fetched ${pokeData.name}.`). After declaring the pokeData object and filling it up with values, we also add the object onto the end of our pokeArray array with pokeArray.push(pokeData). You may remember that we declared that array near the top of our code: const pokeArray = []. The [] symbols define the variable as being an array, but when it was declared, it was empty. In other words, it was an array with no elements inside it. Using the push method, we ‚Äúpush‚Äù our pokeData object onto the end of the array. You can learn more about how this method works here: Array.prototype.push() ‚Äì JavaScript | MDN The push() method adds one or more elements to the end of an array and returns the new length of the array. developer.mozilla.org Before we move on, you should also change your const end = 10 line to const end = 1 for now: async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { This will cause the script to fetch only the first Pok√©mon, Bulbasaur. Later, we‚Äôll change it to a higher number so we can fetch hundreds of Pok√©mon ‚Äì but for now, it‚Äôll keep things simpler if we fetch just one. Once again, run node index.js in your terminal. You should see a result like this: The console.table() method is another useful tool for seeing information in the terminal. It nicely formats data structures like objects, and by using it we can see all of the properties that we created within the pokeData object. I‚Äôve removed the console.table() line from my final code; you can choose whether or not to do the same. Leaving it in won‚Äôt change anything, as it‚Äôs just a logging tool. Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) }) .catch((error) => { console.log(error) }) } } getPokemon() Create Your First Page with the Notion API Now that we have a tidy little object full of Pok√©mon data, let‚Äôs send it to Notion and create the first page in our Pok√©dex! To do that, we‚Äôll declare a second function called createNotionPage() at the bottom of our code, beneath the getPokemon() function call. Additionally, we‚Äôll call the createNotionPage() within the getPokemon() function‚Äôs declaration, at the very end before its closing curly brace. Go ahead and add the highlighted lines to your code: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } We‚Äôll go through what this code does in a second. For now, we‚Äôre going to run the code and see what happens. First, you‚Äôll need to go to your Pok√©dex database‚Äôs ‚Ä¢‚Ä¢‚Ä¢ menu, go to Group, and set the No Generation option to visible. We currently aren‚Äôt passing generation information, so you‚Äôll need to do this in order to see the page you‚Äôre about to send to Notion. Next, go ahead and run node index.js in the terminal once more. If your code and .env variables are set up correctly, you should see something similar to this in your terminal: [email protected]:~ 23:48 $ node index.js Fetched bulbasaur. ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ (index) ‚îÇ Values ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ name ‚îÇ 'bulbasaur' ‚îÇ ‚îÇ number ‚îÇ 1 ‚îÇ ‚îÇ height ‚îÇ 7 ‚îÇ ‚îÇ weight ‚îÇ 69 ‚îÇ ‚îÇ hp ‚îÇ 45 ‚îÇ ‚îÇ attack ‚îÇ 49 ‚îÇ ‚îÇ defense ‚îÇ 49 ‚îÇ ‚îÇ special-attack ‚îÇ 65 ‚îÇ ‚îÇ special-defense ‚îÇ 65 ‚îÇ ‚îÇ speed ‚îÇ 45 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Sending bulbasaur to Notion { object: 'page', id: '64499d85-9748-4ddd-a08b-38a8c6dd6a2c', created_time: '2023-02-05T23:49:00.000Z', last_edited_time: '2023-02-05T23:49:00.000Z', created_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, last_edited_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, cover: null, icon: null, parent: { type: 'database_id', database_id: 'c9cdd00e-d731-4f94-97f4-ab23e9fa0bdd' }, archived: false, properties: { Height: { id: 'C%3FgF', type: 'number', number: 7 }, 'Weight (kg)': { id: 'Dn_%5D', type: 'formula', formula: [Object] }, Attack: { id: 'MRaQ', type: 'number', number: 49 }, 'HP Label': { id: 'MdMo', type: 'formula', formula: [Object] }, Weight: { id: 'N%3BN%7B', type: 'number', number: 69 }, 'Stats Meta': { id: 'NZS%7B', type: 'formula', formula: [Object] }, HP: { id: 'Rce%7D', type: 'number', number: 45 }, 'Sp. Attack': { id: 'U%7Bi%40', type: 'number', number: 65 }, 'Defense Label': { id: 'VRMi', type: 'formula', formula: [Object] }, Sprite: { id: '%5BlYm', type: 'files', files: [] }, No: { id: '%5DY%40D', type: 'number', number: 1 }, 'Ht/Wgt Meta': { id: 'cjoi', type: 'formula', formula: [Object] }, Speed: { id: 'dCkj', type: 'number', number: 45 }, 'Height (m)': { id: 'e%5DNz', type: 'formula', formula: [Object] }, Defense: { id: 'iLgx', type: 'number', number: 49 }, 'Height (ft)': { id: 'i%5DgP', type: 'formula', formula: [Object] }, Meta: { id: 'oBLz', type: 'formula', formula: [Object] }, 'No Label': { id: 'oLD%3B', type: 'formula', formula: [Object] }, 'Sp. Defense': { id: 'pmEd', type: 'number', number: 65 }, 'Weight (lbs)': { id: 'qT%5Er', type: 'formula', formula: [Object] }, Generation: { id: 'q%5CeI', type: 'select', select: null }, Type: { id: 'smaD', type: 'multi_select', multi_select: [] }, Category: { id: 'tESh', type: 'rich_text', rich_text: [] }, 'Attack Label': { id: 'xLfc', type: 'formula', formula: [Object] }, Name: { id: 'title', type: 'title', title: [Array] } }, url: 'https://www.notion.so/bulbasaur-64499d8597484ddda08b38a8c6dd6a2c' } Operation complete. You should also see a new Bulbasaur entry in your Pok√©dex: Congratulations! You‚Äôve just created your first page in Notion using the Notion API. If it didn‚Äôt work, make sure you added the line calling createNotionPage() right before the closing } in your getPokemon() function! Now let‚Äôs walk through these code additions and see what‚Äôs actually happening. The code we added here does five distinct things: Declares the createNotionPage() function. Creates a for...of loop, which allows us to iterate over the elements of pokeArray, performing the same set of actions (defined within the loop) on each one. Defines a data object, which is formatted in the way the Notion API wants, and which is filled with the values of the current object within pokeArray that the loop is working on. Sends a POST request to the https://api.notion.com/v1/pages endpoint of the Notion API in order to create a new page, using the information from the data object Finally, calls the createNotionPage() function from within the getPokemon() function, after everything else in that latter function has finished executing. At this point, the basic structure of the entire script is in place. You can jump back up to the flow chart (or view it on Whimsical in a new tab) to see that entire structure, but here‚Äôs a super-quick refresher. When you run node index.js in the terminal, the following process kicks into high gear: Axios and the Notion API client are imported, the notion variable is created, and the pokeArray array is created (initially empty). getPokemon() is called. Within getPokemon(), a loop executes. For each loop iteration, we make a call to Pok√©API for a Pok√©mon, then place the data we want from the response into an object called pokeData. We then push that pokeData object onto the end of pokeArray. After the loop has finished running as many times as is defined, we call createNotionPage(). Inside createNotionPage(), we have a loop that will execute for each object within pokeArray. Each time, it will take the data from the current object within pokeArray being worked on, place it in the data object, then send that object off to Notion within a request to create a new page. In other words, we go through one loop to called Pok√©API a bunch of times and load up our pokeArray with lots of objects (one for each Pok√©mon), then we go through another loop a bunch of times to send those objects to our Notion Pok√©dex. Now that you understand the gist of what‚Äôs happening, let‚Äôs dig into the actual call being made to the Notion API. First, I‚Äôll briefly cover what‚Äôs happening in our for...of loop: for (let pokemon of pokeArray) This is a looping construct that iterates over every element in pokeArray. As you‚Äôll recall, each element in that array is an object, defined by the pokeData object definition, which holds information about each Pok√©mon. Each time the loop executes, the current element of pokeArray is temporarily stored in the pokemon variable defined in the loop declaration. This means that we can access the Pok√©mon‚Äôs name like so: pokemon.name Earlier in the script, we used pokeData.name to do the same thing. But since we define the variable name as pokemon in the loop declaration, we now use pokemon instead of pokeData. More detail on for‚Ä¶of loops In the code above, you can see that we‚Äôre using a for...of loop to iterate over our array: for (let pokemon of pokeArray) { } This is a type of for loop that can iterate over the values of an array or an object (for... in loops can iterate over the keys). You can see the differences between for...of and for...in here: For-In vs For-Of | Kevin Chisholm ‚Äì Blog blog.kevinchisholm.com In most cases, you want to access the actual values of an object or array, so a for...of loop is cleaner. Note that you could also write a normal for loop, using the array‚Äôs length to set the end parameter: for (let i = 0; i < pokeArray.length; i++) { } Since we‚Äôre working on an array, these approaches are functionally identical. Next, let‚Äôs look at the data object declaration. const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } data is an object that is structured exactly as the Notion API expects. Of course, you may now be wondering‚Ä¶ how do I know how to structure the object? That‚Äôs where the Notion API documentation comes in ‚Äì and you‚Äôre going to want to get very familiar with it. In this case, I looked at the reference for creating new pages: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com On this page, you can get all the information you need to properly structure your request to the API. Let‚Äôs go over a few important parts of this page: First, at the top of the page you‚Äôll see the endpoint URL and the method required for sending this type of request. For creating a page, you send a POST request to https://api.notion.com/v1/pages ‚Äì or you use a method that does the same for you (e.g. using notion.pages.create() as we are in our script). Second, you‚Äôll see the body parameters that can be sent with the request. You‚Äôll also see the ones that are required ‚Äì in this case, the parent (which is either a database or an existing page) and the properties. Third, you‚Äôll see the example code area. This shows a sample request, which you can use as a reference for modeling your own request. Additional Example Options Note that you can use the dropdown menus to see other requests. The default example uses the official Notion SDK for JavaScript, which we‚Äôre using in this project as well. It provides lots of handy methods for making API requests without writing as much code. However, you can see several other examples. If you change the dropdown from Notion SDK to Axios, for example, you‚Äôll see this code: import axios from 'axios'; const options = { method: 'POST', url: 'https://api.notion.com/v1/pages', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json' } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); My only issue with this example code is that it actually doesn‚Äôt give you all of the information you need to make a request using Axios. Perhaps they‚Äôll fix this in the future (you may see different code if you‚Äôre reading this well after I publish it), but for now, it‚Äôs incomplete. Here‚Äôs the full code you‚Äôd need to use to create a page using Axios: const axios = require('axios') const options = { method: 'POST', url: 'https://api.notion.com/v1/pages/', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json', Authorization: `Bearer ${process.env.NOTION_KEY}` }, data: { parent: { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, properties: { \"Name\": { \"title\": [ { \"text\": { \"content\": \"Test Page\" } } ] } } } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); The code is quite similar, but you can see that I‚Äôve included two new pieces of information: An Authorization property in the headers object, containing my integration‚Äôs secret key A data object that contains both the parent and the properties. Both of these are required, yet they aren‚Äôt shown in the Axios example. This is a harsh truth I‚Äôve learned as I‚Äôve gone through my journey of learning APIs; you‚Äôre often expected to know a lot of fundamentals, and API documentation often doesn‚Äôt hold your hand. This is likely because developers are trying to write mountains of documentation very quickly, and they‚Äôre also experienced enough to know the missing pieces by heart. Unfortunately, us noobs are often left scratching our heads as a result! Fourth, you can see examples of responses that the API will send back. Here on the Create a Page doc, there are four possible responses: 200 ‚Äì a successful response, indicating that the page has been created. 400 ‚Äì invalid request (can mean several things) 404 ‚Äì resource does not exist (in this case, the parent) 429 ‚Äì your application has been rate limited You can see a full list of the error responses that the Notion API may return here: Errors Responses from the API use HTTP response codes are used to indicate general classes of success and error. Error responses contain more detail about the error in the response body, in the ‚Äúcode‚Äù and ‚Äúmessage‚Äù properties. developers.notion.com Using the information on this page ‚Äì especially the example code ‚Äì I was able to properly construct the data object. There‚Äôs one other page that came in very handy for constructing this request, and that‚Äôs the Property Values reference: Property values A property value defines the identifier, type, and value of a page property in a page object. It‚Äôs used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with ‚Ä¶ developers.notion.com Note: This page is currently not shown in the sidebar of the API reference. It‚Äôs quite hard to find, and it‚Äôs the only page that shows you explicitly how to set property values when creating or updating pages. There is also a Page Property Values page, which is listed in the sidebar, and which has a very similar title ‚Äì but only shows you the responses that you get when you retrieve property values. Notion is in the middle of merging these two pages, but as of this writing, that process hasn‚Äôt been completed yet. This page will show you how to properly construct an object in order to set any kind of property value (that is supported by the API). For example, here‚Äôs how you‚Äôd set a value in the number-type property called No: \"No\": { \"number\": 42 } Important Note: That first key value (in this case, ‚ÄúNo‚Äù), must match the name of the property in your database. Using the property references on that page, you‚Äôll be able to figure out how to structure your request and add values to all of the properties in your target database (if indeed you‚Äôre creating a page in a database). Finally, we have this small block of code that actually sends the request to Notion: console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) Here, we‚Äôre simply using the notion.pages.create() method, passing our data object as the argument. Note that we could have defined the object directly between those parentheses, but I find it cleaner to define it first and then simply pass the variable as the argument. The console.log() lines simply log information in the terminal. Before we move one, I‚Äôd like to cover one more quirk from our data object definition: \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, Note how the first line accesses the defense property: pokemon.defense ‚Äì this method of accessing object properties is called dot notation. It can be used when the property name contains only letter, numbers, or underscores. When a property name contains other characters ‚Äì such as spaces or dashes ‚Äì then you must use bracket notation to access it. The line accessing special-attack shows how: pokemon['special-attack']. Learn more here: Property accessors ‚Äì JavaScript | MDN Property accessors provide access to an object‚Äôs properties by using the dot notation or the bracket notation. developer.mozilla.org Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Create Multiple Pages at Once Now that we have the basic structure of our script in place, it‚Äôs time to kick things up a notch and fetch multiple Pok√©mon at once. Fortunately, we already have both of our loops in place! So all we need to do in this step is: Tweak the end variable so that the initial loop runs more than once, and fetches more than one Pok√©mon Add a ‚Äúwait‚Äù function to prevent our script from getting rate-limited Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Now let‚Äôs test this out. First, delete your original Bulbasaur entry from your Pok√©dex, since it will be recreated. Next, run node index.js in the terminal once more. If everything goes smoothly, you should see a lot of log information in your terminal. Additionally, you should now have ten entries in your Pok√©dex: Let‚Äôs go over what we‚Äôve added. The first change here is pretty simple. We‚Äôre just changing const end = 1 to const end = 10, which will cause our initial loop to run ten times. This means that we‚Äôll make ten called to Pok√©API and add ten objects to pokeArray. The other change is the addition of the following code beneath the getPokemon() call: const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; This is a simple function that takes a single argument (a number) and will cause the script to wait that many milliseconds before continuing whenever we call it. You can see that we‚Äôre calling it right before sending each page to Notion: await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) JavaScript doesn‚Äôt have a built-in sleep() function as some other languages do, but we can use the above code to approximate one. It uses a combination of setTimeout() (a built-in Web API method), a Promise, and async/await to essentially pause the script for the number of milliseconds we specify. More Detail on the sleep() function You don‚Äôt really need to understand the nuts and bolts of the sleep() function to use it; you can basically just copy and paste. However, if you‚Äôre curious about how and why it works, here‚Äôs a brief overview. The built-in setTimeout() function will set a timer and execute a function after the timer is up. Here‚Äôs the reference for it: setTimeout() ‚Äì Web APIs | MDN The global setTimeout() method sets a timer which executes a function or specified piece of code once the timer expires. developer.mozilla.org However, setTimeout() will not delay the execution of the next line of code. We can get around this issue by creating a Promise within our sleep() function, which is only fulfilled after the setTimeout() call inside it has finished running. Then, by calling the function with the await keyword (e.g. await sleep(300)), we effectively cause our script to pause for 300 milliseconds before moving on. The MDN documentation on Promises explains why this works: Promise ‚Äì JavaScript | MDN The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. developer.mozilla.org You can also get more detail on this sleep() function itself here: JavaScript Sleep: How to Pause Code Execution JavaScript does not have an inbuilt sleep function but thanks to the introduction of promises and async/await, we can implement such sleep in JavaScript. appdividend.com Why are we doing this, though? The reason is that requests to the Notion API are rate-limited, meaning you can‚Äôt send a huge number of requests super-quickly to it. Notion is not unique here; almost all APIs have some kind of rate-limiting implemented. The Notion API currently allows an average of three requests per second: The rate limit for incoming requests per integration is an average of three requests per second. Some bursts beyond the average rate are allowed. Read more here: Request limits To ensure a consistent developer experience for all API users, the Notion API is rate limited and basic size limits apply to request parameters. Rate limits Rate-limited requests will return a ‚Äúrate_limited‚Äù error code (HTTP response status 429). The rate limit for incoming requests per integration ‚Ä¶ developers.notion.com This doc also mentions that a rate-limited request (e.g. one that fails due to hitting the rate limit) will return a 429 error. If you get this, you‚Äôre supposed to set up your code to try the request again after a number of milliseconds that is specified in the Retry-After header value in the 429 response. However, a quick-and-dirty way to make sure we never even see a 429 response is to make sure our script never sends requests too quickly. Hence our await sleep(300) line before the actual call to the Notion API ‚Äì we are waiting 300ms before sending each request, keeping our average very close to that three-requests-per-second limit. There are certainly more sophisticated ways you could handle Notion‚Äôs rate limits, which would likely make your application run faster. I‚Äôd encourage you to explore them as you continue to learn and build! Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Refine Your Pok√©mon Data At this point, your script can send basic information about multiple Pok√©mon to Notion all at once. Now we‚Äôll start the process of adding additional information to each Pok√©dex entry, as well as refining some of the information we already have. Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } Remember, you can always jump back up to the Steal My Code section to see the final version of the code. This step adds a lot of code, and makes some significant changes to the pokeData object declaration. If you‚Äôre starting to feel overwhelmed, now might be a good time to get up and take a short break! I made a video about how breaks are crucial to learning and productivity a while ago, and it even has a Pok√©mon in the thumbnail‚Ä¶ so you know I have to include it here. Once you‚Äôre feeling fresh, let‚Äôs take some time to go through each of these new additions to our code. At a glance, here‚Äôs what we‚Äôre accomplishing in this step: Get and store each Pok√©mon‚Äôs type(s) Reformat each Pok√©mon‚Äôs name to look nicer (e.g. changing ‚Äúmr-mime‚Äù to ‚ÄúMr. Mime‚Äù) Construct a valid Bulbapedia URL for each Pok√©mon, which we‚Äôll later embed in that Pok√©mon‚Äôs page content Get and store the sprite and/or official artwork for each Pok√©mon Each of these steps has a specific code block. For now, we‚Äôre simply getting and formatting this information; we‚Äôll send it to Notion in a later step. First, we get the Pok√©mon‚Äôs type ‚Äì or multiple types! const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } This presents a bit of a challenge. Pok√©mon can have up to two types, and Pok√©API returns each Pok√©mon‚Äôs type(s) as an array filled with objects. See for yourself at the official docs for the pokemon endpoint. This means we have to: Dig into each object within the types array and get the name of each type Place to types into a new array of objects, structured in the way that the Notion API requires To do this, we create a typesRaw variable, setting its value to the entire array of types from the API response: poke.data.types. We also create a new empty array called typesArray. Once again, we‚Äôre using a for...of loop to iterate over typesRaw. Inside, we declare an object called typeObj, setting its name property to type.type.name. The first type in that object is simply the type variable we defined in the for...of loop declaration, which represents the current object being iterated over. The second is the actual type property, the value of which is an object containing the name property (in addition to a url property that we aren‚Äôt using). Next, we format the Pok√©mon‚Äôs name so it looks nicer. This process also has a secondary benefit; it will allow us to construct valid Bulbapedia URLs later. const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") We‚Äôre doing a lot here code-wise, but the aims are simple: Capitalize each Pok√©mon‚Äôs name Handle edge cases where we need to add periods, accent characters (√©), dashes, colons, or gender symbols (‚ôÇ, ‚ôÄ) How this code works This block of code may initially look confusing, as it is quite dense. The reason for this is that I‚Äôve used method chaining to condense it. In JavaScript, you can call methods one after another with periods. This results in code that takes up less space, and for experienced programmers it can often be more readable. However, for a beginner, it may be intimidating. So the best way to explain this code will be to rewrite it as distinct steps on their own lines. Run the code here, then view the source: Here, I have both the distinct steps as well as the method-chained approach in the code. As you can see, both methods give the same exact result. However, using method-chaining takes up far fewer lines. Learn more about method chaining: Here‚Äôs what the code actually does, in order: Splits the name into an array of single-word values (will usually create a single-element array, but this is needed for Pok√©mon like Mr. Mime and Type: Null) Uses map() to iterate over the returned array, executing these steps on each element: Use toUpperCase to capitalize the first letter of the name Concatenate that capitalized letter with the rest of the name (using substring() to get everything except the first letter) Join the elements of that array back together as a single string, separating each with a space character (\" \") Use replace() to handle edge-case replacements, such as replacing ‚ÄúMr M‚Äù with ‚ÄúMr. M‚Äù As for the actual methods being implemented here, I‚Äôll link to the docs for each one: String.prototype.split() Array.prototype.map() String.prototype.toUpperCase() (using bracket notation to access the first character in the string) String.prototype.substring() Array.prototype.join() String.prototype.replace() Third, we construct the Bulbapedia URL: const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` This step is fairly straightforward. We create a variable called bulbURL and set its value by creating a template literal (using the backtick ` characters), which allows us to reference variables within the string. Template literals (Template strings) ‚Äì JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org Bulbapedia has an extremely rigid structure for its URLs. It‚Äôs always the same, except for the Pok√©mon name: https://bulbapedia.bulbagarden.net/wiki/Charmander_(Pok√©mon) https://bulbapedia.bulbagarden.net/wiki/Squirtle_(Pok√©mon) https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pok√©mon) Thus, our URL structure just needed to use processedName to set the correct URL. The only fancy thing we‚Äôre doing here is using replace() to replace any space characters with underscores: `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` More on replace(): String.prototype.replace() ‚Äì JavaScript | MDN The replace() method returns a new string with one, some, or all matches of a pattern replaced by a replacement. The pattern can be a string or a RegExp, and the replacement can be a string or a function called for each match. If pattern is a string, only the first occurrence will be replaced. The original string is left unchanged. developer.mozilla.org Fourth, we define a variable called sprite that holds either the Pok√©mon‚Äôs sprite or its official artwork: const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default The reason we need to do either/or here is because Pok√©mon from Pok√©mon Legends: Arceus and later games don‚Äôt have sprites (their models are 3D). As a result, Pok√©API doesn‚Äôt have a sprite object for them, meaning we need to grab their official artwork instead. Finally, we add our new key:value pairs to the pokeData object definition: sprite, bulbURL, and typesArray. Additionally, we change the value of the name property to be our new processedName variable. const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } If you‚Äôd like to test your code at this point, I‚Äôd recommend commenting out the createNotionPage() function call. Adding // to the beginning of that line will turn it into a comment, preventing it from executing. // createNotionPage() Doing this will allow you to see the log information for your code changes without sending more pages to Notion (which we‚Äôre not yet ready to do). Run node index.js in the terminal once more, and you should see log information like this: Here, our console.table() reports are now showing our nicely-formatted Pok√©mon names. We can also see the URLs for the sprite, official artwork, and Bulbapedia page. Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is commented-out at this point; later, we‚Äôll remove the comment symbols to enable it again. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Get Flavor & Generation Data for Each Pok√©mon In the last step, we added quite a lot of new information to our pokeData object definition. However, we‚Äôre still missing a few vital pieces ‚Äì including each Pok√©mon‚Äôs: Generation (e.g. Gen I, II, III‚Ä¶) Category/Genera (e.g. ‚ÄúFlame Pok√©mon‚Äù or ‚ÄúDancing Pok√©mon‚Äù) Flavor Text The reason we haven‚Äôt gotten these pieces of information up until now is because they‚Äôre accessible via a completely different endpoint of Pok√©API: the pokemon-species endpoint. All of our previous information came from the pokemon endpoint. In fact, Pok√©API has several different endpoints under the ‚ÄúPok√©mon‚Äù umbrella: My guess as to why they‚Äôve designed their API this way is to simply cut down on the amount of information that is returned from a single request. In any case, we need to query the pokemon-species endpoint in order to get these piece of information. To do so, add the following lines to your code, just above your createNotionPage() function call within the getPokemon() function: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } //createNotionPage(); } This code sets up a for...of loop, just as we did when we created our createNotionPage() function (click here to jump back to that section if you need a refresher). Within that loop, we‚Äôre using Axios to call the pokemon-species endpoint. Note how we use the pokemon.number property to define the specific URL: await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) Since we‚Äôre iterating over each element of pokeArray, we‚Äôre just taking the number obtained from our previous call to the normal pokemon endpoint. Once we get the response, we do three things: Declare the flavorText, category, and generation variables, setting their values by accessing the relevant information from the API response and formatting it. Add new properties to our pokeData object, setting their values using the variables we just declared. Log the event in the console. Note that we could easily combine steps #1 and #2 here; we don‚Äôt need the interim variables (e.g. flavorText). I‚Äôve only split these steps up to make things clearer. There‚Äôs actually a lot going on here, and the steps we have to take to access and format the data in step #1 here are quite technical. Therefore, I‚Äôll put each of them in a toggle that you can read through if you want. Flavor Text and Category To fetch and format the flavor text, we use this line of code: const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") We do nearly the exact same thing to get the category, just without the replace() call at the end: const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus Here I‚Äôll break down the flavorText variable assignment, but it applies to category as well. Once again we‚Äôre method-chaining here, using these methods: Array.prototype.find() String.prototype.replace() Here‚Äôs the problem we need to solve with flavor text: the pokemon-species endpoint‚Äôs response contains an array called flavor_text_entries ‚Äì which may contain many flavor text objects in different languages. Additionally, the english flavor text is not always at the same index in the array ‚Äì so we can‚Äôt just target a particular index. Instead, we need to search through each object, find the one where the value of flavor_text_entries[X].language.name equals \"en\", and then get the flavor_text property from it. Chespin‚Äôs record stores the English flavor text at array element #6. To do this, we use the find() method, which will search through an array and return the first element that satisfies the condition we specify in a testing function. To make this clearer, let‚Äôs look at a simple embed that just uses find() to return the flavor_text entry from the array element that contains the English text: In our test function, we‚Äôre doing something called nested object destructuring. This will make sense more readily if you understand destructuring in general: Destructuring assignment javascript.info Once you understand destructuring, you can dig into nested object destructuring: Nested Destructuring Learn how to use nested destructuring on nested objects with JavaScript. davidwalsh.name The gist, though, is that instead of setting the entire object we‚Äôre currently iterating over as the argument in our test function, we‚Äôre ‚Äúdigging into‚Äù that object and setting only the nested name property as the argument instead. From there, find() iterates over each element in the flavor_text_entries array until it finds the one where that nested name property‚Äôs value is \"en\". Since the matched array element is the return value, we can simply access its flavor_text property (end of this line): const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text Unfortunately, this flavor text often contains lots of newline characters that make the text look very wonky. To deal with that, we finish our method chain with a replace() call: replace(/\\n|\\f|\\r/g, \" \") Here, I‚Äôm using a regular expression to replace every instance of a newline character (typically these will be \\n, but they can also be \\f or \\r) with a space character. Here‚Äôs how that works: The / characters define the beginning and end of the regular expression to be matched \\n, \\f, and \\r are all the possible ‚Äúnewline‚Äù characters that will cause a line break in a string The | character means ‚Äúor‚Äù Finally, the g flag means ‚Äúmatch every instance of this expression, not just the first one Regular expressions are a whole subject unto themselves, but if you want to learn them, start here: RegexOne ‚Äì Learn Regular Expressions ‚Äì Lesson 1: An Introduction, and the ABCs RegexOne provides a set of interactive lessons and exercises to help you learn regular expressions regexone.com You can find more regular expression resources at the Regex guide in my Notion Formula Reference: Regular Expressions in Notion Formulas ‚Äì Notion Formula Reference Learn how to use regular expressions in Notion‚Äôs test(), replace(), and replaceAll() functions. learn.thomasjfrank.com Generation Getting and formatting the generation is easier than getting the flavor text and category. We use this code: const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() Here we‚Äôre fetching the generation, which Pok√©API formats like so: generation-vi. We want a simple Roman numeral, like VI. We also want it capitalized. To do that, we go through this process: split() to split the string into array elements, using the - character as our separator pop() to remove the last element of the returned array and (more importantly) return it toUpperCase() to fully capitalize that returned element Once we have those variables set, we simply create new properties in the current pokemon object (defined earlier by the pokeData definition, then represented as pokemon via the for...of loop definition): pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation As you can see, all we have to do is create the new property with either dot notation or bracket notation, depending on the characters in its name. Read more on this here: How to Add Property to an object in JavaScript? ‚Äì Scaler Topics In this article by Scaler Topics, we will look at different ways of adding a property to an object in JavaScript using different methods and examples. www.scaler.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Add New Data to the Notion API Call We‚Äôre at the last code step! All we need to do now is modify the data object definition within our createNotionPage() function, adding the new pieces of information that we‚Äôve fetched (generation, types, flavor text, art, etc.). Add the highlighted code to your data object definition: async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } In addition to the additions and changes highlighted above, be sure to add commas after the closing } symbols where needed. For example: \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, When defining JavaScript objects or writing JSON, sequential properties must be separated by commas as shown above. If you run into errors when trying to run your code, be sure to check for missing commas. I‚Äôve missed plenty of them in my code before. In this step, we add the following information: Page Icon (Using the sprite) Page Cover (Using the official artwork) Properties: Category (rich text) Type (multi-select) Generation (select) Sprite (file) Child blocks (i.e. page content) Flavor text (quote block) A blank space (text block ‚Äì for formatting/aesthetics) ‚ÄúView This Pok√©mon‚Äôs Entry on Bulbapedia:‚Äù (text block) Bulbapedia URL (bookmark block) We‚Äôve already covered objects quite heavily in this guide, so I won‚Äôt spend too much time explaining each addition here. Instead, I‚Äôll point you to the relevant pages in the Notion API reference that explain them. To learn how to set the page icon and page cover, refer to the example code shown on the Create a Page reference: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com Note that images cannot be uploaded to Notion via the API at this time, so you must link to an image hosted externally (as we‚Äôre doing here). For the properties, you can currently see how to format your objects when creating and updating pages here: Property values A property value defines the identifier, type, and value of a page property in a page object. It‚Äôs used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with ‚Ä¶ developers.notion.com In the near future, all of this information will be consolidated into the Page Property Values page, which is linked in the reference‚Äôs sidebar. To add child blocks/page content, refer to the example code in the Create a Page reference linked above. You can also use the Append Block Children reference to learn how to add new blocks to existing pages and blocks (remember, pages are blocks themselves!): Append block children Creates and appends new children blocks to the parent block_id specified. Returns a paginated list of newly created first level children block objects. Errors Returns a 404 HTTP response if the block specified by id doesn‚Äôt exist, or if the integration doesn‚Äôt have access to the block. Returns a 400‚Ä¶ developers.notion.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. In the next step, we‚Äôre remove the // symbols and re-enable that function call. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Run Your Final Test It‚Äôs time to actually run your script! Before you do, go into your code and ‚Äúun-comment‚Äù the createNotionPage() function call at the end of your getPokemon() function: console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() This will ensure the createNotionPage() function is actually called, and that your pages get created in your Notion database. Now it‚Äôs time for the moment of truth. Run node index.js in your terminal one more time; if all goes well, you should see these full-featured entries flooding into your Pok√©dex: Since we also set up the Generation information, you‚Äôll also get them neatly grouped under the I group! If you click into each page, you should also see the flavor text and Bulbapedia link: If everything looks good, then you can modify your start and end variables in order to fetch more Pok√©mon. You already have #1-#10, so now you can set: start = 11 end = 905 Adding Pok√©mon #906-#1008 As of this writing, Pok√©API has not yet added flavor text, category, or generation information for Pok√©mon #906-#1,008 (those releases with Scarlet and Violet). Therefore, this script will work flawlessly for all Pok√©mon up to #905. If you‚Äôd like to add the newer Pok√©mon, you can see ‚Äúdefault‚Äù values in the data object definition, as shown below. I found that I needed to do this for Category, Flavor Text, and Generation. \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category || \"No Category Information\" } } ] } There are more elegant ways to handle this, but I‚Äôll leave them as an exercise for you to tackle if you‚Äôre so inclined! Once you‚Äôre modified those variables and ran the script again, you‚Äôll be the proud owner of a full Pok√©dex in your Notion workspace. Conclusion If you‚Äôve followed this tutorial, you hopefully now have a strong grasp on how to work with the Notion API using JavaScript. What you‚Äôll quickly learn if you start working with other APIs is‚Ä¶ you also know how to work with them as well! As I‚Äôve learned, working with one API greatly prepares you for working with almost any other API. From here, you can use your newly-developed programming and API skills to do nearly anything you want. One resource I‚Äôll recommend now is Pipedream, which is a platform that lets you connect APIs and write actual code (unlike no-code tools, such as Make.com). I love Pipedream because it handles all of the server setup and API authentication for you, letting you just worry about your code. They also have an incredibly generous free tier; I can‚Äôt imagine ever having to pay for Pipedream. As a result, you‚Äôll see Pipedream-focused tutorials on this site in the future. This tutorial took months to produce; if you enjoyed it, you can support my work by grabbing one of my Notion templates (there are both free and paid options here): The Best Free Notion Templates for Tasks, Projects, Notes, and More If you want to improve your Notion workspace, these advanced, battle-tested templates will help you do it. Made by YouTuber Thomas Frank. thomasjfrank.com You can also join my Notion Tips newsletter below for free; once you‚Äôre on it, I‚Äôll send you tons of Notion cheat sheets and goodies. You‚Äôll also be the first to know when I publish new tutorials and templates.","metadata":{"source":"https://thomasjfrank.com/notion-api-crash-course","title":"The Complete Notion API Crash Course for Beginners","date":"2023-02-10T20:53:27+00:00","contentLength":24879}},{"pageContent":"In this Notion Fundamentals lesson, you‚Äôll start learning how to create pages within Notion and customize them. Notion places everything on the page, which might be better described as a canvas. Pages can consist of a few paragraphs of text in a single column, or can contain complex, multi-column dashboards like the one in Ultimate Tasks for Notion. In the video lesson above, you can see how to create the following example page. It is deliberately simple right now; over the next few lessons, we‚Äôll add more features to it before moving onto more advanced page designs. A simple page in Notion with a column of text. Read on to get an easily-referenced overview of Notion‚Äôs page features and options. All of this information is also covered in more detail within the video. You can also add all of the example pages and resources into your own Notion workspace from the Notion Fundamentals hub page. Notion Pages are Canvases Fundamentally, a page is a canvas that holds blocks, which are Notion‚Äôs basic unit. Pages can be nested within one another, and they can also exist inside of databases. When a page is in a database, it contains properties that it gets from that database. We‚Äôll talk more about databases and properties later on in the course. Remember: Pages are simply a canvas! They can be many things: A simple page of text ‚Üí Simple Page A single task ‚Üí Task Due Today A complex, sprawling dashboard ‚Üí Ultimate Tasks for Notion The flexibility of pages ‚Äì and of the modular blocks that live on them ‚Äì makes Notion fundamentally different than most productivity apps. In Notion, a page can be your navigation tool, writing area, task, etc. In most other apps, everything is given a defined roll. In Evernote, for example, a page is just a place to enter text and content. There‚Äôs a separate, defined navigation area. Content and navigation are completely separate in Evernote. Page Features You may notice that the content on this page looks a bit different! Notion lets you customize the look of a page in a few different ways: Fonts ‚Äì normal, serif, and monospaced Small text ‚Äì if toggled, text is smaller than normal Full width ‚Äì not enabled on our example page. This feature is great for multi-column dashboards, or for databases with lots of properties. If a page isn‚Äôt in a database, you‚Äôll be able to find it by navigating to it from the sidebar. If you want to quickly see the page‚Äôs location in your workspace, you can look at the breadcrumbs at the top of the page. You can search for any page as well, whether it‚Äôs in a database or not. If you want quick access to a page, hit the Favorite button and it‚Äôll show up in the Favorites section. Pages always have a title. They can also have an icon and a cover. For each, you can choose from pre-defined options or upload your own! Lastly, pages can have comments and backlinks. On this page, you‚Äôll see both near the top. The Comments section shows any comments that have been made for the entire page ‚Äì though it won‚Äôt show comments placed on blocks or individual pieces of text. The Backlinks area shows pages that are currently linking to this page. We‚Äôll talk more about how to create page links later on. In the page options, you can go to Customize Page and choose how you want to display comments and backlinks. Page History On plans that support it (all except the Free plan), your pages have version control. By going to the Page History area, you‚Äôll be able to see the edits that have been made to a page, and choose to revert to a previous edit if you like. You can also simply copy the content in a previous version and paste it elsewhere if you don‚Äôt want to give up the current version. Page Nesting Useful to know: Pages can be nested infinitely, and higher-level pages have no special properties that don‚Äôt also apply to lower-level pages. The only minor exceptions to this: Top-level pages will show up in your sidebar. You can find lower-level pages by drilling down into these top-level pages in the sidebar view (unless you‚Äôre looking for a page in a database ‚Äì then you‚Äôll need to look in the database) Sharing settings cascade down to lower-level pages. So if you set up sharing for a page, all pages within that page will inherit the same settings. Now that you understand the basics of creating and editing pages, it‚Äôs time to move on to the next lesson: Mastering Notion‚Äôs Text Editing Tools. If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/how-to-create-and-edit-notion-pages-notion-fundamentals","title":"How to Create and Edit Notion Pages ‚Äì Notion Fundamentals","date":"2021-04-24T02:42:47+00:00","contentLength":843}},{"pageContent":"In this Notion Fundamentals lesson, you‚Äôll learn all about Notion‚Äôs text editing tools. While it may not have the same level of text formatting capability as Microsoft Word, Notion does give you a lot of flexibility with your content. Notion has a multi-featured writing system that gives you many ways to do things. You can format your text using Markdown, keyboard shortcuts, or with a toolbar that comes up when you highlight text. You can also do a lot of formatting through Notion‚Äôs universal Slash (/) command. In the video lesson above, I‚Äôll show you visual examples of all these tools. We‚Äôll also use these tools to add new formatting to the example page from the previous lesson on creating pages in Notion. Our simple page from the previous lesson, now with additional formatting. Below, you‚Äôll find a written version of the video lesson that includes some of the most useful Markdown commands and text editing shortcuts in Notion. You can also add the example page above ‚Äì along with all the other examples and templates in this course ‚Äì into your own Notion workspace from the Notion Fundamentals hub page. Text Formatting Options in Notion At a basic level, Notion allows you to format your text in the following ways: As I mentioned above, you have several options to achieving each of these types of formatting: Markdown formatting Keyboard shortcuts The editing toolbar The Slash command Let‚Äôs cover each of these. Notion‚Äôs Markdown System Like many modern note-taking apps, Notion allows you to use Markdown to format your text as you write. If you already know what Markdown is and how to use it, you can head down to the next section to get a Markdown reference for Notion. Markdown is a markup language created by John Gruber and Aaron Swartz in 2004. It allows you to apply formatting to text even when you‚Äôre using a basic plaintext editor, such as Notepad or Atom. This is done by wrapping your text in special formatting characters, such as * and _. A side benefit to this method of formatting is that you apply formatting as you write. Instead of needing to pause in order to hit a keyboard shortcut ‚Äì or go back and highlight text ‚Äì you can apply your formatting as you‚Äôre typing. When Markdown was first released, you‚Äôd write your text in any editor you wanted. To see your formatting, you‚Äôd then have to run your plaintext file through a formatting script, or open it in a Markdown preview application. Next came purpose-built Markdown editors. These often had a two-pane UI; in one, you‚Äôd write and apply markup in plaintext. The other would show you the formatted text, but wouldn‚Äôt let you edit it directly. Dillinger, a classic Markdown editor. Notion does things differently. In Notion, when you wrap text in Markdown characters, your formatting changes are applied immediately inside the editor. This is often called a WYSIWYG (What You See is What You Get) Markdown editor, and it‚Äôs my favorite type of text editor. Notion applies Markdown formatting immediately. You‚Äôll also find this type of Markdown system in apps like Slite, Roam Research, Bear, and Whimsical Docs (which might have my favorite text editor of any app ‚Äì ask me why on Twitter). Some Markdown purists don‚Äôt like WYSIWYG Markdown editors because they strip away the markup characters. While Notion does this, it also gives you to option to export a plaintext .md file, which will contain all the original markup. You can find this at the top-right 3-dot menu ‚Üí Export. From there, choose Markdown & CSV as your export format. Notion Markdown Commands Reference The table below gives you a quick reference to all of the Markdown commands available to you within Notion. Note that not all Markdown features are supported within Notion. Some (such as footnotes) are simply not included, while others (like image embedding) are achieved using other tools like the slash command. For a full breakdown of Notion‚Äôs Markdown support, see Markdown Guide‚Äôs breakdown. Element Syntax Heading 1 # Heading 2 ## Heading 3 ### Italics *text* or _text_ Bold **text** or __text__ Strikethrough ~text~ Pre-formatted text `text` Unordered (Bullet) list *, -, or + ‚Äì then space Ordered (Numbered) list 1., a., or i. ‚Äì then space Horizontal Rule (Line) --- To-Do [] Blockquote \" Toggle block > Code block ``` Toggle heading 1 > + space, then # + space Toggle heading 2 > + space, then ## + space Toggle heading 3 > + space, then ### + space You can also view this table directly inside Notion. Text Editing Keyboard Shortcuts You can also use classic text formatting shortcuts in Notion. If you‚Äôve used shortcuts in Evernote, Microsoft Word, or Google Docs, then you probably know most of these already. A few useful shortcuts to remember: ctrl/cmd + b = bold ctrl/cmd + i = italic ctrl/cmd + u = underline ctrl/cmd + e = inline code Notion has a lot of keyboard shortcuts, so it would be impractical to list them all here. Instead, I‚Äôd recommend bookmarking the shortcut guide in Notion‚Äôs official documentation. Editing Text with the Editing Toolbar Notion also has a floating tool bar full of options, which comes up anytime you highlight some text. Most formatting options are available from the editing toolbar. In addition to formatting options, the toolbar will also allow you to create links, add dates and reminders, and mention teammates. You can also use it to turn the entire block that contains the selected text into another type of block. Editing Text with the Slash Command Notion‚Äôs ‚ÄúSlash‚Äù command ‚Äì so named because you merely need to type / to use it ‚Äì brings up a powerful menu full of options. As you learn more about Notion, it will likely become the feature you use more often than any other. Using the Slash command to create lists. In general, the Slash command is used to create new blocks or to change the type of an existing block. It can‚Äôt really be used to format a precise selection of text. That‚Äôs what the other methods we‚Äôve discussed are for. However, there are a couple of useful formatting tricks for which you can use the Slash command: Using the Slash command to change a block‚Äôs type and background color. Change a block‚Äôs type ‚Äì click anywhere in a block and type /turn. You‚Äôll see options for transforming the block into something else. You can keep typing to narrow this down ‚Äì e.g. /turnbullet to highlight the Bullet List block type. Change a block‚Äôs text or background color ‚Äì click anywhere and type /red (or any other supported color) to zoom to that color option. Start adding ‚Äù background‚Äù to the end to zoom to that background color ‚Äì e.g. /red b. You can also type /back to zoom straight to all the background color options. I find myself using these two tricks all the time. They‚Äôre much faster than the alternative methods. Now that you have a firm grasp on text editing in Notion, it‚Äôs time to move onto learn about one of the most important features ‚Äì blocks! If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/a-guide-to-editing-and-formatting-text-in-notion-notion-fundamentals","title":"A Guide to Editing and Formatting Text in Notion ‚Äì Notion Fundamentals","date":"2021-04-28T18:01:47+00:00","contentLength":1233}},{"pageContent":"In this Notion Fundamentals lesson, you‚Äôll learn all about blocks, which are one of Notion‚Äôs most essential tools. What is a block? Put simply, a block is a basic unit of data. Notion‚Äôs official explanation (from their pricing FAQ): ‚ÄúA block is any single piece of content you add to your page, like a paragraph of text, a to-do item, an image, a code block, an embedded file, etc.‚Äù Think of blocks like LEGO pieces. By adding blocks together, you can build more complex ‚Äì and more useful ‚Äì things. Here‚Äôs an example page with some of the different block types labeled. When you build with LEGOs, you have access to lots of different types of pieces ‚Äì short pieces, long pieces, thick pieces, and special pieces for that Star Wars X-Wing kit you lost the instructions for months ago. The same is true in Notion, which gives you access to many different block types. All of the following are blocks: A paragraph of text An image An embedded YouTube video A database A page ‚Ä¶and yes, you read that last one correctly ‚Äì pages are blocks, too. This concept is fundamental to fully understanding how to use Notion: Pages are canvases for blocks. Pages are also blocks themselves, which live on other pages. In this guide, you‚Äôll learn how to create blocks, edit them, and easily turn them into other blocks. I‚Äôve also created a comprehensive list of every block in Notion, which you can use to see most of the blocks available to you. In the video above, you‚Äôll learn to use blocks hands-on by working through an example project ‚Äì building a personal dashboard! We‚Äôll work through this project slowly throughout the rest of the course, using it to explain every part of Notion ‚Äì however, you can also skip ahead and checkout my full Notion dashboard tutorial. How to Create a Block in Notion You‚Äôve got two main ways to create new blocks in Notion: Use the / Command Click the + button to the left of any existing block Here I‚Äôm creating a Quote block using the / command. Certain types of blocks ‚Äì such as headings, bullet lists, and toggle blocks ‚Äì can also be created using keyboard shortcuts and Markdown syntax. Check out my guide to editing text in Notion to learn more about using these methods. Using the two main methods listed above, you‚Äôll be immediately presented with a pop-up menu of all the different types of blocks you can choose. You can scroll through this, but you can also start typing to narrow down your choices. Once you hit Enter or click your choice, that block will be inserted on the page. Edit Blocks with the Block Menu Hover over any block in Notion and you‚Äôll see a gray six-dotted icon to the left of it, calle the block handle. Click it to access a menu of options you can use to edit your blocks, or click and hold it to drag the block around. (On mobile, tap any block, scroll the toolbar to the right, and find the ‚ÄúMore‚Äù button to access these options.) Opening the block menu using the block handle. Within this menu, you‚Äôll see the following options: Delete Duplicate Turn Into ‚Üí lets you turn the block into another type of block. Turn Into Page ‚Üí turns the block into a page. You can either create a new sub-page on the current page, or create a page elsewhere in your workspace. Blocks nested within it will become page content. Copy Link ‚Üí copies the URL of the block. Navigating to that link will bring you to the containing page with the block highlighted. Move To ‚Üí move the block to another page. Comment ‚Üí leave a comment on the block. Color ‚Üí highlights the block in a chosen color, or changes its text to a chosen color. On text-based blocks, nearly all of these commands can be accessed using the / Command as well. For example, you can type /comment to add a comment. Some editing features also have keyboard shortcuts, such as Ctrl/Cmd + Shift + M for adding a comment. Adding a comment to a block using the / command. Certain types of blocks also have additional options. On image blocks, you‚Äôll see an option to view the image in full-screen. Code blocks will give you options for code wrapping and code language for syntax highlighting. There are other options as well, so go do some exploring! Synced Blocks in Notion In June 2021, Notion quietly released a special type of block called the Synced block. This block brings some significant changes to Notion, so it gets a whole section! Synced blocks can be copied and pasted elsewhere in your workspace, and all you to see and edit content from multiple locations. If you‚Äôve ever used block embeds in Roam Research, you‚Äôll be familiar with this concept. Any other block can go inside a Synced block (except other Synced blocks). You can also ‚Äúturn‚Äù existing blocks into Synced blocks, which just wraps a new Synced block around them. Once created, you can copy and paste your Synced block to other locations in your workspace. You can even paste them into template blocks and database templates. You can use Synced blocks to create: Headers and footers across your workspace Databases that you want to see in multiple places (you can also use Linked Databases for this, but this method will let you see/edit the original database). Checklists and documentation that shows up inside project templates (remember to un-sync checklist copies if you want to change them on just one project) Learn more in my comprehensive guide to Synced blocks in Notion. Full List of Notion Blocks To see a list of most of the blocks available to you in Notion, check out my comprehensive block reference. You‚Äôll also have the option to duplicate that page into your workspace if you like. Note that the page doesn‚Äôt include every block, since there are many, many types of embeds from different services. I don‚Äôt use all of them, so there are few that I haven‚Äôt included. As I mentioned above, you can simply type the / Command to see a list of every block available. Block Limits in Notion Prior to May 2020, Notion‚Äôs free personal plan limited your workspace to 1,000 blocks. Since then, however, Notion has removed the block limit and the Free plan now allows you to create an unlimited number of blocks. You can see the remaining limitations of the Free plan on Notion‚Äôs pricing page, but for the most part, the removal of the block limit means that the Free plan is more than enough for most people. The only place where the 1,000-block limit remains is on the free trial for the Team Plan. When using the trial, you can see how close you and your team have come to the limit in Settings & Members ‚Üí Settings. Pro-tip: You can always delete existing blocks to make room for new ones. But ‚Äì even more pro-tip: The Guest feature in Notion is very powerful. Guests in Notion can do most of what Team Members can, so if you‚Äôre simply working with frequent collaborators, you can save money by adding them as guests. The main limitations you‚Äôll run into are that Guests can‚Äôt be added to Groups, and they‚Äôll need to be added to each new top-level page. Team Members are automatically given access to all new top-level pages, unless you create them in your Private list. Now that you understand how to create blocks in Notion, let‚Äôs take you understanding to the next level and learn how to create multi-column page layouts! If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-blocks-guide","title":"Notion Blocks: Everything You Need to Know","date":"2021-05-10T23:05:18+00:00","contentLength":1350}},{"pageContent":"One of my most-used areas in my Notion workspace is my personal dashboard. It‚Äôs a fairly simple page that does three important things. It: Works as a ‚Äúhome base‚Äù where I can jump to my tasks, notes, projects, wiki pages, etc. Gives me quick access to my daily tasks board, which I use to plan my day Makes my Notion sidebar way more useful. In this tutorial, you‚Äôll learn how to create your own personal dashboard. I‚Äôve also included a free template that you can add to your Notion workspace below. Watch the video tutorial above to see a step-by-step guide for building a personal dashboard. Alternatively, keep reading to see some examples and dashboard features you can use. Note: Building a personal dashboard is also the main example project in my free beginner‚Äôs series, Notion Fundamentals. If you want to learn all the basics of Notion, check it out. A Look at My Notion Dashboard A personal dashboard is a very, well, personal thing. The only design philosophy is that it should give you quick, convenient access to the parts of your workspace that you use most often. Here‚Äôs a look at my own dashboard: I use a very page link-heavy design with my dashboard. It exists as a jumping-off point ‚Äì it‚Äôs like a train station that can take me to lots of different destinations. Note how the use of Link to Page blocks (rather than page Mentions) causes the links to show up in the sidebar, nested underneath my Dashboard alongside the pages that are actually contained inside it: This is a very powerful Notion feature. It allows you to simply Favorite your dashboard, then toggle it open to access other pages (rather than crowding your Favorites bar with tons of pages directly). Free Dashboard Template In the video above, we go step-by-step to create a slightly more advanced dashboard: In addition to page links, this dashboard also contains some linked databases, giving you on-page access to both a task inbox and note inbox. Many people like to be able to work directly from their dashboards; this example build allows that. I‚Äôve turned this example into a free template you can duplicate into your own workspace. Keep in mind that the template really just gets you the page layout ‚Äì since this is a personal dashboard, you‚Äôll want to replace the example links with your own. If you‚Äôd like to also subscribe to my Notion Tips email list and be the first to know when I release new tutorials and templates, enter your email below. You‚Äôll be redirected to the template right afterward, and I‚Äôll also email you a link to all my free templates. Alternatively, use the second link to jump directly the template without subscribing! ‚Äî Here are the other templates that I used to build the dashboard (these are all free): Ultimate Tasks and Projects Ultimate Note-Taking System Simple Habit Tracker Finally, if you‚Äôd like to add your own cool weather widget like the one I have in the template, check out Indify. They offer several other free Notion widgets as well. If you‚Äôd like some more personal dashboard inspiration, I‚Äôll recommend the Notion subreddit ‚Äì people are always sharing their own dashboards there!","metadata":{"source":"https://thomasjfrank.com/how-to-build-a-personal-dashboard-in-notion","title":"How to Build a Personal Dashboard in Notion","date":"2021-09-09T18:32:26+00:00","contentLength":559}},{"pageContent":"Pages in Notion can be simple, single-column affairs ‚Äì but your pages can also have multiple columns as well. In fact, you‚Äôve got quite a lot of control over how you lay out your pages in Notion! This allows you to create complex dashboards, wikis and knowledgebases, task management systems (like Ultimate Tasks), and lots of other cool things. In this Notion Fundamentals lesson, you‚Äôll learn how to create these types of multi-column layouts. Note: As I mentioned in Page Basics, you can make Notion pages full width on a page-by-page basis. In most cases, you‚Äôll want to do this when creating a multi-column page ‚Äì however, it‚Äôs not required. Dragging and Moving Blocks Any block can be dragged and moved around on the page. To drag a block, click and drag the six-dot icon to the left of it. You can also select multiple blocks and drag them all at the same time in this way. As you drag a block, you‚Äôll see a blue line indicating where it will go. Release the block to drop it wherever you want. Creating a New Column You can create new columns by dragging a block to the left or right of another block. You‚Äôll see a vertical blue line indicating that a new column will be created once you do this. After you‚Äôve create a new column, you can drag other blocks above or below the first block within that column to add them to it. You can also drag them to the side to create even more columns. You can create layouts with a lot of columns. In fact, I‚Äôm not even sure there‚Äôs a true limit to how many you can create: There‚Äôs one caveat to this feature: inline database blocks don‚Äôt play nice with it. You can‚Äôt drag them to the side of other blocks, nor can you drag other blocks to the side of them in order to create multiple columns. I‚Äôm not sure if this is a bug or intended behavior, but it‚Äôs been this way for a long, long time. But fear not! There are a couple tricks for getting inline databases to play nicely with multi-column layouts. First, you can click the three-dot menu on any inline database and then click Turn into page. This will convert your inline table into a Page block, which can be easily dragged around and used to create columns. Once you‚Äôve created a column, click the three-dot menu once again and choose Turn into inline. Voil√†! You now have a new column with your inline database. However, there‚Äôs another trick I use even more often. Simply create a column using another block (such as a Heading), and when drag your inline database under that block. This is typically faster, and I usually like to put header blocks at the top of my columns anyway. Organizing with Toggles One of my favorite blocks in Notion is the toggle block. Toggle blocks can be used to hide and show other blocks. They‚Äôre great for hiding detailed asides within long articles, giving the reader the option to skip over extraneous details if they‚Äôre in a hurry, or to open up the toggle if they want to soak up all the details. In addition to hiding long asides, toggles can hide pieces of multi-column layouts in order to keep them more organized and easier to navigate (especially when you‚Äôre using Notion‚Äôs mobile apps). When you‚Äôre creating a multi-column layout, try using some toggle blocks to keep things hidden and tidy! Nested Columns in Notion It‚Äôs also possible to nest multiple columns underneath an existing column. You can see an example of this in my free Habit Tracker template: If you try to create this type of layout by dragging and dropping blocks, you‚Äôll find that it‚Äôs impossible. By default, you can‚Äôt create multi-column layouts within an already-split column. You can make a row of two columns, then a row of three under that ‚Äì but you‚Äôll find that those rows are very much separate. In order to create a layout like you see above, you‚Äôll have to use an advanced trick. I know, I know ‚Äì this is a Notion basics course ‚Äì but I think we can make time for just one advanced trick! Here‚Äôs the secret: You can paste multiple columns into a Toggle block, then drag that Toggle block and drop it into an existing column. After doing so, you can then use the Turn Into function to turn the Toggle into a Heading. Once done, your columns will be nested under their parent column normally; you can simply delete the Heading afterwards. Note that this trick also works with Page blocks ‚Äì you can create multi-columns layouts in a page, nest that page block under a column, and then turn it into a Heading just like you did with the Toggle block. Mobile Layout Considerations Multi-column layouts do not work on mobile phones. Instead, much like most responsive websites do, your columns will stack on top of each other in a left-to-right fashion. Keep this in mind when designing dashboards and other multi-column pages that will be accessed from a phone. How can you set things up so that you won‚Äôt have to do a ton of scrolling on your phone? Here are a couple tricks I employ. First, put things in toggles. This allows you to scroll to the section you need quickly, then open up the toggle to find specific content. Second, limit the number of rows that are loaded by default in any inline databases. I typically like to limit mine to 10 rows ‚Äì I can always click to load more if I need. Finally (and this one is really cool), you use a Table of Contents block to create a list of links to your on-page Headings. Notice how I‚Äôve created a ‚ÄúQuick Links‚Äù section at the top of my Dashboard Example. When you tap on these links, they‚Äôll zoom you straight to that block on the page. This is a design pattern that I use in nearly all my templates, and you‚Äôll likely find it to be very useful in your own workspace. Now that you understand how to create multi-column layouts, let‚Äôs move onto the next fundamental concepts ‚Äì creating page links and sub-pages! If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/how-to-create-multi-column-layouts-in-notion","title":"How to Create Multi-Column Layouts in Notion","date":"2021-09-27T22:19:07+00:00","contentLength":1138}},{"pageContent":"A huge part of Notion‚Äôs power as a knowledge management tool stems from the way it lets you easily create new pages anywhere in your workspace, and then link those pages together in multiple ways. In this Notion Fundamentals lesson, you‚Äôll learn all of the different ways to create links in your workspace, as well as how to create sub-pages in multiple ways. Sub-pages are Notion pages contained within other pages. Unlike other apps such as Evernote, Notion allows you to create a practically infinite number of nested sub-pages: An example of nested sub-pages in Notion. If you‚Äôve been following along with our Personal Dashboard example project in this course, you probably noticed several page links in the Tasks area of the example dashboard. These each link to another existing page (specifically, they link to pages in my Ultimate Tasks template). By the end of this lesson, you‚Äôll understand exactly how those were created, and you‚Äôll be able to create similar links all throughout your workspace. You‚Äôll also learn all of the ways you can create new pages in your workspace. Creating Page Links Notion gives you several ways to easily link to pages from anywhere in your workspace. Instead of forcing you to use its organizational structure (or rely on search), Notion also lets you build your own web of links and shortcuts for getting around however you like. Here we‚Äôll cover each of the ways you can link to existing pages. The Link to Page Block Just as the Page block (which we covered in Block Basics) lets you create a brand new sub-page, the Link to Page block creates a link to an existing page. This link is a full block, meaning it takes up a full line on your page (or within a column if you‚Äôve created a multi-column layout), as opposed to inline links which can exist within other blocks. To create this type of block, you can either: Use the / command and choose Link to Page, then either search for the page you want or paste the URL if it‚Äôs on you clipboard Paste the URL of a Notion page directly onto the page you‚Äôre on. This will bring up a few different options ‚Äì to create a link block, choose Link to Page. Notice that when you use the Link to Page block, your link shows up in the Sidebar nested underneath the current page. This is just like sub-pages that actually exist within the current page! This means that you can use the Link to Page block to create shortcuts to other parts of your workspace that are easily accessible via the sidebar. I make heavy use of this within my Favorites area. My ‚ÄúThomas‚Äô Dashboard‚Äù page contains links to other important areas of my workspace, which allows me to toggle that page open in order to quickly access them instead of adding them all directly to Favorites. Inline Links In some cases, you‚Äôre going to want to link to pages within a block of text. You also won‚Äôt always want your links to show up in the Sidebar. In these cases, you‚Äôll want to use inline links, which are also known as mentions of pages. To create an inline link, you can paste the URL of a Notion page just as you‚Äôd do for creating a link block. When the menu of options comes up, choose Mention page. You can also create inline links via a few different keyboard commands: [[ ‚Äì the easiest way to create an inline link. The double-bracket is specifically used to create inline links + ‚Äì this is typically used to create new sub-pages, but you can also type the name of an existing page and create an inline link to it. @ ‚Äì this is mainly used to mention people or create date reminders, but it ‚Äì like the + symbol ‚Äì can be used to create inline links as well. Fun technical details about inline links If you create an inline link on a new line in Notion (or create a sub-page on a new line using the + syntax), you‚Äôre actually creating a new Text block! You can prove this to yourself by trying to input text on either side of the inline link; it‚Äôll work perfectly. You can also turn this Text block into a Page, which will get you a weird result ‚Äì your Page Title will contain a link. One thing that trips people up here: If you create a sub-page inline using + syntax, you won‚Äôt be able to use the Turn Into command to turn the page into something else, such as a Toggle block. This is the block menu is actually operating on the Text block ‚Äúwrapper‚Äù that contains the page link. There‚Äôs no way to access the block menu for the page itself. You can fix this by moving the cursor just to the left of the inline sub-page link, then hitting enter. This will force the inline page link onto its own line, turning it into a true Page block. Hyperlinks There‚Äôs one final way to create links in Notion ‚Äì the tried and true hyperlink. These work just like you‚Äôd expect if you‚Äôve ever created a link in a blogging platform like WordPress. You can link to Notion pages or external pages this way. To create a hyperlink, highlight a piece of text and bring up the editing menu. There you‚Äôll find a Link option, which will allow you to type or paste a link. Backlinks Whenever you link to a page in Notion, you‚Äôre actually creating a bi-directional link. This is because Notion has a backlink feature, similar to the one in Roam Research (though not quite as powerful). When you link to a page, you‚Äôll see a backlinks area underneath the title and properties of that page: You can use this feature to navigate back to a page after you leave it via a link, or to see which pages in your workspace are linking to a certain page. Creating Sub-Pages When you create a new page in Notion, it is known as a sub-page unless you‚Äôre creating a top-level page from the Sidebar. There are four main ways to create new sub-pages, not counting methods for creating pages within databases. These include: Creating from the Sidebar Using the New Page button Using the Page block Creating sub-pages using the + syntax Let‚Äôs quickly cover each one, shall we? Creating Pages from the Sidebar Notion‚Äôs sidebar lets you navigate your workspace, but you can also use it to create new pages and sub-pages. When you hover over Workspace or Private, you‚Äôll see a small + icon. You can click this to create a new top-level page, either within your Workspace (accessible by everyone in your Workspace by default) or within your Private collection. You can also hover over any page within these areas to see another + icon. Click this to create a sub-page within that page. If you then visit that page, you‚Äôll see the new page you‚Äôve create at the bottom of it. Using the New Page button At the bottom of Notion‚Äôs Sidebar, you‚Äôll find a New Page button. This button creates a brand new page that doesn‚Äôt yet have a home in your workspace. There are two other tricks for creating a page in this way: Tapping the big + button on the Notion iOS widget Visiting notion.new in the browser At the top of the page, you‚Äôll see a destination menu with a pre-set destination, which you can change. If you‚Äôve picked a destination before on the current device or browser you‚Äôre using, that destination will be remembered and will be set as the default (this is done on a per-device basis). Using the Page Block You can create a new sub-page where you are in your Workspace by using the Page block (we also talked about this in Block Basics). This instantly creates a new page, linked from where you created the block. Easy. Once done, you‚Äôll see the page listed in the Sidebar underneath the page where you created it. Creating Sub-Pages with the + Syntax In addition to using the Page block, it‚Äôs also possible to create new sub-pages using the + syntax. This actually allows for more flexibility than the Page block does. As with inline links, sub-pages created with the + syntax can be placed in the middle of a line of text ‚Äì or even in a page title! To use this page creation method, simply type a + followed by some text ‚Äì whatever you‚Äôd like the page to be named. You can use @ and [[ as well, but + defaults to page-creation, while the others put the page creation options at the bottom of the menu. You‚Äôll see two main options: New ‚Äú____‚Äù sub-page New ‚Äú____‚Äù page in‚Ä¶ The ‚ÄúNew ____ sub-page‚Äù option will create a new sub-page named with the text you entered. This is nearly identical to how the Page block works ‚Äì but with one key difference. Using the + syntax, you can create new sub-pages inline. This means you can house sub-pages within your current page, but have them live on a line of text that‚Äôs already inside another block. By contrast, the Page block always creates a sub-page on its own line. The ‚ÄúNew ____ page in‚Ä¶‚Äù option is more interesting. Click it will take you to a new menu, and will allow you to place the new sub-page anywhere within your workspace. You can even place the new sub-page within a database, and you can go even further by creating it using an existing template (Learn all about creating database templates here). When you use this option, you‚Äôll see a link to the new sub-page that you created. I‚Äôll note that using this option will also allow you to link to existing pages. The text you enter is used as a search query to look for existing pages you can link to. If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-links","title":"Notion Links: How to Create Page Links, Backlinks, and Sub-Pages","date":"2021-11-22T22:02:50+00:00","contentLength":1761}},{"pageContent":"The most powerful and flexible tool in Notion is its database feature. Within your Notion workspace, you can create databases that can store almost any kind of data, including text, numbers, file attachments, and more. Databases can be used to create: Task managers (such as Ultimate Tasks) Calendars Note-taking systems CRMs Custom dashboards for sales and performance data ‚Ä¶and much more. Once you understand how to work with databases, you‚Äôll unlock a whole new level of capability inside of Notion. In this Notion Fundamentals lesson, I‚Äôll guide you through all the basics of creating and using databases. Note: This guide is massive, and is intended to be a truly complete tutorial for Notion databases. I encourage you to use the table of contents to jump around! In the video version of this lesson, we‚Äôll be using everything we learn to create a useful example database ‚Äì a simple task manager, which you could include in the personal dashboard that we‚Äôve been building throughout the other lessons in this series. One thing I‚Äôll note before we get started is that I‚Äôve created a completely free task management template called Ultimate Tasks, which has a lot more capabilities than the example we‚Äôll be building here ‚Äì such as sub-tasks, recurring tasks, progress bars for projects, and more. If you‚Äôre looking for a capable task manager for Notion, check it out! The Ultimate Task and Project Management Template for Notion Use this template to move ALL of your task and project management into Notion. Get it Free How to Create a Notion Database The best way to learn is by doing ‚Äì by trying things out, experimenting, and getting your hands dirty. So let‚Äôs start this guide out by covering how to actually create a Notion database. Doing so is simple; just type /database on any Notion page, and you‚Äôll see a list of database options. You can start out by choosing Database ‚Äì Inline, which will create a brand-new database right on that page. Here‚Äôs a very simple example database that lists some of my favorite movies: By default, your new database will be displayed as a table. Notion offers other database layouts, but a table is a great starting point. There are a couple of alternative ways to create a database as well. First, you can create a blank page (see my lesson on creating pages), and then select one of the database options: You can also use the / command to create a database with the specific layout you want. The options include: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view If you create a database block using a layout command, Notion will give you the option to either create a Linked Database (which links to an existing source database), or to create a new database. There are later sections in this guide for both (click to jump to them): Database Layouts Linked Databases For now, it‚Äôs just useful to know the ways you can create new databases. Notion Databases at a Glance Databases store rows (sometimes known as records). And in Notion, those rows are actually Notion pages themselves. The Table layout in Notion displays a database‚Äôs rows as they‚Äôre actually stored in the database (since Notion uses a table-style database structure with rows and columns). In this example, each movie is a row in the database. However, I can open up any one of them and get a Notion page that works just like any other: These pages can hold any type of content you want ‚Äì text, images, and even other Notion databases. Databases also have properties. You can see these at the top of the Hot Fuzz page above, or as columns in the Table view. Properties hold structured information within a database, and typically they‚Äôre set on a per-row basis. Here in the movies database, I have two: Genre ‚Äì a Multi-Select property, which allows one or more tags to be applied to each record Seen Recently ‚Äì a simple Checkbox property Properties have several uses, but their greatest use is in filtering and sorting your data. Here‚Äôs another view of our Movies table, filtered to show only the movies that we haven‚Äôt seen recently: Note how this is a different view of the same database. Our original Table tab doesn‚Äôt contain the same filter. By looking at the same database through different views with unique filters, we can look at the same database in many different ways. This is immensely powerful. Consider a Notes database containing all the notes in your life. That might be thousands of notes! Without any filters, this data would be hard to sift through. But by applying properties, sorts, and filters, you could create all sorts of useful views: All notes created in the last month Notes tagged with ‚ÄúFitness‚Äù All notes, sorted by Date Last Updated Notes related to the Vacation project in your Project Database Notes with a Review Date that falls within the next week Without a database, these types of filters and sorts aren‚Äôt possible in Notion ‚Äì which means you may eventually end up with long lists of pages that can only be sorted by dragging-and-dropping. Hopefully, this introduction has shown you just how powerful databases can be. From here, the rest of this guide is a choose-your-own-adventure: You can scroll up to the video tutorial above, where we‚Äôll create a simple task manager using some slightly more advanced database techniques. Or, you can keep reading this written guide, which will detail all the important Notion database features ‚Äì filters, sorts, grouping, properties, relations, linked databases, and more. What Is a Database? Now that you‚Äôve had a proper introduction to how Notion databases work, I‚Äôd like to touch a bit on what databases actually are before we get into the details of their individual features within Notion. In general, a database is defined as an: ‚Äú‚Ä¶organized collection of data stored and accessed electronically.‚Äù Nearly every program and web app you use relies heavily on databases. If you‚Äôve ever used a digital calendar app like Google Calendar, then you‚Äôve benefited from a database. Behind the scenes, every event on your Google Calendar is a row in a database. These rows have properties, just like the ones you saw in this guide‚Äôs introduction. Some of these include: Event date Location Calendar (Work, Personal, etc.) Google Calendar uses the values stored for these properties in each row to intelligently display your calendar, showing you each event on its correct day slot, displaying the event‚Äôs location, and color-coding each event based on its Calendar. Notion works in much the same way, but it gives you a lot more control over your databases. You can create your own properties, customize them, and set up database views that display your data based on filters, sorts, and more. Here‚Äôs an example: What if I just wanted to see events on my Work calendar in the month of August? In Google Calendar, I‚Äôd toggle all my other calendars to their ‚Äúoff‚Äù state, and navigate to the correct month: In Notion, I could achieve the same result by first ensuring that I have properties in my Events database for Date and Calendar. Then, I could simply create a view with two filters: Where Calendar contains Work Where Date is within August 1 ‚û° August 31 Of course, Notion also includes a Calendar layout, so the date filter might not be necessary. I just wanted to show you how you‚Äôd directly interact with your database properties to create unique, filtered views. Databases vs. Spreadsheets You might have looked at all our example table views in the screenshots and thought, ‚ÄúHey, those look like spreadsheets!‚Äù Indeed, they do look like spreadsheets ‚Äì but they‚Äôre not. There‚Äôs a fundamental difference between spreadsheets and databases. On a spreadsheet, data is contained within cells that have specific X:Y coordinates on a grid, such as B2 or D5. This means that formulas can reference specific cells, like B2+D5 ‚Äì this simple formula will add the values of B2 and D5. Conversely, databases don‚Äôt really have ‚Äúcells‚Äù with X:Y coordinates. Rather, each record has the same number of properties, each of which can be set to a unique value per record. Technically, since most databases are relational and store data in a table with rows and columns, you could feasibly target coordinates on the table. But since databases are built to be flexible, the vast majority of database tools don‚Äôt provide spreadsheet-like cell coordinates for row:property pairs. We can display a database in a grid-like table, but it‚Äôs not actually a grid of cells that we can target. This means we can easily visualize the information in our database in other ways besides a classic table ‚Äì such as a Kanban-style board, where the columns are based on the Assignee property: Spreadsheets and databases do have quite a bit of overlap, though. In a spreadsheet, we can simulate properties by creating a two-dimensional table. And apps like Excel even allow us to sort of treat a spreadsheet like a database through pivot tables and other functions. Likewise, an app such as Notion can let us view a database‚Äôs table structure, which looks like a spreadsheet. The most important thing to know as a Notion user, however, is that we can‚Äôt target individual row:property combinations as if they were cells on a grid. Here on my task table, I couldn‚Äôt write a formula that specifically targets the ‚Äúcell‚Äù with ‚ÄúApril 6‚Äù in it. In Excel, you might think of that location as B3, but there‚Äôs no B3 in Notion. Instead, there‚Äôs a row ‚Äì the ‚ÄúTest Web Parachute‚Äù row ‚Äì and its Due Date property is set to April 6. It‚Äôs also worth noting that ‚ÄúTest Web Parachute‚Äù is itself a specific value in the Name property. In Notion, new databases get a default property called Name, which can‚Äôt be hidden or deleted. But it is still a property ‚Äì just a special property. Its type is ‚ÄúTitle‚Äù, and you can actually open it up to see a brand-new Notion sub-page within your database. If you want to get even nerdier about spreadsheets and databases, check out this article comparing them. With this high degree of control and flexibility, you can use databases to create all sorts of different tools and applications inside of Notion. After all, many software tools are just collections of filtered database views! Consider: Your phone‚Äôs contacts app Task managers like Todoist Websites like IMDB Each of these simply gives you tools to work with one or more databases. As a result, you can create replacements for all of these tools inside of Notion. You can also create hyper-personalized tools that fit the exact information and processes you use for your work. That‚Äôs Notion‚Äôs superpower. It allows you to build tools that don‚Äôt yet exist, tailored to your exact needs. Notion Database Examples Book Tracker Contact Manager Simple Task Manager As we dig into all the particulars of Notion‚Äôs database tools, you might want some example databases to play around with. Here are a few, which will also serve to show you some of the tools you can build within Notion. Simple Task Manager Contact Manager Book Tracker Each of these databases is available as a free template, which means you can duplicate them into your Notion workspace and make changes to the duplicated copy. Learning happens fastest when you take action, so experiment and make some changes! Add some stuff! Let your cat walk on your keyboard for a minute and then try to fix everything that broke! There are 3 ways to make progress in anything:1. Buy new gear.2. Learn academically through books, courses, etc.3. Spend time in deliberate practice.In order of importance:Practice > Learning >>>>> Gear‚Äî Thomas Frank (@TomFrankly) May 29, 2022 I‚Äôll also note that these are very simple example templates. They purposely lack a lot of features so that they‚Äôre easy to understand and edit. I‚Äôve also designed several more robust templates with advanced features. These templates are completely ready to rock, and will instantly upgrade your Notion workspace with useful tools. Check them out on my Notion Templates page. We‚Äôre now ready to start digging into all of the features that Notion databases offer. From here, you may want to use the Table of Contents to the left (or at the top of this article if you‚Äôre on mobile) in order to find the topic you most want to learn about. Database Views A database view is a specific combination of layout, filters, sorts, etc. Note that a database block can contain multiple views. When it does, you‚Äôll see them all listed across the top as tabs: Each of these views pulls from the same database, but each shows a unique set of data based on a combo of sorting, filtering, and layout. You can also add a new view to a database block using the Add view button: For each view, you can access a View Options menu, where you‚Äôll be able to change nearly any setting related to that database view: Here, you‚Äôll have access to nearly every setting inside your database, including: Database name Layout ‚Äì Table, Board, Calendar, etc. Property settings ‚Äì show/hide properties on the current view Filter options Sort options Group options Load Limit ‚Äì sets the max number of rows that will be loaded automatically (you can load additional rows using the Load More button at the bottom of any view) Lock Database/Lock Views ‚Äì On a source database, this will lock the entire database. On a Linked Database, you‚Äôll see Lock Views, which merely locks the Linked Database‚Äôs views from being changed. (Learn more about locking databases) Copy Link to View ‚Äì copies the link to the current database view to your clipboard Duplicate View ‚Äì duplicates the specific view you‚Äôre currently on Delete View ‚Äì deletes the specific view you‚Äôre currently on Layout Types Notion databases can be viewed in several ways. You‚Äôve already seen the Table layout in our examples above, but that‚Äôs just one of six available layouts: Table ‚Äì a traditional, spreadsheet-like view Board ‚Äì a Trello-style ‚ÄúKanban‚Äù view Timeline ‚Äì a Gantt chart view Calendar ‚Äì a no-frills Calendar view List ‚Äì a responsive, mobile-friendly Table alternative Gallery ‚Äì an aesthetic view that‚Äôs great for showcasing images Each one of these layout types gives you a different way of displaying the same information from your database. They each have their own advantages, disadvantages, and features, so try them all out! Add New Pages to a Database You have a few different options for adding new pages to your database. First, you can hit the +New button within your database view. In a Table view, you‚Äôll find it at the bottom of the table: It‚Äôs worth noting that this is the only way to add a row that will conform to the view‚Äôs filters automatically. Example: If the view above had a filter that said ‚ÄúGenre is Action‚Äù, then your new row would automatically be tagged with Action. This is called a forcing function. Click here to jump to the section of the guide on forcing functions. You can also hit the blue New button in the top-right corner of any database view. This will open up a modal window with a blank record in the database. Additionally, you can create new rows in a specific database from anywhere in your Notion workspace by using the + link syntax, then choosing the ‚ÄúNew page in‚Ä¶‚Äù command. For example, I could add a new row to my Movies database from anywhere by typing +Ghost in the Shell, choosing New page in‚Ä¶, and then selecting the Movies database as the destination. Learn more about this in my guide on linking Notion pages together. Finally, you can add new rows to a Notion database through external tools. For example, the official Notion web clipper and the Save to Notion extension can both clip web pages into your Notion workspace. If you want to get more advanced, you can even use the Notion API to add new database rows using thousands of other tools. Database Properties Properties are the columns in a database‚Äôs table structure, and they‚Äôre useful for holding structured information about each row. They let you add dates, checkboxes, tags, numbers, and a lot more to your databases. In a Table view, you‚Äôll see your database‚Äôs properties as columns: In other layouts, you‚Äôll see property values listed on the cards for each row: You can show/hide individual properties on any given view by going to View Options ‚Üí Properties: By opening up a row as a page, you‚Äôll be able to see all of the properties in that row‚Äôs database. You can also easily add new properties here. Notion comes with many different types of properties. Some are writable, meaning you can edit the information they hold on each row. Others are read-only, meaning they hold information that can‚Äôt be edited. Here‚Äôs a table showing all of Notion‚Äôs property types: Property Description R/W Text Holds text, which can be formatted. Writable Number Holds numbers. Can be formatted as a progress bar. Writable Select Holds singular ‚Äútags‚Äù. Writable Multi-Select Can hold multiple ‚Äútags‚Äù. Writable Status Indicates project/task status. Always has a default value. Can show as text or a checkbox. Writable Date Holds dates, which can be displayed absolutely (e.g. ‚Äú03/25/22‚Äù) or relatively (e.g. ‚ÄúTomorrow‚Äù). Writable Person Holds members or guests of the workspace. Writable Files & Media Holds file attachments, including images, audio files, video, etc. Writable Checkbox Holds a simple checkbox. Writable URL Holds a URL, which is clickable. Writable Email Holds an email address. Writable Phone Holds a phone number, which can be called on supported devices. Writable Formula Holds formulas that can process and output data in many ways. Read-Only Relation Relates the row to other rows in the same database or another database. Writable Rollup Pulls in property information from Related rows. Read-Only Created time Holds the date and time of the row‚Äôs creation. Read-Only Created by Holds the workspace user who created the row. Read-Only Last edited time Holds the date and time of the row‚Äôs last edit. Read-Only Last edited by Holds the workspace user who last edited the row. Read-Only One last useful thing to know about properties is that they can be deleted and restored. If you accidentally delete a property, just head to View Options ‚Üí Properties ‚Üí Deleted Properties to find it and restore it (or permanently delete it if you want): Sorting You can sort a database view by any property, in either ascending or descending order. To create a sort: Hit the Sort button at the top of your database block. Select the property by which you‚Äôd like to sort your view. Choose ascending or descending order. Add additional sort criteria if you want. By adding additional properties, you can create even more granular sorts in your database views. In these cases, the database will be sorted by each property in top-to-bottom order. Drag properties around to change the sort order. Here, you can see that I have this shot list database sorted first by Type, then by B-Roll Description. P.S. ‚Äì This shot list database is part of Creator‚Äôs Companion, my all-in-one Notion template for content creators. Check it out if you make videos, blog posts, or social media content. If you create a sort within a database that is shared with others (Team Members or Guests), your sort will initially only be visible to you on your current device. You‚Äôll notice a Save for Everyone button after creating the sort; click it if you want to apply the sort to the database for everyone. You can also click Reset to remove any changes you‚Äôve made, or simply leave things as-is if you want to keep the sort for your eyes only. If you‚Äôre working on a database that‚Äôs private, you won‚Äôt see these options; they only come up on shared databases. Filters Databases often contain huge amounts of data, but you rarely need to see all of it at once. Typically, you just need to see the rows that are relevant to a specific context, like: Tasks that are due today Subscribers who are less than 30 days away from their renewal date Movies in the Action genre This is where filters come in. Filters allow you to limit the rows a view displays, and they‚Äôre among the most useful tools you‚Äôll find in Notion. Just like a sort, you can create a filter by hitting the Filter button at the top of your database block: There are two types of filters in Notion: Simple Filter ‚Äì a singular filter that targets one property Advanced Filter ‚Äì a set of filters or filter groups Simple Filters Simple filters are quick to create and target a single property. To create one, hit the Filter button and then select the property you‚Äôd like to filter by. Filters follow this convention: Property Name ‚Üí [Criteria] ‚Üí Value Here, you can see that I‚Äôm filtering my view by the Genre property, which has the Multi-Select property type: Your criteria options will change depending on the property‚Äôs type. Here, I have four options: Contains Does Not Contain Is Empty Is Not Empty Finally, I can choose one or more values. My completed filter reads: Genre Contains Action, which means my view will only show rows that have Action in their Genre property. Since Genre is a Multi-Select property, rows can also contain other genres. You can add multiple simple filters to a database view, and you‚Äôll see them displayed in a row across the top of your database view when the Filter bar is open. Advanced Filters An Advanced filter is a set of one or more filters that show up in a single dialogue box. Using an advanced filter, you can do something that‚Äôs incredibly useful; you can mix AND/OR operators when working with multiple filters. When you create multiple simple filters, you‚Äôre always using the AND operator between them. For example: ‚ÄúGenre contains Action‚Äù AND ‚ÄúSeen Recently is Checked‚Äù. By creating an advanced filter, you could instead set up this filter combo: ‚ÄúGenre contains Action‚Äù OR ‚ÄúSeen Recently is Checked‚Äù. Note how this drastically changes the rows that show up in this view! Now, a row only has to fit one of the filter criteria. Advanced filters also let you create filter groups. Within an advanced filter, click the Add Filter Rule dropdown and then select Add Filter Group to create one: Filter groups let you mix your AND/OR operators. Normally, once you‚Äôve chosen either AND or OR, you‚Äôre locked into that choice when you add more rules to the filter. However, a filter group gives you a nested box where you can select a new operator. How is this useful? Here‚Äôs an example problem: Say I‚Äôm a movie buff. I want to watch a movie every night, and I have these preferences: I‚Äôm an action movie nut, so I might want to watch an action movie even if I have seen it recently. For other genres, I only want to watch a movie if I haven‚Äôt seen it recently. Using a filter group, I can create a view that fits both of these preferences. In my Movies database, I‚Äôve created the following set of filters: If a row contains the Action genre, it‚Äôll always show up. If it doesn‚Äôt contain the Action genre, it‚Äôll only show up if Seen Recently isn‚Äôt checked. Here‚Äôs another example from my Ultimate Brain template: Ultimate Brain has a robust note-organization structure (modeled on Tiago Forte‚Äôs P.A.R.A. method) with: Higher-level Areas Lower-level Resources Areas can contain Resources, and Notes can exist in Areas or Resources. This means that within an Area, we‚Äôd want to show Notes that exist directly in that Area, or that exist within any Resources underneath that Area. We also want to make sure those Notes aren‚Äôt archived. Using a filter group, I‚Äôve created a combo of AND and OR operators to meet these criteria. This example is more complex than the previous one, but I hope that it illustrates how filters can allow you to create truly useful tools directly within Notion! P.S. ‚Äì If you‚Äôd like to use Notion as a true Second Brain, check out my Ultimate Brain template. It seamlessly combines tasks, notes, projects, goals, and whole-life organization, and it‚Äôs what I use as my own productivity system. Saving Filters As with sorts, filters created in shared databases will initially only affect your account and device. When you create a new filter or change/delete current filters, you‚Äôll see a Save for Everyone button pop up: You can click that to apply the filter for everyone who has access to the database, hit Reset to erase your changes, or just leave things as they are if you want the filter to only affect you. Forcing Functions When you set up a filter in a database view, new rows created in that view must conform to that filter. As a result, creating a new row in a view with filters will automatically set default property values. Here‚Äôs an example: In this view of the Movies database, I‚Äôve created the following filter: Seen Recently is Checked. Note how the new row I‚Äôve added automatically has its Seen Recently checkbox property checked. When filters are used in this way, I call them forcing functions. You can use these in all sorts of ways ‚Äì here are just a few ideas: Add tasks to a task view with a due date set to Today Add notes to a filtered notebook view with a specific tag, such as Lecture or Book Add tasks to a shared task database with a specific Assignee (person property) I‚Äôve made an entire video explaining how these work (and how to use them to your advantage) in a lot more detail: Grouping Notion lets you group rows in a database view based on common values in nearly any property type. Here, I‚Äôve grouped my Movies database view by the Genre property. Now my movie rows are grouped by genre: You can add Grouping to any view layout (except for Calendar) by going to View Options ‚Üí Grouping. From there, you‚Äôll be able to select the property you‚Äôd like to use for grouping: You‚Äôll also find a few other options, such as Hide Empty Groups. Sub-Grouping Notion‚Äôs Board layout has a unique feature: In addition to Grouping, it can have Sub-Grouping as well. Normally, a Board view will display its groups as columns. This is the classic ‚ÄúKanban‚Äù style of grouping that has its origins in Japanese manufacturing, and which was popularized in the U.S. by apps like Trello. By adding sub-grouping, you can group a board view into distinct rows. In this case, the rows aren‚Äôt actual database rows (as in a Table view); they‚Äôre sub-groups based on another property. In the screenshot above, I‚Äôve grouped the Board view by Genre, and then sub-grouped it by a new Select property called Rating. Movies are grouped by their ratings ‚Äì PG, PG-13, R, etc. You can add sub-grouping to a Board view in nearly the same way you‚Äôd add grouping ‚Äì simply navigate to View Options ‚Üí Sub-Group. Relations The Relation property type allows you to relate database rows to each other. These relations can be created: Between rows in the same database Between rows in separate databases This concept can take a bit of time to fully grok, so let me start out with an example. Example 1: Parent and Child Tasks Task managers often have a sub-tasks feature, which lets you nest sub-tasks underneath a top-level ‚Äúparent‚Äù task. Here‚Äôs a task with a couple of sub-tasks in Todoist: When you open the Parent Task 1‚Äôs window as in the image above, how does Todoist know to show you two sub-tasks ‚Äì and not show you any other tasks? Behind the scenes, there‚Äôs a Relation set up in Todoist‚Äôs database. This Relation consists of two properties, which you could think of as columns in a table: Parent Task Sub-Tasks The Parent Task 1 database row has its Sub-Tasks Relation property filled with links to two other database rows: Child Task 1 Child Task 2 Likewise, each Child Task has its Parent Task Relation property filled with a link to the Parent Task 1 row. In this way, Parent Task 1 is related to the two Child Tasks. With this Relation set up, Todoist can simply use a filter (also behind the scenes) to display the correct Child Tasks. Essentially, that filter would read: Where Parent Task contains ‚ÄúParent Task 1‚Äù This filter ensures that only the two Child Tasks show up. If that makes sense so far, let‚Äôs create it in Notion! How to Create a Single-Database Relation A Relation is a type of property, so you can add one to your database by: Adding a new property Selecting the Relation type Selecting the Database you‚Äôd like your Relation property to point towards Choosing whether the Relation should have separate properties Since I‚Äôm creating a Parent Task ‚¨å Sub-Tasks relation, I want to make sure I choose the same database that I‚Äôm currently working with ‚Äì in this case, My Tasks. Next, I‚Äôll choose whether or not I want to create Separate Properties. If I don‚Äôt, I‚Äôll just get a single Relation property called Sub-Tasks. If I do turn it on, I‚Äôll get a second property. Since I do want a second property called Parent Task, I‚Äôll turn on the Separate Properties option and give my second property the correct name: Now that I have my Relation properties, I can model Parent Tasks and Sub-Tasks just like we did earlier with Todoist. Here, I‚Äôve clicked into the Sub-Tasks property within the ‚ÄúTake Grocery Boxes‚Ä¶‚Äù row, and set two other rows as sub-tasks: Build grocery boxes Get rain covers Note how ‚ÄúTake Grocery Boxes‚Ä¶‚Äù automatically shows up in the Parent Task property for each of these sub-tasks. Now that we have these Relations set up, we can do some useful stuff! Here‚Äôs a basic example. I‚Äôve set up a simple filter that says: Where Parent Task contains ‚ÄúTake Grocery Boxes‚Ä¶‚Äù With this filter in place, I can only see the two sub-tasks I created earlier. In the Linked Databases section of this guide, I‚Äôll show you how to set up this same filtered view inside the Parent Task‚Äôs page. This is far more useful, and it models the Todoist example above perfectly. For now, let‚Äôs take Relations one step further by relating two separate databases together. Example 2: Tasks and Projects Task managers also tend to have Projects or Lists that are useful for grouping multiple tasks together. You can see this in Todoist: If we think about the databases that run everything behind the scenes, we realize that there are actually two main databases: Tasks Lists These databases are related to one another. This means that a single row in the Lists database can be related to many rows in the Tasks database. Then, using filters, Todoist can show you a tidy view of the tasks in a specific list, such as House. Guess what? You can do the exact same thing in Notion by creating a multi-database Relation! How to Create a Multi-Database Relation To create a multi-database Relation, we‚Äôll first need two databases to work with. Fortunately, the Simple Task Manager example template already has two: My Tasks My Projects I can create my Relation in either database, but I‚Äôm going to create it in My Tasks. Adding a new Property, I‚Äôll: Name it Project Select the Relation property type Select the My Projects database for the database connection Toggle Show on My Projects to the On position Name my Related Property with the My Projects database as ‚ÄúTasks‚Äù Note how the Relation builder also gives you a preview of what your Relation looks like. Here, you can see that two properties are being created: ‚ÄúProject‚Äù within the My Tasks database ‚Äì which points to the My Projects database ‚ÄúTasks‚Äù within the My Projects database ‚Äì which points to the My Tasks database These two properties are reciprocal, meaning that setting a related row in one will affect the other. In My Projects, the Suit Redesign project contains two related rows from My Tasks: Going over to My Tasks, we can see that both of these rows ‚Äì Design new web shooters and Test web parachute ‚Äì contain Suit Redesign in their Project property. With this Relation set up, I can do some very useful things. For example, I can group this view by my Project property. I can also set up a database view within a Project‚Äôs page that shows only its related tasks. To do that, I‚Äôll need to use a Linked Database. Linked Databases Linked Databases allow you to create a database block that pulls data from an existing source database, which can live elsewhere in your Notion workspace. For example, the main All Tasks database inside my Ultimate Brain template lives inside the Archive: On Ultimate Brain‚Äôs Quick Capture page, there‚Äôs a Linked Database block that uses All Tasks as its source: This means that any rows I add to this linked database view will end up in the All Tasks database. Essentially, you can think of Linked Databases as collections of Views for a database that can live elsewhere in your Notion workspace. Linked Databases are immensely useful. They allow you to create pages and dashboards in Notion that are driven by source databases, but that serve specific contexts. The Quick Capture page shown above is just one example of a context-specific page. Here‚Äôs another one ‚Äì this page only shows tasks that are due on or before tomorrow: Note that this Linked Database view has the source database hidden; this is an option you can turn off or on. How to Create a Linked Database You can create a Linked Database in Notion either by typing /Linked view of a database or by typing any of the following options: /Table view /Board view /Gallery view /List view /Calendar view /Timeline view I‚Äôll go with /Linked view... inside the Suit Redesign project in the My Projects database. That way, I‚Äôll be able to get a view of all the tasks related to this project. The first thing I have to do is select a data source. This is the source database that I want to pull from. In this case, I want to select My Tasks: Next, I‚Äôll be given the option to either copy an existing view from the source database or to create a new empty view. I‚Äôll do the latter so I can completely customize it: From here, I can customize my view just like I would with a normal view inside the source database. All of the options are exactly the same. The only difference is that the Linked Database view comes with the option to show or hide the source database title. Here, I‚Äôve hidden it in order to make my database view look cleaner: The last thing I‚Äôll do here is add a filter to my linked view: Project contains Suit Redesign This will ensure that only tasks related to my Suit Redesign project show up. It also creates a forcing function, ensuring that new rows I add to this view will automatically be related to the Suit Redesign project! With this simple filter in place, my Project page works just like a List in Todoist (or any other task management app). Database Templates Pages inside a Notion database act just like normal Notion pages ‚Äì they give you a blank canvas on which you can add any combination of blocks. But you won‚Äôt always want to start from scratch; sometimes, you‚Äôll want to have a common starting point for certain pages in a database. That‚Äôs where database templates come in. By creating templates in your database, you can automatically generate any page content you want with just one click. Templates can be as simple or as complex as you want them to be. Here‚Äôs a very simple template within my Movies database: ‚Ä¶and here‚Äôs the comprehensive Content Project Template that I use for all of my YouTube videos. In one click, it generates a task list, shot list, script page, research area, multiple checklists, and more: Note how it also sets default values on some of my database‚Äôs properties ‚Äì including the Status, Channel, and #No properties. If you‚Äôre a content creator, you can get access to this template ‚Äì along with a whole suite of dashboards and tools to aid your creation process ‚Äì in my Creator‚Äôs Companion template. It‚Äôs the exact system I use to run my YouTube channels and blogs (including this one). When you have a template created within a database, you‚Äôll see an option to use it whenever you create a new page in that database and open and open it: You can also create a page from an existing template by clicking the arrow next to the blue New button in your database‚Äôs top-right corner, then selecting a template: How to Create a Database Template You can create a new template by clicking the arrow next to the blue New button in the top-right corner of your database, then clicking New Template. From there, you can add any content you want to the template. You can also set default values in properties, which will be applied to any new page that you generate from the template. Default Templates After you‚Äôve create a database template, you can choose to have that template automatically applied to any new pages you create. You can do this in two different ways: Set the template to be applied only on new pages in the current database view Set the template to be applied on pages created in all views of the database To set a template as a default, click the blue arrow next to the New button and find your template. Then click the ‚Ä¢‚Ä¢‚Ä¢ menu next to the template and choose Set as Default. Once done, you‚Äôll see the options I mentioned above: Choose ‚ÄúFor all views‚Äù if you want the template to be applied in all views of the database (i.e. it will always be applied). Choose ‚ÄúOnly on‚Ä¶‚Äù if you want the template to only be applied on the current view of the database. Self-Referential Filters One of the most useful things you can do with a database template is to combine it with a Linked Database and set up what‚Äôs called a self-referential filter. If you wanted to create a database template inside a Projects database, which shows all the tasks related to the current project, you‚Äôd use a self-referential filter for that. Note: Self-referential filters are tools for Notion power users. You should be familiar with Relations and Linked Databases before worrying about them. A self-referential filter is a filter inside a database template that updates itself when you create a new page from that database template. Specifically, a self-referential filter: Is set on a Linked Database that is placed within a database template. Filters a Relation property, which targets the database that contains the database template. Targets the database template itself. Essentially, a self-referential filter helps you filter a linked database view so that it only shows rows that are related to the page that contains that linked database. When you set it up in a database template, you set it to target the template itself ‚Äì but when you create a page from that template, the filter updates itself! Here‚Äôs a look at one in action. Here, I‚Äôm editing the Project Template in the My Projects database. I‚Äôve created a linked database, which points to the My Tasks source database. In the filters, I‚Äôve set up a filter that states: Project contains Project Template This means that only rows with Project Template set in their Project Relation would show up here. Of course, filtering for Project Template wouldn‚Äôt be very helpful. It‚Äôs a template, not an actual project. But watch what happens when I create a new project ‚Äì Suit Redesign ‚Äì and generate its page content from the Project Template: As you can see, my filter has automatically updated itself! Now it reads: Project contains Suit Redesign Crucially, I didn‚Äôt have to edit the filter myself. That‚Äôs the beauty of a self-referential filter; it auto-updates so that it targets your current database page instead of the database template. Rollups The Rollup property type allows you to pull property information from any rows that are connected to your current row through a Relation. You can also perform calculations on that information. To create a Rollup, add a new property just as you‚Äôd do for all other property types. Then set the Relation, Property, and Calculate options (explained below). Here, I have a Rollup called Undone Count in the My Projects database. It‚Äôs configured to show the state of the Done property for each of the rows that are related to my Suit Redesign row: See how the Rollup essentially allows me to pull information about the properties in these related rows? Not only that, but it collects this information in a single area; in other words, the information is ‚Äúrolled up‚Äù! Rollups have three configuration options: Relation ‚Äì the Relation property in your current database that you‚Äôd like to ‚Äúreach through‚Äù Property ‚Äì the Property in the database where the other side of the Relation exists (e.g. my Tasks Relation points to the My Tasks database, so it‚Äôs targeting the Done property of the rows there) Calculate ‚Äì the way in which you‚Äôd like to display the information By default, Rollups will use the Show Original setting within the Calculate dropdown. However, you‚Äôll find lots of other choices depending on the property type that you‚Äôre rolling up. If I set Calculate to Unchecked, I get a count totaling all the unchecked rows related to this project. In this case, both of the related tasks have been done, so the count is 0. Formulas Learn even more about formulas in my comprehensive Notion formula reference guide. Or, if you‚Äôre short on time, check out my one-page Notion formula cheat sheet. The Formula property type allows you to write formulas that can: Pull in data from other properties Format and change data Do complex calculations Run if-then scenarios with multiple potential outcomes Notion‚Äôs formula property is by far its most complex, and there‚Äôs essentially no limit to what you can do with it. Fun fact: My Ultimate Brain template contains a 10,000-character formula that does complex recurring-date calculations directly in Notion! You can create a formula property in Notion in the same way that you‚Äôd create any other property. From there, you can click the property‚Äôs content area to open up an editor where you can write formula code: Underneath the editor, you‚Äôll find a list of properties, functions, and more that you can use to create your formula. These include: Properties ‚Äì includes all the properties in your current database Constants ‚Äì such as e, pi, true, false Operators ‚Äì if, add, subtract, greater than, less than, etc. Functions ‚Äì join, slice, format, toNumber, etc. Since this is an overall guide to Notion databases, I won‚Äôt delve too deeply into how to write formulas here ‚Äì check out the full formula reference guide for that. For this post, I‚Äôll share two example formulas and explanations that will help you get started with writing your own formulas. Both of these can be found in the Simple Task Manager example template! Formula Example 1: Combine Numbers and Text The first formula we‚Äôll cover can be found in the My Projects database within the Simple Task Manager template. The property is called Meta, and it simply takes the number from the Undone Count property and formats it to look nicer. Here‚Äôs the ‚Äúcompact‚Äù version of the formula that you can easily paste into Notion: format(prop(\"Undone Count\")) + \" Tasks Left\" Note: If you paste this formula into a brand-new Notion database, you‚Äôll need the Undone Count property to exist first. Otherwise, you‚Äôll get a Property Not Found error. I prefer to write my formulas in a code editor (such as VS Code) and then make them compact using this Excel Formula Beautifier (which can either ‚Äúbeautify‚Äù code or compress it). As the name implies, it‚Äôs meant for Excel formulas ‚Äì but it works perfectly on Notion formulas as well. In fact, Notion‚Äôs formula syntax is extremely similar to Excel‚Äôs formula syntax. Here‚Äôs a version of the formula that‚Äôs easier to read: format( prop(\"Undone Count\") ) + \" Tasks Left\" The first part of this formula is: format(prop(\"Undone Count\")). It uses the prop() function to pull in the value of the Undone Count property, which is a Rollup (see the Rollup section above to learn more about those). I‚Äôm wrapping prop(\"Undone Count\") within the format() function in order to turn it into a String (which is basically just text). Notion formulas can output four different data types: String (plain text) Number Date Boolean (true/false, shown as a checkbox) However, a single formula can only output one data type. In other words, you can‚Äôt mix data types. Instead, you need to convert data types so that all of your output has the same type. The Undone Count Rollup property outputs a number, but ultimately my formula needs to output a string ‚Äì e.g. ‚Äú3 Tasks Left‚Äù. To achieve that, I use format() to transform that number into a string. It still displays as a number, but since it‚Äôs a plain-text string now, it can no longer be used in calculations (addition, multiplication, etc). Finally, I use the + operator to add my formatted number to this string: Tasks Left. Put them together, and you achieve a data-driven final output, such as: 3 Tasks Left! Formula Example 2: If-Then Statement Next, let‚Äôs look at how you can create variable output in a formula by using an If-Then statement. In the My Tasks database within the Simple Task Manager, I‚Äôve created a formula property called State. This property outputs a different symbol based on the status of the task: ‚è∞ = task is overdue üòÅ = task is done üü¢ = task is due today or later Here‚Äôs the compressed formula code, which you can easily paste into Notion: if(prop(\"Done\") == true, \"üòÅ\", if(dateBetween(now(), prop(\"Due\"), \"days\") > 0, \"‚è∞\", \"üü¢\")) Note: If you paste this formula into a brand-new Notion database, you‚Äôll need the Done and Due properties to exist first. Otherwise, you‚Äôll get a Property Not Found error. And here‚Äôs an expanded version of the formula that‚Äôs easier to read: if( prop(\"Done\") == true, \"üòÅ\", if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"‚è∞\", \"üü¢\" ) ) This formula has an if-then statement with another if-then statement nested inside it. By nesting if-then statements, we can create a formula that has more than two possible outcomes. To help you fully understand this formula, let‚Äôs first break down how if-then statements work. The basic syntax for an if-then statement in Notion is: if([test condition],[outcome if true],[outcome if false]) Essentially, we run a test, then define what do to if that test passes, and what do to if it fails. Here‚Äôs a bare-bones example: if(prop(\"Done\") == true,\"üòÅ\",\"üò°\") The == operator is testing whether the two pieces of information on either side of it are the same. Done is a checkbox property (with the data type boolean), so it outputs true or false. If the output of Done matches true, then the first option will be output: üòÅ. If not, Notion will output the second: üò°. Here‚Äôs where things get interesting ‚Äì either of the output paths in an if-then statement can contain additional functions. This can include more if-then statements! So let‚Äôs walk through the nested if-then statement from our example above: if( dateBetween( now(), prop(\"Due\"), \"days\" ) > 0, \"‚è∞\", \"üü¢\" ) This statement will only be evaluated if the outermost if-then statement ‚Äì if(prop(\"Done\") == true ‚Äì returned false. This inner if-then statement tests to see whether the task is overdue or not. To do that, it uses the dateBetween() function, which finds the amount of time between two dates. I‚Äôm passing three arguments to this function: The now() function, which is built into Notion and returns the current date and time prop(\"Due\"), which returns the task‚Äôs due date \"days\", which simply specifies the unit of time dateBetween() should count by Finally, I check if the output of dateBetween() is greater than (>) zero. If it is, then the task is overdue and my formula outputs the ‚è∞ symbol. If not, the task is not overdue and the formula outputs the üü¢ symbol. As you can see, Notion formulas are extremely flexible and powerful. It‚Äôs also worth noting that practicing with Notion formulas is a good first step into actual programming if that‚Äôs something that interests you! Locking Databases Databases can take a long time to configure, and chaos can ensue if someone accidentally deletes a property, changes the settings of a view, or messes with a formula. Fortunately, Notion allows you to lock your databases in order to prevent these kinds of changes. To lock a database, first navigate to its original location. Open up the View Options menu and click Lock Database: When a database is locked, you won‚Äôt be able to make changes to its structure. You‚Äôll still be able to create new rows and set property values, but you won‚Äôt be able to: Add new properties Delete properties Change property settings (e.g. change a formula) Add/edit/delete options from a Select or Multi-Select property Fortunately, if you need to make a change, you can easily unlock the database by clicking the Locked button at the top. Note that you‚Äôll need to navigate to the original database to find this Locked button; you won‚Äôt see it on Linked Databases. Wrapping Up Whew ‚Äì we‚Äôre done. In this guide, we‚Äôve covered every main feature you‚Äôll find within Notion databases. You‚Äôre now ready to go out and start creating your own databases. Using the features we‚Äôve covered here, you‚Äôll be able to create useful tools that fit your individual workflows and tasks like a glove ‚Äì rather than relying on old-school productivity tools that don‚Äôt quite match the way you want to work. To learn even more about Notion, head to the Notion Fundamentals home page to check out all the lessons in this free series. You can also check out my Notion Templates, which can give you a head start and equip your workspace with an advanced task manager, note-taking system, habit tracker, and more. If you enjoy this content and want more, consider joining my Notion Tips email list! I‚Äôll keep you up to speed on my Notion courses, but also let you know when I publish new free tutorials and templates:","metadata":{"source":"https://thomasjfrank.com/notion-databases-the-ultimate-beginners-guide","title":"Notion Databases: The Ultimate Beginner‚Äôs Guide","date":"2022-06-03T16:37:44+00:00","contentLength":8787}},{"pageContent":"If you want to learn how to work directly with the Notion API, this tutorial will teach you how to do it ‚Äì even if you‚Äôre a beginner with no coding experience. In this tutorial, you‚Äôll learn: What the Notion API is and what it can do What an API is (in general) How to create a Notion API integration inside your Notion workspace How to send data to Notion via the Notion API How to create new pages in a Notion database via the Notion API How to read, understand, and actually use API documentation Lots of beginner-to-intermediate level JavaScript The Notion API already has great documentation, so here I‚Äôll be teaching you how to actually use the API by walking you step-by-step through a fun example project ‚Äì building a complete Pok√©dex in Notion! Many people have built Pok√©dexes in Notion by hand, but we‚Äôll build ours with zero manual data entry. Everything will be handled by the Notion API and a small JavaScript application that we‚Äôll build, which will automatically create an entry for each Pok√©mon. Here‚Äôs a look at the final product (you can also view this Pok√©dex directly on Notion): Each Pok√©mon has its own database entry with art, stats, description, and more. This is a great introductory project for learning how to work with the Notion API. And once you‚Äôve completed it, you‚Äôll have the knowledge and skill to do nearly anything else with the API. I have many more API tutorials planned, so if you‚Äôd like to get notified when they go live, join my Notion Tips newsletter. You won‚Äôt need any special software for this project ‚Äì we‚Äôll do everything in the browser using free tools. We‚Äôll even code in the browser (of course, you can use your own local code editor if you want). I‚Äôve also included deep explanations (in handy collapsible toggles) and external links that explain everything, so you‚Äôll be able to use this as a true zero-to-hero path for learning Notion‚Äôs API. There‚Äôs even a fully mapped-out learning path below. Every Pok√©mon will get its own Notion database entry that includes its stats (HP, attack, defense, etc), types, flavor text, artwork, and more. We‚Äôll accomplish this by building a simple JavaScript application that pulls all of this data from Pok√©API, a free and open-source resource with an immense amount of information on all things Pok√©mon. Our app will then format the data and send it to Notion. Note: This tutorial is meant for those who want to work directly with the Notion API using a programming language like JavaScript. If you‚Äôd like to work with the Notion API using no-code tools (like Make.com), check out this tutorial instead: How to Send YouTube Data to Notion (No Code) ‚Äì Notion API Tutorial A step-by-step guide for importing YouTube views, likes, and other statistics directly into Notion ‚Äì automatically, with no coding required. thomasjfrank.com What is the Notion API? To kick this off, let‚Äôs talk a bit about what the Notion API actually is. The Notion API is a set of tools that allow you to connect your Notion workspace to other apps and services outside of Notion (including apps you build yourself). Using the API, you could: Add new rows to a sales database in Notion when customers make purchases on your online store (using a platform like Lemon Squeezy or Shopify) Auto-transcribe voice notes using a service like Deepgram and send the transcript to a Notion page (tutorial on this coming soon! Join the newsletter to get notified.) Use Notion as a CMS for blog posts and display them on a custom-built website (like Braydon Coyer does ‚Äì though you can also use Notaku for this instead of building a site from scratch) ‚Ä¶and much more. The possibilities are basically endless. The Notion API provides endpoints for many major functions, including: Querying, creating, and updating databases Retrieving, creating, updating, and archiving pages Retrieving, creating, updating, and deleting blocks Appending child blocks to a parent block Listing workspace users and retrieving specific user information Creating and retrieving comments All API requests to the Notion API must be sent to the base URL https://api.notion.com, which you‚Äôll see as the first part of the listed endpoint for any action you‚Äôd want to take. For example, if you wanted to query a database, you‚Äôd send a POST request to: https://api.notion.com/v1/databases/{database_id}/query Notion requires all API requests to be made over HTTPS, and they must be authenticated properly. To make API requests to your workspace, you‚Äôll first need to create an integration (we‚Äôll cover this later), then give that integration explicit access to pages in your workspace. Notion also provides a JavaScript SDK for working with the API. As you‚Äôll see later in the tutorial, it‚Äôs easy to add this to your project, and it gives you access to handy methods that make API requests easy to construct in your code. If you‚Äôd like a more thorough overview, check out the official API documentation‚Äôs introduction. However, I think you‚Äôll get a better grasp on the API by actually working with it ‚Äì so let‚Äôs start doing that! If you do happen to want a primer or refresher on what an API is (in general), check out the toggle block below. What is an API? (General API Definition & Primer) APIs (Application Programming Interfaces) are sets of tools that allow different web services to talk to each other over the HTTP protocol. An API can allow one service to read data from another one; alternatively, it can allow one service to create new data at another service, update existing data, or even delete data. You‚Äôll often see another acronym used to describe these four potential operations: CRUD. Create Read Update Delete APIs are what allow you to posts Giphy GIFs directly in Slack. They enable those awesome link previews that you can create in a Notion page. And they are the many engines under the hood of connector tools like Zapier and Make.com. APIs typically consist of one or more URLs, to which your application can make HTTP(S) requests in order to do one or more CRUD operations. These URLs are often called endpoints. Note: You may have a conversation in the future about APIs with a nerd who will stress that you access URIs, not URLs. The distinction really does not matter here, but here‚Äôs an article on their differences if you‚Äôre curious. In most cases, APIs will have separate endpoints for each type of operation you can do. In other words, you‚Äôll almost never use the same endpoint to both read data and delete data. To see how an API actually works, let‚Äôs look at an example from PokeAPI ‚Äì the API we‚Äôll be working with later in the tutorial. One of PokeAPI‚Äôs endpoints is the pokemon endpoint, accessible via either one of these URL schemes: https://pokeapi.co/api/v2/pokemon/[pokemon name] https://pokeapi.co/api/v2/pokemon/[pokemon number] To access information about Charmander, you‚Äôd either use https://pokeapi.co/api/v2/pokemon/charmander or https://pokeapi.co/api/v2/pokemon/4. Since PokeAPI doesn‚Äôt require any special kind of authentication, you can even visit these URLs in your browser. Here‚Äôs a link you can try. However, you‚Äôll quickly realize that visiting that URL in the browser isn‚Äôt very useful; you‚Äôre just presented with a huge string of JSON. I‚Äôll cover JSON more thoroughly later, but you can watch this video now if you‚Äôre curious about what it is and how it works: However, if you make that request from a program, you can use additional code to process that JSON response and do really useful things. For example, you could write code that goes through all that data, pulls out the Pokemon‚Äôs name, and displays it. I show this example later in this guide (click here to jump to it), so I won‚Äôt repost it here. Of course, you can do much more than just display the Pokemon‚Äôs name. Once you have the information, you can do basically anything with it, so long as you know how to write the required code. That‚Äôs the power of an API: It allows you to do CRUD operations, and then combine them with any sort of code you want to write. The applications are basically limitless. To wrap up this small primer, I‚Äôll go over the five most common HTTP methods available to you when working with APIs. You‚Äôll see these all the time, so it‚Äôs good to be familiar with them. GET ‚Äì used for reading data from the application. It is read-only, so it has no risk of modifying any data. POST ‚Äì sends data to the application to create something new. PUT ‚Äì sends data to the application to update an existing resource. Contains a full updated copy of the resource. PATCH ‚Äì also updates an existing resource, but only contains the changes to be made instead of the entire updated resource. DELETE ‚Äì sends an instruction to the application to delete an existing resource. In many cases, your requests to a particular API will need to contain both the URL to be accessed and the method to be used. For example, if you want to create a page in Notion via the API, you‚Äôll need to access the https://api.notion.com/v1/pages endpoint using a POST request. You‚Äôll learn much more about APIs simply by working through this project. However, you can also get additional insight with the following resources. First, check out Fireship‚Äôs excellent (and short) overview: If you fancy long videos, you may also enjoy freeCodeCamp‚Äôs APIs for Beginners course (though you could also just watch the video version of this tutorial near the top of this page! ‚ÄúWhat If I Don‚Äôt Know How to Code?‚Äù In this project, we‚Äôll build our application using JavaScript. So if you have a basic understanding of JavaScript, you‚Äôll be more comfortable going through it. However, you don‚Äôt need to already know JavaScript to go through this tutorial. My entire goal with this tutorial is to help non-technical people dip their toes into the world of coding and working with the Notion API. I‚Äôve gone to great lengths to make it a truly comprehensive resource. Read this if you‚Äôre feeling anxious or overwhelmed about coding If you don‚Äôt know how to code ‚Äì if you get confused and overwhelmed at most coding tutorials ‚Äì I‚Äôve been in your shoes. At the beginning of last year (2022), I didn‚Äôt know how to code. I barely knew what an API was. I tried to watch tutorials, but I‚Äôd get confused when the creator would throw around terms like ‚Äúnpm‚Äù, ‚Äúnode.js‚Äù, and ‚ÄúAPI endpoint‚Äù without explaining them. Eventually, after much Googling and a lot of frustration, things started to click for me. Hopefully I can spare you some of that frustrated Googling (Froogling?) with this tutorial. As you‚Äôll see later, I‚Äôve added lots of toggles just like this one throughout the tutorial. The purpose of these is to give you an explanation for everything if you need it (and keeping these explanations in toggles lets more experienced coders skip past them easily). However, the best piece of advice I can give you for learning how to do is this: Run your code early and often. The true ‚Äúbest‚Äù way to learn how to code is to write a lot of code and to get lots of feedback. Luckily, you get feedback pretty quickly when you‚Äôre coding; when there‚Äôs an error, it‚Äôll be logged in your console or somewhere else. So dive in and get your hands dirty! To build any skill, you need 3 ingredients:1. Quality instruction2. Deliberate practice3. FeedbackMost people don't get nearly enough of #3 because they're too afraid of making mistakes or getting judged.Don't be one of them.Try often, get judged often, learn faster.‚Äî Thomas Frank (@TomFrankly) October 20, 2022 As we go through this tutorial, I‚Äôll include asides and primers about all of the tools and concepts we‚Äôll use. However, I‚Äôve also collected them all in this learning path toggle, enabling you to find them all in one place. Full Learning Path and Resource List This project involves working with several tools, two different APIs, and multiple JavaScript programming methods and concepts. Here, I‚Äôve compiled a full list of all of these things, along with some general resources you can use to learn JavaScript more comprehensively. I encourage you to use this as a reference, but don‚Äôt let its length intimidate you! If you follow the rest of the tutorial, I‚Äôm confident that you can get the entire project working even if you don‚Äôt understand everything right away. Once you do, you‚Äôll be in a better position to go back, dig into these resources, and really understand how they all fit together. Tools Used in This Project This is a list of the specific tools and libraries we‚Äôll use in this project. Since we‚Äôll be building in Glitch, you don‚Äôt really need to worry about their details ‚Äì Glitch will take care of most of the work for you. Glitch ‚Äì a free platform for building websites and web apps. Includes everything ‚Äì a full code editor, Node.js backend, npm package manager, terminal, and more. Node.js (automatically set up by Glitch) ‚Äì a runtime for JavaScript. Allows you to run JavaScript code outside of the browser, effectively enabling JavaScript to be used as a back-end (server-side) language. Learn more about Node here. Npm (automatically set up by Glitch) ‚Äì the Node Package Manager. Allows you to very easily include external code libraries in your project and use them. There are thousands of packages, including one for Notion‚Äôs API. Pok√©API ‚Äì an open-source API that enables you to access pretty much any data related to Pok√©mon that you could ever want. Notion API ‚Äì Notion‚Äôs official API, which allows you to read, write, update, and delete resources in a Notion workspace. Axios ‚Äì a free HTTP library that works with Node.js. This is the library we‚Äôll use to access the Pok√©API. Note: You can also build this project on your local machine. I‚Äôm using Glitch because it keeps things extremely simple and takes care of the setup. If you want to go the local route, you‚Äôll need a code editor like VS Code. You‚Äôll also need to install Node.js and npm. JavaScript Learning Resources These free courses and general-purpose resources are great for developing a full understanding of JavaScript. JavaScript Algorithms and Data Structures ‚Äì a full, free, and interactive JavaScript course by freeCodeCamp. This is, IMO, the best beginner resource for learning JavaScript. The course has hundreds of mini-lessons, each of which teaches a concept and then has you actually use it in the in-browser code editor. I have only done the Basic JavaScript and ES6 sections of this course, personally. You absolutely don‚Äôt need to finish the entire course to understand this tutorial. That Weird JavaScript Course ‚Äì Fireship‚Äôs great series of YouTube videos on JavaScript. Each is super-entertaining and does a great job at explaining JavaScript at a high level. The Modern JavaScript Tutorial ‚Äì an excellent written guide to JavaScript. The MDN Web Docs ‚Äì the definitive technical reference for JavaScript. I‚Äôll be linking to this many, many times in this guide. Beginner JavaScript Notes ‚Äì a free ‚Äúcliff‚Äôs notes‚Äù version of Wes Bos‚Äô paid Beginner JavaScript course. JSFiddle ‚Äì a tool for running small code snippets in your browser. Great for testing things out without much required overhead. Specific Concepts This is a list of the individual concepts and programming patterns/data structures we‚Äôll use in this tutorial. I‚Äôve listed the actual methods we‚Äôll use separately below. These have been ordered roughly by their difficulty, and I‚Äôve included a recommended understanding level for each. This isn‚Äôt a requirement; I think you can work your way through this tutorial and refer to these concepts as you go. It‚Äôs more an indication of my own perceived understanding of each concept at the time I built this project. Concept Recommended Understanding Variables ‚Äì const vs. let Full Data types ‚Äì string, number, etc Full Variable scope Medium Boolean values ‚Äì truthiness and falsiness Full Console logging Basic Arrays Basic Objects Basic Accessing object properties Full Functions Basic Conditional statements Medium Ternary syntax (for conditionals) Full For loops Full For‚Ä¶of loops Full Try/catch blocks Basic Requiring modules in Node.js Basic REST APIs Basic Template literals Basic Arrow functions Medium Object destructuring Medium Destructuring nested objects Full Regular expressions Basic Promises Basic Async/await Basic Specific Methods We‚Äôll use several built-in JavaScript methods throughout this tutorial. Below, I‚Äôve linked to the documentation for each one on the MDN Web Docs. These are ordered alphabetically. Array.prototype.find() Array.prototype.join() Array.prototype.map() Array.prototype.pop() Array.prototype.push() setTimeout() String.prototype.replace() String.prototype.split() String.prototype.substring() String.prototype.toUpperCase() How to Go Further If you finish this tutorial and want to push your skills even further, here are a few challenge ideas: Use the Notion API and database relations to display the evolution chain for each Pok√©mon. Display a table within each Pok√©mon‚Äôs page that contains each move that it can learn. Push the data from your Notion Pok√©dex to a static website (example: Daniel Shiffman‚Äôs Nature of Code site uses Notion as a CMS) Steal My Code and Create a Pok√©dex Instantly If you just want the code you‚Äôll need to build a Pok√©dex, you‚Äôre in luck! I‚Äôve built this project on Glitch, which is a free platform that allows people to build and share working web apps and sites. Here‚Äôs the direct link to my Glitch project. There‚Äôs a handy Remix feature that allows you to fully copy my Pok√©dex project and run it for yourself. All you‚Äôll need to do is create a free Glitch account, hit the Remix button, and follow the instructions in the README.md file. Even if you intend to follow this tutorial and build the project from scratch, I‚Äôd encourage you to first Remix mine and see how it works! One of the most powerful ways to learn faster is to prime your brain by skipping ahead and getting a preview of what you‚Äôre trying to accomplish. Even if you don‚Äôt fully understand it, you‚Äôll be setting your brain up to more readily understand each piece of the process once you go back and start it in earnest. I‚Äôve also meticulously commented my code, so you can work through it and get an explanation of how everything works. To get the script running: Create a Glitch account and hit the Remix button on my project. Duplicate my Pok√©dex Template into your Notion workspace. Follow the instructions in this section ‚Üí Create Your Notion Integration Follow the instructions in this section ‚Üí Set Your Environmental Variables Open the Terminal. Type node index.js and hit Enter. By default, the script will pull the first 10 Pok√©mon into your Notion database. To change this, modify the start and end variables (lines 65 and 66 in index.js, or 18 and 19 in index-nocomments.js). Full Project Code I‚Äôm also going to share the full code for this project right here. As we work through the tutorial, I‚Äôll include smaller code snippets that focus on the specific part we‚Äôll be building at that point. However, you may want to reference the project code in its entirety; when that happens, just open one of these toggles. Full Project Code (No Code Comments) Remember that you can view this code directly on my Glitch project as well! It is located in the index-nocomments.js file. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage(); } getPokemon(); const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Full Project Code (With Comments) Remember that you can view this code directly on my Glitch project as well! It it located in the index.js file. /* Bring in the external packages we'll be using. Axios is an HTTP client that makes working with APIs easier: https://axios-http.com/docs/intro Additionally, we bring in the Notion API client so we can make requests to it. */ const axios = require('axios') const { Client } = require('@notionhq/client') /* Create a new object 'notion' that gives our code access to the Notion credentials set up in the .env file */ const notion = new Client({auth: process.env.NOTION_KEY}) /* Create a blank array in which we'll store an object for each pokemon fetched from the PokeAPI */ const pokeArray = [] /* Create a function for making requests to the PokeAPI. We have to use an asynchronous function becuause axios.get() returns a Promise. Without using an async function, the rest of our code would run before axios gets a response from the PokeAPI. */ async function getPokemon() { /* Define start and end variables for the 'for' loop below. These numbers would usually be set directly in the for loop itself, but I've made them into their own variables so you can easily tweak them. They correspond to actual Pokemon numbers - e.g. 1 = bulbasaur. */ const start = 1 const end = 10 /* This 'for' loop will make the first set of requests to the PokeAPI. We're using a basic 'for (let i = num)' loop because i will correspond to specific Pokemon numbers. So if you only wanted the original 151, you'd set start at 1 and end at 151. */ for (let i = start; i <= end; i++) { /* Use the axios.get() method to make a GET request to the PokeAPI's 'pokemon' endpoint: https://pokeapi.co/docs/v2#pokemon This endpoint allows to to access MOST of the information we need. The only info we can't get from this endpoint is flavor text, generation #, and category (e.g. \"Flame Pokemon\"). For that info, we'll have to query the 'pokemon-species' endpoint later on. Note how we're using a template literal in order to pass our `i` variable's value into the URL. This is what will allow us to call PokeAPI for the correct pokemon on each run of the loop, e.g. https://pokeapi.co/api/v2/pokemon/4 (when i = 4) will get Charmander. */ const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { /* Pokemon have a variable number of types (some have 1, some have 2). The Notion API expects Multi-Select property selections to come in the form of an array of objects, so we need to create an array of objects that we can pass when we're setting the 'Type' Multi-Select property's values. First, we store the types array from PokeAPI in the typesRaw variable. */ const typesRaw = poke.data.types /* Now we'll create a blank array that will contain our type objects, which will be formated specifically so they'll work with the Notion API. */ const typesArray = [] /* Create a for...of loop that will loop through all the elements of typesRaw. For each one, we'll create an object 'typeObj' which is formatted as needed for the Notion API, which which contains ONE of the Pokemon's types. Since the number of loop iterations is defined by the length of the typesRaw array, we'll end up with a new array (typesArray) that contains an object for each of the Pokemon's types. E.G. - Butterfree is Bug-type and Flying-type, so its typesArray will have two elements. */ for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } /* Add the object onto the end of typesArray */ typesArray.push(typeObj) } /* The PokeAPI returns very basic formatting for Pokemon names - e.g. 'Mr. Mime' is formatted as 'mr-mime'. We want to show names with proper punctuation and capitalization in Notion - e.g. 'Mr. Mime'. This is also important for auto-generating links to Bulbapedia, where more information about each Pokemon can be found (this is a basic Pokedex that doesn't include move information, locations, etc.) To accomplish this, we're running the poke.data.species.name object through several functions. First, the split().map().join() combo capitalizes the first letter of each word - e.g. 'mr-mime' becomes 'Mr Mime'. When methods are chained like this, they are executed left-to-right. So the return value of split() is fed into map(), and map()'s return value is fed into join(). Then, we run that result through a gauntlet of replace() calls to deal with edge case Pokemon like Type: Null, Ho-Oh, Mr. Mime, and Nidoran‚ôÄ - all of which include punctuation or symbols. Each replace() call looks for a regular expression match and replaces the first one it finds with the next argument. */ const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") /* Define a variable that holds the bulbapedia URL for the Pokemon. Bulbapedia has a very standardized URL scheme for Pokemon, so all we need to do is pass in the processedName variable and then replace any space characters it contains with underscores. All other special characters are left in the URL - even :,√©,-,etc. Example URL: https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pok√©mon) */ const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName .replace(' ', '_')}_(Pok√©mon)` /* Here we're defining a variable for the sprite using ternary syntax (? and : ) to create a conditional statement. We need to do this because certain Gen VIII Pokemon were introduced in Pokemon Legends: Arceus and do not have a sprite. The PokeAPI has an 'official-artwork' image for EVERY Pokemon, so we'll set the value of sprite to 'official-artwork' if a 'front_default' sprite doesn't exist. (!poke.data.sprites.front_default) is a Boolean check; if the value of this object is null, it'll evaluate to false. */ const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default /* Now we'll construct the object that will hold all of the data about this Pokemon. If you recall, we aren't able to pull generation, flavor text, or category from PokeAPI's 'pokemon' endpoint, so we'll add those to this object later. For now, each object property is being set to the value of the corresponding property returned from our first PokeAPI call. Note how ['official-artwork'] is defined differently. Property key names with dashes or spaces must be called using 'bracket notation' rather than 'dot notation'. */ const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } /* Send a log to the console with each fetched Pokemon's name. Doing this will allow the console to show activity the whole time the script is running. Without it, you'll just see a blank spot in your console while the script takes minutes to run. */ console.log(`Fetched ${pokeData.name}.`) /* Push our pokeData object onto the end of the pokeArray array. This is done each time our loop executes, resulting in an array full of objects - one for each Pokemon that you included in the loop (using the start and end numbers). Each object will look just like the pokeData object definition above, except the properties will contain actual information. If you want to see how these look, add console.log(pokeData) above this line. */ pokeArray.push(pokeData) }) .catch((error) => { /* if axios.get() fails and throws an error, this catch block will catch it and log it in the console. */ console.log(error) }) } /* We now need to call another PokeAPI endpoint to get three more pieces of information about each Pokemon: - Flavor text (e.g. \"Spits fire that is hot enough to melt boulders. Known to cause forest fires unintentionally.\") - Generation (e.g. I, II, III...) - Category (e.g. \"Flame Pokemon\", \"Owl Pokemon\") These must be obtained from the pokemon-species endpoint (https://pokeapi.co/docs/v2#pokemon-species) We now have all of the Pokemon we'll sent to Notion in pokeArray, so we'll now use a for...of loop to loop through that array, get the 'species' info for each element from PokeAPI, and add each piece of info to that pokemon's object in pokeArray. */ for (let pokemon of pokeArray) { /* Just like we did above, here we use axios.get() to call the PokeAPI endpoint we want. Note that this time we're passing the pokemon.number property from the current element of pokeArray (which is stored in the pokemon variable created in this loop) into the PokeAPI URL. */ const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { /* Create a variable to store the pokemon's flavor text. Depending on the pokemon, PokeAPI will have a differing number of flavor text options. These are all stored in an array called flavor_text_entries, and the English-language flavor text might be at any one of the indexes. See for yourself: Go to pokeapi.co and enter 'pokemon-species/charmander' in the testing box. Array index 0 (the first one) contains English-language flavor text. However, try 'pokemon-species/cramorant' and you'll see that the English flavor text doesn't show up until Array index 7. So instead of calling a specific array index, we have to search deeply inside the array's objects to find the one that has a 'language' object, which itself contains a 'name' property with a value of 'en'. To accomplish this, we call the find() method on the flavor_text_entries array, which returns the first array element that satisfies a test condition we'll set up though a function. That function is name === 'en'. To make sure the value of the nested 'name' property is fed into the function as the 'name' varible, we do what is called nested object destructuring. ({language: { name }}) tells find() that for each array element, go into its language object, then into the name property nested within, and pass name's value as the variable for the function. find() returns the full array element that matches the test condition, so we then tack on `.flavor_text` to get the value of its flavor_text property. Finally, we pass the found value through replace(/\\n|\\f|\\r/g, \" \") to replace any newline characters with spaces, resulting in a single line of flavor text. */ const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") /* Here we do the exact same thing as was done with the flavorText variable, except for the 'genus' property, which is PokeAPI's term for the category - e.g. \"Flame Pokemon\" */ const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus /* Now we get the pokemon's generation. It is returned in this format: 'generation-i' - but we want it to simply be 'I', so we run the result through split(/-/), which splits the string into an array using the dash character (-) as the divider. Then we use pop() to \"pop\" the last element of that array off of the array and return it - this will always be the generation number in Roman numerals, e.g. 'iv'. Finally, we pass that value through toUpperCase() to capitalize it - e.g. 'IV'. */ const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() /* Now we add our three new pieces of information to the current pokemon's object by creating three new properties within that object, and then assigning them the values from our three variables above. Note how pokemon['flavor-text'] uses bracket notation; this is required when an object property name has or will have spaces, dashes, or other special characters in it. Dot notation can only be used when property names contain letters, numbers, and underscores. */ pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation /* Add a log entry in the console each time this information is fetched from PokeAPI. */ console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { /* Log any errors thrown by axios.get(), just as in the previous loop block. */ console.log(error) }) } /* Once both loops have finished running, we call the createNotionPage() function which is defined below. It's important to note that we're calling this function within the getPokemon() function. Since getPokemon() is an async function, calling createNotionPage() outside of it (in the global context) will cause createNotionPage() to run before getPokemon() can finish construcing its array of objects. Calling it here forces createNotionPage() to run only after our two loops have completely finished fetching and formatting the data from PokeAPI. */ createNotionPage(); } /* Here's where we actually call the getPokemon() function. When you type `node index.js` in the Terminal to run this script, it immediately runs this function, which kicks off everything else. Note how we've defined additional functions below this; these are totally fine to exist below this line because JavaScript \"hoists\"function definitions to the top when it actually runs a .js file. Look up \"JavaScript Hoisting\" to learn more about this. */ getPokemon(); /* Create a \"wait\" function to comply with Notion API rate-limiting. The Notion API only allows ~3 requests per second, so after we create each new page in our Notion database, we'll call this sleep function and have it wait for 300ms. This will ensure that our app doesn't try to send data to Notion too quickly, which would cause our calls to eventually fail. */ const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; /* Create a function for sending our data to the Notion API. As with getPokemon(), this function has to be async because it is using axios.get(), which is an asynchronous method that returns a Promise first. Therefore, we must await it, and to do that it has to be inside an async function. */ async function createNotionPage() { /* Here's our main loop for the process of sending data to Notion. We already have our array of pokemon objects (pokeArray), so we can use a for...of loop to iterate through it. For each element, we'll construct a new object that formats the data in the way Notion wants. Then we'll create a new page in our Notion database with that data. */ for (let pokemon of pokeArray) { /* Here we'll construct the data object that we'll send to Notion in order to create a new page. This object defines the database in which the page will live (the \"parent\") and sets its icon, cover, and property values. It also adds a few blocks to the page's body, including the flavor text and a link to the pokemon's Bulbapedia page. I won't verbosely comment every piece of this object definition. Instead, I'll encourage you to study it and also point you to a few reference pages that you'll fine invaluable for working with the Notion API: - Property Values: https://developers.notion.com/reference/property-value-object - Block Objects: https://developers.notion.com/reference/block - Create a Page: https://developers.notion.com/reference/post-page Note how, for each block, we're setting the relevant property values to the variables in our pokemon object (except for the database ID, which is set by process.env.NOTION_DATABASE_ID). It's also useful to note that EVERYTHING in Notion is a block. The 'data' object will end up being a block that is recognized by Notion as a page due to the 'parent' value we're giving it (a database), and due to the fact that we're using the notion.pages.create() method to create it. However, you can see below that this block has children, which are blocks that will show up as its page content. Note that you can create 'block children' under nearly any block - not just under a page! See more: https://developers.notion.com/reference/patch-block-children */ const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } /* Here we call our sleep() function, passing it a value of 300 so that the loop \"sleeps\" for 300ms before going onto the next cycle. This ensures that we respect the Notion API's rate limit of ~3 requests per second. */ await sleep(300) /* Finally, we actually create the new page in our Notion database. First, we add a log item to the console for our own benefit. Then we call the notion.pages.create() function, which creates a new page in our database. We pass it our data object (defined above), which contains all of the necessary information. Finally, we store the Notion API's response in the response variable, and log it. */ console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } /* When the entire process is done, this will simply print \"Operation Complete\" in the console. */ console.log(`Operation complete.`) } Bonus: My developer‚Äôs take on the getPokemon() function As I mentioned above, I only learned how to code in JavaScript this year, so my skills are not well-honed. Fortunately, that doesn‚Äôt matter much. These days, computers are so powerful that simple applications can be built many ways. Even if the code isn‚Äôt perfectly-optimized, it‚Äôs ‚Äúgood enough‚Äù so long as it gets the job done and handles errors well. Still, there are often better ways to do things. To show you an example, below I‚Äôm sharing my full-time developer Eli‚Äôs take on the getPokemon() function. He readily admits that his code is less readable than mine, but it does result in a 40% reduction in code length. In professional setting, my code above would probably get refactored to look more like his. async function getPokemon() { const replacer = (str) => { const n = { \"Mr M\": \"Mr. M\", \"Mime Jr\": \"Mime Jr.\", \"Mr R\": \"Mr. R\", \"mo O\": \"mo-o\", \"Porygon Z\": \"Porygon-Z\", \"Type Null\": \"Type: Null\", \"Ho Oh\": \"Ho-Oh\", \"Nidoran F\": \"Nidoran‚ôÄ\", \"Nidoran M\": \"Nidoran‚ôÇ\", \"Flabebe\": \"Flab√©b√©\", } let pn = Object.keys(n).find((o) => str.includes(o)) return pn ? str.replace(pn, n[str]) : str } let urls = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=50`) .then((r) => r.json()) .then((d) => d.results.map(u => u.url)) let base = await Promise.all(urls.map(async (url) => { let d = await fetch(url).then((r) => r.json()) let name = replacer(d.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1) })[0]) return { name: name, number: d.id, types: d.types.map((t) => t.type.name), height: d.height, weight: d.weight, hp: d.stats[0].base_stat, attack: d.stats[1].base_stat, defense: d.stats[2].base_stat, specialAttack: d.stats[3].base_stat, specialDefense: d.stats[4].base_stat, speed: d.stats[5].base_stat, sprite: d.sprites.front_default, artwork: d.sprites.other['official-artwork'].front_default, bulbURL: `https://bulbapedia.bulbagarden.net/wiki/${name.replace(' ', '_')}_(Pok√©mon)`, } })) let flav = await Promise.all(base.map(async (p) => { let d = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${p.number}`).then((r) => r.json()) return { flavorText: d.flavor_text_entries.find(({language: {name}}) => name === \"en\"). flavor_text.replace(/\\n|\\f|\\r/g, \" \"), category: d.genera.find(({language: {name}}) => name === \"en\").genus, generation: d.generation.name.split(/-/).pop().toUpperCase() } })) return base.map((b, i) => ({...b, ...flav[i]})) } ‚Äã getPokemon().then((r) => { createNotionPage(r) }) What You‚Äôll Need to Get Started To successfully complete this tutorial, you‚Äôll need a few things: A Notion account. Even the free tier is able to work with the API! A Notion database that you‚Äôd like to use for your Pok√©dex (you can start with my template below). An integration in your Notion account. We‚Äôll create this in the first step of the tutorial. A free Glitch account. This is the platform where we‚Äôll build and run the application. Don‚Äôt Want to Use Glitch? You can also build and run this project locally on your own computer. Likewise, you could do things like the pros, pushing your code to Github and then deploying it to a company that can host Node.js apps such as Vercel. The reason I‚Äôve chosen to build this project on Glitch is because it gives you a complete starting point for free. We can code directly in the Glitch editor and then run our code directly in Glitch‚Äôs terminal. If you‚Äôd rather build this project locally, here are the prep steps you‚Äôll need to take: Get a code editor ‚Äì I recommend VS Code, as it has a built-in terminal for running your code along with many extensions and a huge community. Install Node.js and npm. The Node.js LTS installer should install both. Refer to this guide to see other ways to install (included the recommended-yet-harder nvm method), and to see how you can check that node and npm are indeed installed on your machine. Follow this guide to set up VS Code for a Node.js project and to move into the correct directory where you want to build your app. Once you have your project set up with a package.json file, type npm install axios in the terminal and hit Enter to add the Axios package to your project. It should show up in the package.json file under dependencies. Likewise, type npm install @notionhq/client in the terminal and hit Enter to install the Notion SDK package. Just like on Glitch, you‚Äôll need to create a .env file in your project and add your authentication details to it. However, Glitch automatically takes care of a few things you‚Äôll have to do manually here. First, type npm install dotenv and hit Enter in the terminal to install the dotenv package and add it to your package.json. (Glitch includes this by default.) In your project‚Äôs root directory (the same top-level folder where package.json is contained), create a filed called .env (no other file extension). Add your environment variables to this file and hit Save. Replace these default values with your Notion integration key and your target database‚Äôs ID. Refer to the Create a Notion Integration section for more detail on this. NOTION_KEY = blargablargblarg NOTION_DATABASE_ID = blargblarg At the top of your index.js file, you‚Äôll also need to include: require('dotenv').config() This will allow your app to access the variables defined in your .env file. You can test this by adding these lines to your index.js file, then running node index.js in the terminal: console.log(process.env.NOTION_KEY) console.log(process.env.NOTION_DATABASE_ID) If you plan on pushing your code to Github or otherwise using git for version control, you‚Äôll also want to create a .gitignore file in your project‚Äôs root directory. Then, add .env to that file and commit your .gitignore to your repo (see this more comprehensive guide for more detail): .env From there, you can follow the rest of the instructions in this tutorial. If you‚Äôd like to learn more about .env files and running things locally, see this guide: How to Use Environment Variables in Node You can use any database you want to create your Pok√©dex, but if you‚Äôd like a head start, you can use this free Pok√©dex Notion template I‚Äôve created for you. The template is an exact copy of my public Pok√©dex, minus all the actual Pok√©mon. It comes with all the properties and views pre-configured, so you can skip all of the database setup and get to coding. Since I‚Äôm providing this template, I won‚Äôt cover the database set up in this tutorial. However, if you want to learn more about setting up Notion databases, check out my beginner‚Äôs guide to Notion databases. You may also find my complete Notion formula guide helpful for understanding some of the formulas in this template! Tutorial Overview Before we start coding, let‚Äôs do a quick overview and cover what we‚Äôll be accomplishing. We know that we want to pull information about each Pok√©mon from Pok√©API and then create a new page in our Notion database for each Pok√©mon ‚Äì but how exactly will we do that? First, the prep work: We‚Äôll set up our Pok√©dex database on Notion, create a Notion API integration, and ensure the integration is able to edit the database (covered in the very next section). Once that‚Äôs done, we‚Äôll build the script that will actually execute the process of getting the data and sending it to Notion. Let‚Äôs break down the process. Don‚Äôt worry if you don‚Äôt know what GET and POST requests are ‚Äì I‚Äôll explain them as they come up! For each Pok√©mon, we‚Äôll send a GET request to Pok√©API. This will contain the URL that maps to the specific Pok√©mon we want information about ‚Äì e.g. https://pokeapi.co/api/v2/pokemon/4 (you can paste that link directly in your browser to see the response). Pok√©API will accept our GET request if it is formatted correctly. Pok√©API sends back a response that contains all of the Pok√©mon data we want, plus other meta info. The response contains way too much data, and it‚Äôs not always formatted perfectly. So we‚Äôll do some work to process the response directly on our web server (Glitch/Node.js). For each Pok√©mon, we‚Äôll create a custom JavaScript object called pokeData that will contain all the info we‚Äôll need. We‚Äôll do the work to extract and format the data from Pok√©API and add it to the pokeData object ‚Äì including name, height, weight, base stats, artwork, etc. We‚Äôll add each pokeData object to an array called pokeArray. Now we‚Äôll make a POST request to the Notion API for each Pok√©mon within pokeArray. Assuming our request is formatted correctly and authenticated, Notion will create a new page within our Pok√©dex database, setting property values and populating the page content with the information we sent over. Finally, the Notion API will send back a response that we‚Äôll simply log. Here‚Äôs a graphic that shows the entire process visually (you can also view this directly on Whimsical): Now that you‚Äôve got a map in your head for what we‚Äôll be building, let‚Äôs build it! Create a Notion Integration The first thing we‚Äôll do is create an integration within your Notion account. This integration will allow you to work with the Notion API and make changes to your workspace. Note: You‚Äôll also find these instructions in the getting started guide within the Notion API docs. We‚Äôll be referencing these docs a lot later on, and I highly recommend getting familiar with them if you plan on building more Notion API integrations! To start, make sure you‚Äôve duplicated my Pokedex template into your Notion workspace. This template contains all the properties and views you‚Äôll need. Next, you‚Äôll need to create an integration in your Notion account. Click here to go directly to the ‚ÄúMy Integrations‚Äù area of your account. Alternatively, you can find this page by going to Settings & Members within the Notion app, then navigating to My Connections ‚Üí Develop or Manage Integrations. Click New Integration. Fill out the Basic Information for your integration. You can leave most of the settings at their defaults, but set these as needed: Name: Any descriptive name. I‚Äôll use ‚ÄúNotion Pokedex Integration‚Äù in this guide. Associated workspace: Choose the workspace you want this integration to work with (aka the one that contains your Pokedex database). User capabilities: Set to no user infomation. This project doesn‚Äôt need user info, and it‚Äôs a good practice to limit integrations to only the capabilities they need. Click Submit. Once the integration has been created, you‚Äôll see a field where you can show your internal integration token. Copy this token to your clipboard; you‚Äôll need it when we start setting up the project in Glitch. Important: Keep this token secret. As this tutorial will show you, an integration token allows external tools and scripts to make changes to your Notion workspace. Show the token, then copy it to your clipboard. Additionally, note where it says, ‚ÄúOnly works with [your workspace name] workspace‚Äù. If you want to work with another workspace, you‚Äôll need to create another integration. You‚Äôll also be able to see that your integration is set as Internal rather than Public. This is what you want! I‚Äôm just pointing it out in case you‚Äôre unsure which one should be selected. Add Your Integration to Your Pokedex Database Before we can move on, we need to give your integration permission to edit your database. To do that, head to your Pokedex: Click the ‚Ä¢‚Ä¢‚Ä¢ icon in the top-right corner. Find the Connections sub-menu. Find and select your integration. You‚Äôll see the following message: Notion Pokedex Integration will have access to this and all child pages. Continue? Click confirm. Once connected, you‚Äôll be able to navigate back to that Connections menu and see your connected integration‚Äôs permissions for this page. Note that any child pages/databases of the current page will also be accessible to the integration. Now that your integration can modify your Pokedex page, we can move onto the next step! Create Your Glitch Project We‚Äôll be writing our actual code on Glitch, a free platform that lets you built and run websites and apps in a single, easy-to-use interface. To get started, head to Glitch and create a free account. Next, click New Project. You‚Äôll be given the choice of a few different starter apps, but you should actually click Find More, as the one we want isn‚Äôt shown here. From this new page, find the Hello Node! starter project and choose the blank version. While you can use the regular Hello Node! app (and I do in the video tutorial above), it comes with a bunch of extra stuff you don‚Äôt need. It also doesn‚Äôt come with a .env file by default, whereas the blank version does. Select the blank version of the Hello Node! app. Once done, Glitch will set up a new project that is pre-configured to run Node.js, the server runtime that will allow us to run JavaScript code directly from the terminal (instead of needing to run it in web page). What is Node.js? Node.js is a backend runtime environment that allows JavaScript to be executed outside of the browser. Originally, JavaScript was designed to be a programming language that could only run in a web browser. This was initially done for security reasons back when JavaScript was first being built in the mid-1990‚Äôs. Over time, people started using JavaScript for more and more purposes. What was once meant to be a simple scripting language started getting used to build complex web applications. In 2009, Node.js was released in order to allow developers to write the JavaScript syntax they were familiar with in other contexts. Node allows JS code to do all sorts of back-end tasks, like processing user data, reading and writing to file systems, and more. If you want to learn more about Node.js, watch this video: The Glitch app gives you a complete development environment. Here‚Äôs a quick tour, going over the most important parts: The editor is where you‚Äôll write your code. As you can see below, it can also render markdown files (.md files) with formatting. The sidebar gives you access to all of the files and assets within your project, and allows you to create more. You can also access your project settings here. The terminal will allow you to run your code. This is where we‚Äôll run your Pokedex script. The main thing you should do right now is create an index.js file. This will be the file where we write our JavaScript code in the next steps. To do this: Click the + icon next to Files in the sidebar. Name the file index.js. Click Add This File. For now, you can leave this file blank. We‚Äôll come back to it soon and start coding, but before that, we need to set up our environment variables and import a couple of packages. Let‚Äôs go! Set your Environment Variables For the script to be able to send Pokemon data to your Notion workspace, you‚Äôll need to provide it with two pieces of specific information: Your internal integration token (set when you created your Notion integration earlier) The database ID for your Pokedex database Both of these are private pieces of information that shouldn‚Äôt be shared. When developing Node.js apps (which we‚Äôre doing here), there‚Äôs a best practice for storing private pieces of information with which the program needs to directly interact, and that‚Äôs to store them in as environmental variables in a .env file. So that‚Äôs exactly what we‚Äôll do now, and we‚Äôll start by gathering these pieces of information. What is a .env file? A .env file is a special file that contains environmental variables. These are often variables that hold sensitive information, such as authentication tokes for API access. .env files are never pushed to version-control systems like git, meaning that programmers and teams can use services like Github and even share open-source code without exposing sensitive information. If you want to learn more, check out this video: You should already have your internal integration key from when you set up your Notion integration; if not, head back to the My Integrations page and copy it. Next, we‚Äôll get your database ID. Obtain Your Database ID Your database ID can be found within the URL of your Notion database. To find it, first navigate to your source database in Notion. If you‚Äôre using my Pokedex template, note that the template is a normal page that contains the source database. Click the Open as full page button on the database view to access the source database. Once you‚Äôre looking at your source database, copy its URL by going to the ‚Ä¢‚Ä¢‚Ä¢ menu and clicking Copy Link. Alternatively, you can use the shortcut ‚åò/Ctrl + L. Within your database‚Äôs URL, your database ID is the string of characters after the final / and before the query symbols ?v=. // Full URL https://www.notion.so/thomasfrank/c9cdd00ed7314f9497f4ab23e9fa0bdd?v=2d6e86289d304cd1ab5ba08a0d9ec1b4 // Database ID c9cdd00ed7314f9497f4ab23e9fa0bdd Copy your database ID and paste it in a temporary holding place along with your internal integration token. P.S. ‚Äì if you don‚Äôt have clipboard history enabled on your computer, now‚Äôs a great time to turn it on! On Windows, just hit ‚äû Win + V. If you‚Äôre on a Mac, get Raycast; it‚Äôs an incredibly powerful launcher tool with built-in clipboard history. Edit the .env File Now that you have your internal integration token and database ID, head back to Glitch. Your project should already have a .env file listed in the sidebar. If not, click the + one more time and create a file called .env. Add these two environmental variables. Ensure the labels are NOTION_KEY and NOTION_DATABASE_ID, but replace the example values with your own. NOTION_KEY=secret_LykgP0z2wvrYCiqAaWKu3j5uSokRvosbsqgWaHIjLw6 NOTION_DATABASE_ID=c9cdd00ed7314f9497f4ab23e9fa0bdd As the dialogue box pictured above will tell you, these environmental variable values will be visible to you and anyone else you specifically invite to edit your project. However, anyone else will merely see the variable names ‚Äì not the values. That means you‚Äôll be able to safely let people view (or even Remix) your project without revealing them. To learn more about how .env works in Glitch, check out their article on Adding Private Data. Add Your NPM Packages The script we‚Äôre building uses two external libraries that do a lot of the heavy lifting. These include The Axios HTTP library The Notion API‚Äôs JavaScript SDK Once we start coding, I‚Äôll explain what these libraries actually do in more detail. For now, we simply need to bring them into our project and set up index.js so that our code can access and use them. Luckily, bringing these libraries into our project is very easy. Node.js comes with a package manager called npm, which lets developers quickly import packages (which contain these libraries) into their projects. Normally, a developer would install a package by typing npm install into the terminal along with the name of the package. For example, you could install the dadjoke library into your project by typing: npm install dadjoke You can actually do this on Glitch, and I‚Äôll invite you to do so and then type dadjoke in the terminal to see what happens. For clarity: You do not need the dadjoke library for this project; it‚Äôs just a very simple library that you can easily use to test the npm install process. However, Glitch provides an even easier way to install packages. Simply head to your package.json file and click Add Package. From there, you can search for packages and click them to install. Search for and install the following packages. I‚Äôve linked their npm pages below in case you need to double-check that you‚Äôre installing the right ones. axios @notionhq/client Once done, you‚Äôll see that your package.json file has been updated with new depencies: \"dependencies\": { \"fastify\": \"^4.4.0\", \"handlebars\": \"^4.7.7\", \"@fastify/view\": \"^7.1.0\", \"@fastify/static\": \"^6.5.0\", \"@fastify/formbody\": \"^7.0.1\", \"axios\": \"^1.3.1\", \"@notionhq/client\": \"^2.2.3\" } Aside: NPM Packages Can Break (Here‚Äôs What to Do) As of this writing (Februrary 2023), both of the npm packages we‚Äôll use in this project are in a working state. However, I actually went through the experience of dealing with a broken npm package while making this tutorial. After I filmed the video version in November 2022, Axios had a buggy update that broke its ability to make API calls. To make my script work, I had to manually roll Axios back to the 1.1.3 version. Today, Axios‚Äô current 1.3.1 version is working ‚Äì so you (hopefully) shouldn‚Äôt have any troubles with it as you go through this tutorial. That said, if you find that Axios ‚Äì or any package ‚Äì isn‚Äôt working in the future, here‚Äôs what to do. First, check the package‚Äôs Github Issues page to see if others are posting about a potential bug. For example, here‚Äôs the Issue I ran into with Axios (you can even see a comment from me in this thread). Checking for Issues on Github can help you confirm that there‚Äôs a problem with the package itself, rather than your code. Second, simply roll back to an earlier version of the package and see if that works. Axios‚Äô 1.2 version broke my script, but I was able to roll back to 1.1.3 to get it working again. In Glitch, this is incredibly easy ‚Äì just go into package.json and change the version number of the package. Refresh the page, and Glitch will take care of the downgrade in the background. Note: If you want to ‚Äúlock in‚Äù a specific version of the package, take care to remove the caret ^ symbol ‚Äì read up on SemVer if you‚Äôre curious about that. E.g. 1.1.3 instead of ^1.1.3. Elsewhere (such as your own machine with Node.js installed), run the npm install command with the version you want specified, like so: npm install [email protected] Even if the package is already installed with a later version, this command will replace it with the older version you specify. More detail on how to do this can be found at this post: How to downgrade an installed npm package ‚Äì Nathan Sebhastian Learn how you can downgrade an npm package to rollback breaking changes sebhastian.com Now you‚Äôve got the packages installed in your project. Before you can use them, however, you‚Äôll need to ‚Äúrequire‚Äù them within your index.js file. Head over to index.js and add the following lines to the top of the file (which should currently be blank): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) For our purposes, it‚Äôs not incredibly important to know exactly how require() works. But if you‚Äôre curious, here‚Äôs a great article: Everything you should know about ‚Äòmodule‚Äô & ‚Äòrequire‚Äô in Node.js by Srishti Gupta Everything you should know about ‚Äòmodule‚Äô & ‚Äòrequire‚Äô in Node.js Modules > Node.js treats each JavaScript file as a separate module. For instance, if you have a file containing some code and this file is named xyz.js, then this file is treated as a module in www.freecodecamp.org Make Your First Call to Pok√©API We‚Äôre finally ready to start coding! In this step, we‚Äôll make our first call to PokeAPI and log the name of a Pokemon in the Glitch terminal. First, let‚Äôs look at how this actually works. In this Replit embed, I‚Äôve created a very simple script that will call PokeAPI once. Go ahead and hit Run to see what happens. If everything went smoothly, you should see bulbasaur displayed in the terminal. Here‚Äôs a look at the code: const axios = require('axios') async function getPokemon() { await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) } getPokemon() This very simple script does three things: Uses require('axios') to make the axios library‚Äôs methods available for use in the script Defines an asynchronous function getPokemon(), which will call PokeAPI and console log the name of the first pokemon Calls the getPokemon() function in order to run it Once the function is called, the code inside it runs. Here, we‚Äôre only doing two things: Using the axios.get() method to call a specific resource within PokeAPI. In this case, it‚Äôs the first entry in the pokemon resource, which contains data about bulbasaur. Once we get the response, we use JavaScript‚Äôs built-in console.log() function to display the pokemon‚Äôs name in the terminal PokeAPI returns JSON data, so we access specific pieces of that data by using dot notation. To get the name, we have to traverse the JSON data tree. Property accessors ‚Äì JavaScript | MDN Property accessors provide access to an object‚Äôs properties by using the dot notation or the bracket notation. developer.mozilla.org PokeAPI is mainly a learning tool, and they actually have a great interface for exploring the API‚Äôs data right on their homepage. I‚Äôd encourage you to check it out if you want to understand the JSON data structure found in the response a bit better. Here‚Äôs a screenshot showing the name that we‚Äôre accessing: Here, you can see that there‚Äôs a species object, which contains a property called name. (There‚Äôs also a separate name property as well, but I‚Äôve found that the species.name property is more reliable to use). Note: You can see all of the properties accessible via this pokemon endpoint at the endpoint‚Äôs page in the official Pok√©API docs. Of course, in the code above, we‚Äôre accessing: console.log(poke.data.species.name) So where does the poke.data part come into play? poke is a variable that we declare, which holds the entirety of the response from PokeAPI. Let‚Äôs look at the API call: await axios.get(`https://pokeapi.co/api/v2/pokemon/1`).then((poke) => { console.log(poke.data.species.name) }) I‚Äôll cover the await part in a second; right now, let‚Äôs look at the part that says .then((poke) => ... and break that down. The code axios.get(`https://pokeapi.co/api/v2/pokemon/1`) calls the PokeAPI to get the resource stored at https://pokeapi.co/api/v2/pokemon/1. Once the call is finished, we need to do something with the response. The .then() function allows us to do this. Within it, we‚Äôre both defining and calling a function (using an arrow function) which stores the entire response in a variable called poke. It then uses console.log() to log the poke.data.species.name property‚Äôs value. Using .then() just keeps our code nice and concise. We could re-write it using an old-school function declaration and get the same result: async function getPokemon() { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/1`) log(poke) } function log (poke) { console.log(poke.data.species.name) } But this is more verbose, so using .then() is preferable. Next, let‚Äôs address the data property in poke.data.species.name. We don‚Äôt see that on the PokeAPI website‚Äôs example response, so where is it coming from? As it turns out, the response we get from PokeAPI contains a lot of information. We get a status code, headers, config information, and a lot of other information that we generally don‚Äôt need to worry about (but that‚Äôs good to have for debugging in case something goes wrong). The entire response is contained within an object, and inside that object there is another nested object called data. This data object contains all the information that you can see on the PokeAPI homepage‚Äôs sample response. More on objects: Objects javascript.info In the accordion block below, I‚Äôve included the entire response that PokeAPI returns for this API call. Take a second to look through it and identify the data object. Full PokeAPI Response (Sample) This is the entire response returned by PokeAPI for this API call. Find the data object within it to see how we‚Äôre accessing the pokemon‚Äôs name (line 238). Note that, by default, console.log() won‚Äôt fully show the details of objects that are nested many layers deep. For that reason, most of the information in the data object is simply labeled [Object]. However, when you access specific properties in your code, you‚Äôll get the actual values. For example, poke.data.species.name has a value of bulbasaur, which we were able to see in the console in the Replit embed above. { status: 200, statusText: 'OK', headers: AxiosHeaders { date: 'Fri, 09 Dec 2022 20:29:25 GMT', 'content-type': 'application/json; charset=utf-8', 'transfer-encoding': 'chunked', connection: 'close', 'access-control-allow-origin': '*', 'cache-control': 'public, max-age=86400, s-maxage=86400', etag: 'W/\"359f3-JlmmuiyGZkKyOFlSvLzln1IpB6Q\"', 'function-execution-id': 'tkmw3o8u9p36', 'strict-transport-security': 'max-age=31556926', 'x-cloud-trace-context': '3dba91851bd1a57c6ea5dade1ac7e883', 'x-country-code': 'US', 'x-orig-accept-language': 'en-US', 'x-powered-by': 'Express', 'x-served-by': 'cache-iad-kiad7000067-IAD', 'x-cache': 'HIT', 'x-cache-hits': '1', 'x-timer': 'S1669043889.601956,VS0,VE1', vary: 'Accept-Encoding,cookie,need-authorization, x-fh-requested-host, accept-encoding', 'alt-svc': 'h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400', 'cf-cache-status': 'HIT', age: '51296', 'server-timing': 'cf-q-config;dur=6.9999987317715e-06', 'report-to': '{\"endpoints\":[{\"url\":\"https:\\\\/\\\\/a.nel.cloudflare.com\\\\/report\\\\/v3?s=4KTK4BOb7zSytazr61FEYksT%2BVDQfvoEhzU6Ph%2FYbVr%2Bc9ZgsACueHvhFQy5%2BsijYeXyqKyD3Vo7sBe%2FieNvBWwCdvO%2B55koSkx9YXvyuZQXrpitHk2UCZt3rUoa\"}],\"group\":\"cf-nel\",\"max_age\":604800}', nel: '{\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}', server: 'cloudflare', 'cf-ray': '77707e289bca208d-IAD', [Symbol(defaults)]: null }, config: { transitional: { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, adapter: [Function: httpAdapter], transformRequest: [ [Function: transformRequest] ], transformResponse: [ [Function: transformResponse] ], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, maxBodyLength: -1, env: { FormData: [Function], Blob: null }, validateStatus: [Function: validateStatus], headers: AxiosHeaders { 'User-Agent': 'axios/1.1.3', 'Accept-Encoding': 'gzip, deflate, br', [Symbol(defaults)]: [Object] }, method: 'get', url: 'https://pokeapi.co/api/v2/pokemon/1', data: undefined }, request: <ref *1> ClientRequest { _events: [Object: null prototype] { abort: [Function (anonymous)], aborted: [Function (anonymous)], connect: [Function (anonymous)], error: [Function (anonymous)], socket: [Function (anonymous)], timeout: [Function (anonymous)], prefinish: [Function: requestOnPrefinish] }, _eventsCount: 7, _maxListeners: undefined, outputData: [], outputSize: 0, writable: true, destroyed: true, _last: true, chunkedEncoding: false, shouldKeepAlive: false, _defaultKeepAlive: true, useChunkedEncodingByDefault: false, sendDate: false, _removedConnection: false, _removedContLen: false, _removedTE: false, _contentLength: 0, _hasBody: true, _trailer: '', finished: true, _headerSent: true, socket: TLSSocket { _tlsOptions: [Object], _secureEstablished: true, _securePending: false, _newSessionPending: false, _controlReleased: true, secureConnecting: false, _SNICallback: null, servername: 'pokeapi.co', alpnProtocol: false, authorized: true, authorizationError: null, encrypted: true, _events: [Object: null prototype], _eventsCount: 9, connecting: false, _hadError: false, _parent: null, _host: 'pokeapi.co', _readableState: [ReadableState], _maxListeners: undefined, _writableState: [WritableState], allowHalfOpen: false, _sockname: null, _pendingData: null, _pendingEncoding: '', server: undefined, _server: null, ssl: null, _requestCert: true, _rejectUnauthorized: true, parser: null, _httpMessage: [Circular *1], [Symbol(res)]: null, [Symbol(verified)]: true, [Symbol(pendingSession)]: null, [Symbol(async_id_symbol)]: 3, [Symbol(kHandle)]: null, [Symbol(kSetNoDelay)]: false, [Symbol(lastWriteQueueSize)]: 0, [Symbol(timeout)]: null, [Symbol(kBuffer)]: null, [Symbol(kBufferCb)]: null, [Symbol(kBufferGen)]: null, [Symbol(kCapture)]: false, [Symbol(kBytesRead)]: 6334, [Symbol(kBytesWritten)]: 175, [Symbol(connect-options)]: [Object], [Symbol(RequestTimeout)]: undefined }, _header: 'GET /api/v2/pokemon/1 HTTP/1.1\\r\\n' + 'Accept: application/json, text/plain, */*\\r\\n' + 'User-Agent: axios/1.1.3\\r\\n' + 'Accept-Encoding: gzip, deflate, br\\r\\n' + 'Host: pokeapi.co\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n', _keepAliveTimeout: 0, _onPendingData: [Function: noopPendingOutput], agent: Agent { _events: [Object: null prototype], _eventsCount: 2, _maxListeners: undefined, defaultPort: 443, protocol: 'https:', options: [Object], requests: {}, sockets: {}, freeSockets: {}, keepAliveMsecs: 1000, keepAlive: false, maxSockets: Infinity, maxFreeSockets: 256, scheduling: 'lifo', maxTotalSockets: Infinity, totalSocketCount: 0, maxCachedSessions: 100, _sessionCache: [Object], [Symbol(kCapture)]: false }, socketPath: undefined, method: 'GET', maxHeaderSize: undefined, insecureHTTPParser: undefined, path: '/api/v2/pokemon/1', _ended: true, res: IncomingMessage { _readableState: [ReadableState], _events: [Object: null prototype], _eventsCount: 5, _maxListeners: undefined, socket: [TLSSocket], httpVersionMajor: 1, httpVersionMinor: 1, httpVersion: '1.1', complete: true, headers: [Object], rawHeaders: [Array], trailers: {}, rawTrailers: [], aborted: false, upgrade: false, url: '', method: null, statusCode: 200, statusMessage: 'OK', client: [TLSSocket], _consuming: true, _dumped: false, req: [Circular *1], responseUrl: 'https://pokeapi.co/api/v2/pokemon/1', redirects: [], [Symbol(kCapture)]: false, [Symbol(RequestTimeout)]: undefined }, aborted: false, timeoutCb: null, upgradeOrConnect: false, parser: null, maxHeadersCount: null, reusedSocket: false, host: 'pokeapi.co', protocol: 'https:', _redirectable: Writable { _writableState: [WritableState], _events: [Object: null prototype], _eventsCount: 3, _maxListeners: undefined, _options: [Object], _ended: true, _ending: true, _redirectCount: 0, _redirects: [], _requestBodyLength: 0, _requestBodyBuffers: [], _onNativeResponse: [Function (anonymous)], _currentRequest: [Circular *1], _currentUrl: 'https://pokeapi.co/api/v2/pokemon/1', [Symbol(kCapture)]: false }, [Symbol(kCapture)]: false, [Symbol(kNeedDrain)]: false, [Symbol(corked)]: 0, [Symbol(kOutHeaders)]: [Object: null prototype] { accept: [Array], 'user-agent': [Array], 'accept-encoding': [Array], host: [Array] } }, data: { abilities: [ [Object], [Object] ], base_experience: 64, forms: [ [Object] ], game_indices: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], height: 7, held_items: [], id: 1, is_default: true, location_area_encounters: 'https://pokeapi.co/api/v2/pokemon/1/encounters', moves: [ [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object] ], name: 'bulbasaur', order: 1, past_types: [], species: { name: 'bulbasaur', url: 'https://pokeapi.co/api/v2/pokemon-species/1/' }, sprites: { back_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/1.png', back_female: null, back_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/shiny/1.png', back_shiny_female: null, front_default: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png', front_female: null, front_shiny: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/1.png', front_shiny_female: null, other: [Object], versions: [Object] }, stats: [ [Object], [Object], [Object], [Object], [Object], [Object] ], types: [ [Object], [Object] ], weight: 69 } } You may have also noticed the async and await keywords shown in our sample script. These have to do with asynchronous JavaScript and Promises, two topics that are intermediate-level in complexity. I‚Äôll explain them in the accordion block below and link you to some useful resources for learning them in more detail, but the gist is this: Axios is a ‚Äúpromise-based‚Äù library, and to use it correctly within our script, we need to use async and await. If we don‚Äôt, responses might come back from the PokeAPI out-of-order. Of course, there are other JavaScript tools for working with APIs that don‚Äôt force you to use Promises (like fetch), but I‚Äôm choosing to use Axios for this tutorial because it‚Äôs the default option used by Pipedream, which is an amazing automation platform that I‚Äôll be using for upcoming Notion API tutorials. More Detail on Pipedream Pipedream is a code-light platform that I‚Äôll be featuring in upcoming tutorials; it‚Äôs generally a much easier tool for working with the Notion API and creating automations compared to what we‚Äôre doing here. I‚Äôve used it personally to mirror Notion databases, send YouTube stats to Notion, create a speech-to-text automation, and more. I‚Äôm not using it for this tutorial because I want you to be fully aware of what‚Äôs happening while you learn the Notion API, and because you may want to go off and build apps on your own tech stack! So this tutorial is sticking to more general purpose tools ‚Äì but I did want to base it off of Axios so you‚Äôll be fully prepped when you deal with it on Pipedream. More About Async/Await and Promises Axios is a ‚Äúpromise-based‚Äù library, which means that when we use the axios.get() method, we get a Promise. In JavaScript, a Promise is essentially an IOU. It‚Äôs almost as if JavaScript is handing you a piece of paper that says: ‚ÄúI promise to give you the full results of this API call if it is successful. And if it fails, I‚Äôll give you details about the error. The actual response, be it the successfully-retrieved data from the API or an error message, comes later on once the Promise resolves. In general, this is quite useful because JavaScript is a single-threaded language, which means that it generally can only do one thing at a time. This can become a problem with API calls, because they can often take a (relatively) long time to execute. In a program where lots of things are happening, an API call can block additional code steps that would otherwise execute extremely fast. Promises allow that later code to execute before something like an API call finishes, since the Promise gets returned almost immediately. In complex applications, this means later code steps can do their thing, and then once the Promise resolves, you can take action on the actual response from the API. As I mentioned above, I‚Äôm choosing Axios for this project specifically because Pipedream uses it heavily and I‚Äôll be doing lots of Pipedream/Notion API tutorials in the future. However, what we‚Äôre doing here doesn‚Äôt really need Promises or async/await. Our script is going to get all the information about all the Pokemon before doing anything else, so we would be fine to go with a totally synchronous option here if we wanted. Still, asynchronous JavaScript can be very useful in other cases. If you want to learn more about it, here are some resources. First, I highly recommend watching this talk on the Javascript event loop if you want to understand how JavaScript can be ‚Äúasynchronous‚Äù despite being single-threaded: Next, I‚Äôd recommend watching my friend Daniel Shiffman‚Äôs series on Promises and async/await: JSInfo also has some great articles on these topics: Promises Async/await With all that preamble out of the way, let‚Äôs start coding! In the embedded Replit above, we made a single call to PokeAPI and logged bulbasaur‚Äôs name in the terminal. Let‚Äôs take that a step further and set the foundation for our script by adding the following code to index.js in our Glitch project (everything from here on out will go in index.js): const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Note: From this point on, we‚Äôll often be adding new code in between existing lines. Sometimes we‚Äôll even change existing lines. I‚Äôm doing it this way so the learning curve in this tutorial remains gradual. I‚Äôll make sure to highlight those lines in the code blocks that follow this one. Remember, you can always reference the full code (with or without comments) in the Steal My Code section above. In your terminal, type node index.js and then hit Enter to run your script. If you‚Äôve set things up correctly so far, you should get a list of the first 10 Pokemon: This code is very similar to the code in the embedded Replit example above. One change is the addition of these lines: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] The first two are creating a notion variable and bringing in the Notion SDK that we imported earlier, so we can use it within our script. We‚Äôll start using it in earnest below when we send our first page to Notion. We‚Äôre also creating an empty array with const pokeArray = []. As I mentioned in the tutorial overview, we‚Äôll be adding an object for each Pokemon to this array. Then, we‚Äôll loop through the array and create a new page in Notion for each of those Pokemon objects. Another big difference is that we‚Äôve added a for loop to the function; now we‚Äôre calling the PokeAPI from inside it. Loops: while and for javascript.info This means that we‚Äôre making a call to PokeAPI every time the loop executes. Additionally, we‚Äôve tweaked our axios.get() function call slightly. It now reads: axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) We‚Äôve wrapped our PokeAPI URL in template literals (the backticks ``), which allows us to use variables within it. Template literals (Template strings) ‚Äì JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org We can use ${} to reference a variable within our string; in this case, we‚Äôre referencing i, which increases by 1 each time the loop runs. In effect, each execution of the loop calls the next Pokemon from PokeAPI: https://pokeapi.co/api/v2/pokemon/1 https://pokeapi.co/api/v2/pokemon/2 https://pokeapi.co/api/v2/pokemon/3 ‚Ä¶and so on. The start and end variables define how many times the loop will run. Currently, we‚Äôve set them so that the loop runs 10 times, but hopefully you can see how tweaking them would let us get all 905 Pokemon! Finally, I‚Äôll point out the addition of the .catch() block of code: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) If our API throws an error for some reason, the catch block will be activated. Right now, we‚Äôre just logging the error in the console, but you could add more sophisticated error-handling code if you wanted. Learn more here: Error handling, ‚Äútry‚Ä¶catch‚Äù javascript.info Code Checkpoint At this point, your code should look exactly like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { console.log(poke.data.species.name) }) .catch((error) => { console.log(error) }) } } getPokemon() Format the Pok√©mon Data The next thing we need to do is construct an object that will hold the information about each Pokemon that we want to send to Notion. That information includes: Name Number Type(s) Category ‚Äì e.g. ‚ÄúFlame Pokemon‚Äù or ‚ÄúSeed Pokemon‚Äù Generation Height Weight HP Attack Defense Special Attack Special Defense Speed Sprite Official Artwork Flavor text Bulbapedia URL We could declare individual variables for each of these, but a better method is to construct an object and store the values inside it. In JavaScript, an object is a collection of key:value pairs. Object keys always have defined names, and the key:value pairs do not have a specific order (unlike arrays). Objects are heavily used in JavaScript, so check out this primer if you want to learn more about them: Objects javascript.info We‚Äôre going to create an object for each Pokemon that will store all of the data we want to send to Notion. For now, we won‚Äôt add all of the information. Instead we‚Äôll stick with a few basics ‚Äì name, number, height/weight, and basic stats. This will keep things simple; we‚Äôll add the other pieces later on. Remove the old console.log() line, and add the highlighted code within your .then() block: const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) In the pokeData object declaration, we are creating several keys, such as name, number, height, etc. The value that corresponds to each key is dynamically set by accessing a specific value from the poke object, which contains the entire response from Pok√©API. Later, we‚Äôll access the values of this object in order to send information to Notion. You can see that we‚Äôre already doing it once here: console.log(`Fetched ${pokeData.name}.`). After declaring the pokeData object and filling it up with values, we also add the object onto the end of our pokeArray array with pokeArray.push(pokeData). You may remember that we declared that array near the top of our code: const pokeArray = []. The [] symbols define the variable as being an array, but when it was declared, it was empty. In other words, it was an array with no elements inside it. Using the push method, we ‚Äúpush‚Äù our pokeData object onto the end of the array. You can learn more about how this method works here: Array.prototype.push() ‚Äì JavaScript | MDN The push() method adds one or more elements to the end of an array and returns the new length of the array. developer.mozilla.org Before we move on, you should also change your const end = 10 line to const end = 1 for now: async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { This will cause the script to fetch only the first Pok√©mon, Bulbasaur. Later, we‚Äôll change it to a higher number so we can fetch hundreds of Pok√©mon ‚Äì but for now, it‚Äôll keep things simpler if we fetch just one. Once again, run node index.js in your terminal. You should see a result like this: The console.table() method is another useful tool for seeing information in the terminal. It nicely formats data structures like objects, and by using it we can see all of the properties that we created within the pokeData object. I‚Äôve removed the console.table() line from my final code; you can choose whether or not to do the same. Leaving it in won‚Äôt change anything, as it‚Äôs just a logging tool. Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) }) .catch((error) => { console.log(error) }) } } getPokemon() Create Your First Page with the Notion API Now that we have a tidy little object full of Pok√©mon data, let‚Äôs send it to Notion and create the first page in our Pok√©dex! To do that, we‚Äôll declare a second function called createNotionPage() at the bottom of our code, beneath the getPokemon() function call. Additionally, we‚Äôll call the createNotionPage() within the getPokemon() function‚Äôs declaration, at the very end before its closing curly brace. Go ahead and add the highlighted lines to your code: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } We‚Äôll go through what this code does in a second. For now, we‚Äôre going to run the code and see what happens. First, you‚Äôll need to go to your Pok√©dex database‚Äôs ‚Ä¢‚Ä¢‚Ä¢ menu, go to Group, and set the No Generation option to visible. We currently aren‚Äôt passing generation information, so you‚Äôll need to do this in order to see the page you‚Äôre about to send to Notion. Next, go ahead and run node index.js in the terminal once more. If your code and .env variables are set up correctly, you should see something similar to this in your terminal: [email protected]:~ 23:48 $ node index.js Fetched bulbasaur. ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ (index) ‚îÇ Values ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ name ‚îÇ 'bulbasaur' ‚îÇ ‚îÇ number ‚îÇ 1 ‚îÇ ‚îÇ height ‚îÇ 7 ‚îÇ ‚îÇ weight ‚îÇ 69 ‚îÇ ‚îÇ hp ‚îÇ 45 ‚îÇ ‚îÇ attack ‚îÇ 49 ‚îÇ ‚îÇ defense ‚îÇ 49 ‚îÇ ‚îÇ special-attack ‚îÇ 65 ‚îÇ ‚îÇ special-defense ‚îÇ 65 ‚îÇ ‚îÇ speed ‚îÇ 45 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Sending bulbasaur to Notion { object: 'page', id: '64499d85-9748-4ddd-a08b-38a8c6dd6a2c', created_time: '2023-02-05T23:49:00.000Z', last_edited_time: '2023-02-05T23:49:00.000Z', created_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, last_edited_by: { object: 'user', id: '19c6f4cd-6e7d-40ef-8489-9983b28e1bf5' }, cover: null, icon: null, parent: { type: 'database_id', database_id: 'c9cdd00e-d731-4f94-97f4-ab23e9fa0bdd' }, archived: false, properties: { Height: { id: 'C%3FgF', type: 'number', number: 7 }, 'Weight (kg)': { id: 'Dn_%5D', type: 'formula', formula: [Object] }, Attack: { id: 'MRaQ', type: 'number', number: 49 }, 'HP Label': { id: 'MdMo', type: 'formula', formula: [Object] }, Weight: { id: 'N%3BN%7B', type: 'number', number: 69 }, 'Stats Meta': { id: 'NZS%7B', type: 'formula', formula: [Object] }, HP: { id: 'Rce%7D', type: 'number', number: 45 }, 'Sp. Attack': { id: 'U%7Bi%40', type: 'number', number: 65 }, 'Defense Label': { id: 'VRMi', type: 'formula', formula: [Object] }, Sprite: { id: '%5BlYm', type: 'files', files: [] }, No: { id: '%5DY%40D', type: 'number', number: 1 }, 'Ht/Wgt Meta': { id: 'cjoi', type: 'formula', formula: [Object] }, Speed: { id: 'dCkj', type: 'number', number: 45 }, 'Height (m)': { id: 'e%5DNz', type: 'formula', formula: [Object] }, Defense: { id: 'iLgx', type: 'number', number: 49 }, 'Height (ft)': { id: 'i%5DgP', type: 'formula', formula: [Object] }, Meta: { id: 'oBLz', type: 'formula', formula: [Object] }, 'No Label': { id: 'oLD%3B', type: 'formula', formula: [Object] }, 'Sp. Defense': { id: 'pmEd', type: 'number', number: 65 }, 'Weight (lbs)': { id: 'qT%5Er', type: 'formula', formula: [Object] }, Generation: { id: 'q%5CeI', type: 'select', select: null }, Type: { id: 'smaD', type: 'multi_select', multi_select: [] }, Category: { id: 'tESh', type: 'rich_text', rich_text: [] }, 'Attack Label': { id: 'xLfc', type: 'formula', formula: [Object] }, Name: { id: 'title', type: 'title', title: [Array] } }, url: 'https://www.notion.so/bulbasaur-64499d8597484ddda08b38a8c6dd6a2c' } Operation complete. You should also see a new Bulbasaur entry in your Pok√©dex: Congratulations! You‚Äôve just created your first page in Notion using the Notion API. If it didn‚Äôt work, make sure you added the line calling createNotionPage() right before the closing } in your getPokemon() function! Now let‚Äôs walk through these code additions and see what‚Äôs actually happening. The code we added here does five distinct things: Declares the createNotionPage() function. Creates a for...of loop, which allows us to iterate over the elements of pokeArray, performing the same set of actions (defined within the loop) on each one. Defines a data object, which is formatted in the way the Notion API wants, and which is filled with the values of the current object within pokeArray that the loop is working on. Sends a POST request to the https://api.notion.com/v1/pages endpoint of the Notion API in order to create a new page, using the information from the data object Finally, calls the createNotionPage() function from within the getPokemon() function, after everything else in that latter function has finished executing. At this point, the basic structure of the entire script is in place. You can jump back up to the flow chart (or view it on Whimsical in a new tab) to see that entire structure, but here‚Äôs a super-quick refresher. When you run node index.js in the terminal, the following process kicks into high gear: Axios and the Notion API client are imported, the notion variable is created, and the pokeArray array is created (initially empty). getPokemon() is called. Within getPokemon(), a loop executes. For each loop iteration, we make a call to Pok√©API for a Pok√©mon, then place the data we want from the response into an object called pokeData. We then push that pokeData object onto the end of pokeArray. After the loop has finished running as many times as is defined, we call createNotionPage(). Inside createNotionPage(), we have a loop that will execute for each object within pokeArray. Each time, it will take the data from the current object within pokeArray being worked on, place it in the data object, then send that object off to Notion within a request to create a new page. In other words, we go through one loop to called Pok√©API a bunch of times and load up our pokeArray with lots of objects (one for each Pok√©mon), then we go through another loop a bunch of times to send those objects to our Notion Pok√©dex. Now that you understand the gist of what‚Äôs happening, let‚Äôs dig into the actual call being made to the Notion API. First, I‚Äôll briefly cover what‚Äôs happening in our for...of loop: for (let pokemon of pokeArray) This is a looping construct that iterates over every element in pokeArray. As you‚Äôll recall, each element in that array is an object, defined by the pokeData object definition, which holds information about each Pok√©mon. Each time the loop executes, the current element of pokeArray is temporarily stored in the pokemon variable defined in the loop declaration. This means that we can access the Pok√©mon‚Äôs name like so: pokemon.name Earlier in the script, we used pokeData.name to do the same thing. But since we define the variable name as pokemon in the loop declaration, we now use pokemon instead of pokeData. More detail on for‚Ä¶of loops In the code above, you can see that we‚Äôre using a for...of loop to iterate over our array: for (let pokemon of pokeArray) { } This is a type of for loop that can iterate over the values of an array or an object (for... in loops can iterate over the keys). You can see the differences between for...of and for...in here: For-In vs For-Of | Kevin Chisholm ‚Äì Blog blog.kevinchisholm.com In most cases, you want to access the actual values of an object or array, so a for...of loop is cleaner. Note that you could also write a normal for loop, using the array‚Äôs length to set the end parameter: for (let i = 0; i < pokeArray.length; i++) { } Since we‚Äôre working on an array, these approaches are functionally identical. Next, let‚Äôs look at the data object declaration. const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } data is an object that is structured exactly as the Notion API expects. Of course, you may now be wondering‚Ä¶ how do I know how to structure the object? That‚Äôs where the Notion API documentation comes in ‚Äì and you‚Äôre going to want to get very familiar with it. In this case, I looked at the reference for creating new pages: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com On this page, you can get all the information you need to properly structure your request to the API. Let‚Äôs go over a few important parts of this page: First, at the top of the page you‚Äôll see the endpoint URL and the method required for sending this type of request. For creating a page, you send a POST request to https://api.notion.com/v1/pages ‚Äì or you use a method that does the same for you (e.g. using notion.pages.create() as we are in our script). Second, you‚Äôll see the body parameters that can be sent with the request. You‚Äôll also see the ones that are required ‚Äì in this case, the parent (which is either a database or an existing page) and the properties. Third, you‚Äôll see the example code area. This shows a sample request, which you can use as a reference for modeling your own request. Additional Example Options Note that you can use the dropdown menus to see other requests. The default example uses the official Notion SDK for JavaScript, which we‚Äôre using in this project as well. It provides lots of handy methods for making API requests without writing as much code. However, you can see several other examples. If you change the dropdown from Notion SDK to Axios, for example, you‚Äôll see this code: import axios from 'axios'; const options = { method: 'POST', url: 'https://api.notion.com/v1/pages', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json' } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); My only issue with this example code is that it actually doesn‚Äôt give you all of the information you need to make a request using Axios. Perhaps they‚Äôll fix this in the future (you may see different code if you‚Äôre reading this well after I publish it), but for now, it‚Äôs incomplete. Here‚Äôs the full code you‚Äôd need to use to create a page using Axios: const axios = require('axios') const options = { method: 'POST', url: 'https://api.notion.com/v1/pages/', headers: { accept: 'application/json', 'Notion-Version': '2022-06-28', 'content-type': 'application/json', Authorization: `Bearer ${process.env.NOTION_KEY}` }, data: { parent: { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, properties: { \"Name\": { \"title\": [ { \"text\": { \"content\": \"Test Page\" } } ] } } } }; axios .request(options) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); The code is quite similar, but you can see that I‚Äôve included two new pieces of information: An Authorization property in the headers object, containing my integration‚Äôs secret key A data object that contains both the parent and the properties. Both of these are required, yet they aren‚Äôt shown in the Axios example. This is a harsh truth I‚Äôve learned as I‚Äôve gone through my journey of learning APIs; you‚Äôre often expected to know a lot of fundamentals, and API documentation often doesn‚Äôt hold your hand. This is likely because developers are trying to write mountains of documentation very quickly, and they‚Äôre also experienced enough to know the missing pieces by heart. Unfortunately, us noobs are often left scratching our heads as a result! Fourth, you can see examples of responses that the API will send back. Here on the Create a Page doc, there are four possible responses: 200 ‚Äì a successful response, indicating that the page has been created. 400 ‚Äì invalid request (can mean several things) 404 ‚Äì resource does not exist (in this case, the parent) 429 ‚Äì your application has been rate limited You can see a full list of the error responses that the Notion API may return here: Errors Responses from the API use HTTP response codes are used to indicate general classes of success and error. Error responses contain more detail about the error in the response body, in the ‚Äúcode‚Äù and ‚Äúmessage‚Äù properties. developers.notion.com Using the information on this page ‚Äì especially the example code ‚Äì I was able to properly construct the data object. There‚Äôs one other page that came in very handy for constructing this request, and that‚Äôs the Property Values reference: Property values A property value defines the identifier, type, and value of a page property in a page object. It‚Äôs used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with ‚Ä¶ developers.notion.com Note: This page is currently not shown in the sidebar of the API reference. It‚Äôs quite hard to find, and it‚Äôs the only page that shows you explicitly how to set property values when creating or updating pages. There is also a Page Property Values page, which is listed in the sidebar, and which has a very similar title ‚Äì but only shows you the responses that you get when you retrieve property values. Notion is in the middle of merging these two pages, but as of this writing, that process hasn‚Äôt been completed yet. This page will show you how to properly construct an object in order to set any kind of property value (that is supported by the API). For example, here‚Äôs how you‚Äôd set a value in the number-type property called No: \"No\": { \"number\": 42 } Important Note: That first key value (in this case, ‚ÄúNo‚Äù), must match the name of the property in your database. Using the property references on that page, you‚Äôll be able to figure out how to structure your request and add values to all of the properties in your target database (if indeed you‚Äôre creating a page in a database). Finally, we have this small block of code that actually sends the request to Notion: console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) Here, we‚Äôre simply using the notion.pages.create() method, passing our data object as the argument. Note that we could have defined the object directly between those parentheses, but I find it cleaner to define it first and then simply pass the variable as the argument. The console.log() lines simply log information in the terminal. Before we move one, I‚Äôd like to cover one more quirk from our data object definition: \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, Note how the first line accesses the defense property: pokemon.defense ‚Äì this method of accessing object properties is called dot notation. It can be used when the property name contains only letter, numbers, or underscores. When a property name contains other characters ‚Äì such as spaces or dashes ‚Äì then you must use bracket notation to access it. The line accessing special-attack shows how: pokemon['special-attack']. Learn more here: Property accessors ‚Äì JavaScript | MDN Property accessors provide access to an object‚Äôs properties by using the dot notation or the bracket notation. developer.mozilla.org Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 1 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Create Multiple Pages at Once Now that we have the basic structure of our script in place, it‚Äôs time to kick things up a notch and fetch multiple Pok√©mon at once. Fortunately, we already have both of our loops in place! So all we need to do in this step is: Tweak the end variable so that the initial loop runs more than once, and fetches more than one Pok√©mon Add a ‚Äúwait‚Äù function to prevent our script from getting rate-limited Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Now let‚Äôs test this out. First, delete your original Bulbasaur entry from your Pok√©dex, since it will be recreated. Next, run node index.js in the terminal once more. If everything goes smoothly, you should see a lot of log information in your terminal. Additionally, you should now have ten entries in your Pok√©dex: Let‚Äôs go over what we‚Äôve added. The first change here is pretty simple. We‚Äôre just changing const end = 1 to const end = 10, which will cause our initial loop to run ten times. This means that we‚Äôll make ten called to Pok√©API and add ten objects to pokeArray. The other change is the addition of the following code beneath the getPokemon() call: const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; This is a simple function that takes a single argument (a number) and will cause the script to wait that many milliseconds before continuing whenever we call it. You can see that we‚Äôre calling it right before sending each page to Notion: await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) JavaScript doesn‚Äôt have a built-in sleep() function as some other languages do, but we can use the above code to approximate one. It uses a combination of setTimeout() (a built-in Web API method), a Promise, and async/await to essentially pause the script for the number of milliseconds we specify. More Detail on the sleep() function You don‚Äôt really need to understand the nuts and bolts of the sleep() function to use it; you can basically just copy and paste. However, if you‚Äôre curious about how and why it works, here‚Äôs a brief overview. The built-in setTimeout() function will set a timer and execute a function after the timer is up. Here‚Äôs the reference for it: setTimeout() ‚Äì Web APIs | MDN The global setTimeout() method sets a timer which executes a function or specified piece of code once the timer expires. developer.mozilla.org However, setTimeout() will not delay the execution of the next line of code. We can get around this issue by creating a Promise within our sleep() function, which is only fulfilled after the setTimeout() call inside it has finished running. Then, by calling the function with the await keyword (e.g. await sleep(300)), we effectively cause our script to pause for 300 milliseconds before moving on. The MDN documentation on Promises explains why this works: Promise ‚Äì JavaScript | MDN The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. developer.mozilla.org You can also get more detail on this sleep() function itself here: JavaScript Sleep: How to Pause Code Execution JavaScript does not have an inbuilt sleep function but thanks to the introduction of promises and async/await, we can implement such sleep in JavaScript. appdividend.com Why are we doing this, though? The reason is that requests to the Notion API are rate-limited, meaning you can‚Äôt send a huge number of requests super-quickly to it. Notion is not unique here; almost all APIs have some kind of rate-limiting implemented. The Notion API currently allows an average of three requests per second: The rate limit for incoming requests per integration is an average of three requests per second. Some bursts beyond the average rate are allowed. Read more here: Request limits To ensure a consistent developer experience for all API users, the Notion API is rate limited and basic size limits apply to request parameters. Rate limits Rate-limited requests will return a ‚Äúrate_limited‚Äù error code (HTTP response status 429). The rate limit for incoming requests per integration ‚Ä¶ developers.notion.com This doc also mentions that a rate-limited request (e.g. one that fails due to hitting the rate limit) will return a 429 error. If you get this, you‚Äôre supposed to set up your code to try the request again after a number of milliseconds that is specified in the Retry-After header value in the 429 response. However, a quick-and-dirty way to make sure we never even see a 429 response is to make sure our script never sends requests too quickly. Hence our await sleep(300) line before the actual call to the Notion API ‚Äì we are waiting 300ms before sending each request, keeping our average very close to that three-requests-per-second limit. There are certainly more sophisticated ways you could handle Notion‚Äôs rate limits, which would likely make your application run faster. I‚Äôd encourage you to explore them as you continue to learn and build! Code Checkpoint At this stage, your code should look just like this: const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const pokeData = { \"name\": poke.data.species.name, \"number\": poke.data.id, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Refine Your Pok√©mon Data At this point, your script can send basic information about multiple Pok√©mon to Notion all at once. Now we‚Äôll start the process of adding additional information to each Pok√©dex entry, as well as refining some of the information we already have. Add/change the highlighted lines in your code: async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } createNotionPage() } Remember, you can always jump back up to the Steal My Code section to see the final version of the code. This step adds a lot of code, and makes some significant changes to the pokeData object declaration. If you‚Äôre starting to feel overwhelmed, now might be a good time to get up and take a short break! I made a video about how breaks are crucial to learning and productivity a while ago, and it even has a Pok√©mon in the thumbnail‚Ä¶ so you know I have to include it here. Once you‚Äôre feeling fresh, let‚Äôs take some time to go through each of these new additions to our code. At a glance, here‚Äôs what we‚Äôre accomplishing in this step: Get and store each Pok√©mon‚Äôs type(s) Reformat each Pok√©mon‚Äôs name to look nicer (e.g. changing ‚Äúmr-mime‚Äù to ‚ÄúMr. Mime‚Äù) Construct a valid Bulbapedia URL for each Pok√©mon, which we‚Äôll later embed in that Pok√©mon‚Äôs page content Get and store the sprite and/or official artwork for each Pok√©mon Each of these steps has a specific code block. For now, we‚Äôre simply getting and formatting this information; we‚Äôll send it to Notion in a later step. First, we get the Pok√©mon‚Äôs type ‚Äì or multiple types! const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } This presents a bit of a challenge. Pok√©mon can have up to two types, and Pok√©API returns each Pok√©mon‚Äôs type(s) as an array filled with objects. See for yourself at the official docs for the pokemon endpoint. This means we have to: Dig into each object within the types array and get the name of each type Place to types into a new array of objects, structured in the way that the Notion API requires To do this, we create a typesRaw variable, setting its value to the entire array of types from the API response: poke.data.types. We also create a new empty array called typesArray. Once again, we‚Äôre using a for...of loop to iterate over typesRaw. Inside, we declare an object called typeObj, setting its name property to type.type.name. The first type in that object is simply the type variable we defined in the for...of loop declaration, which represents the current object being iterated over. The second is the actual type property, the value of which is an object containing the name property (in addition to a url property that we aren‚Äôt using). Next, we format the Pok√©mon‚Äôs name so it looks nicer. This process also has a secondary benefit; it will allow us to construct valid Bulbapedia URLs later. const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") We‚Äôre doing a lot here code-wise, but the aims are simple: Capitalize each Pok√©mon‚Äôs name Handle edge cases where we need to add periods, accent characters (√©), dashes, colons, or gender symbols (‚ôÇ, ‚ôÄ) How this code works This block of code may initially look confusing, as it is quite dense. The reason for this is that I‚Äôve used method chaining to condense it. In JavaScript, you can call methods one after another with periods. This results in code that takes up less space, and for experienced programmers it can often be more readable. However, for a beginner, it may be intimidating. So the best way to explain this code will be to rewrite it as distinct steps on their own lines. Run the code here, then view the source: Here, I have both the distinct steps as well as the method-chained approach in the code. As you can see, both methods give the same exact result. However, using method-chaining takes up far fewer lines. Learn more about method chaining: Here‚Äôs what the code actually does, in order: Splits the name into an array of single-word values (will usually create a single-element array, but this is needed for Pok√©mon like Mr. Mime and Type: Null) Uses map() to iterate over the returned array, executing these steps on each element: Use toUpperCase to capitalize the first letter of the name Concatenate that capitalized letter with the rest of the name (using substring() to get everything except the first letter) Join the elements of that array back together as a single string, separating each with a space character (\" \") Use replace() to handle edge-case replacements, such as replacing ‚ÄúMr M‚Äù with ‚ÄúMr. M‚Äù As for the actual methods being implemented here, I‚Äôll link to the docs for each one: String.prototype.split() Array.prototype.map() String.prototype.toUpperCase() (using bracket notation to access the first character in the string) String.prototype.substring() Array.prototype.join() String.prototype.replace() Third, we construct the Bulbapedia URL: const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` This step is fairly straightforward. We create a variable called bulbURL and set its value by creating a template literal (using the backtick ` characters), which allows us to reference variables within the string. Template literals (Template strings) ‚Äì JavaScript | MDN Template literals are literals delimited with backtick (`) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates. developer.mozilla.org Bulbapedia has an extremely rigid structure for its URLs. It‚Äôs always the same, except for the Pok√©mon name: https://bulbapedia.bulbagarden.net/wiki/Charmander_(Pok√©mon) https://bulbapedia.bulbagarden.net/wiki/Squirtle_(Pok√©mon) https://bulbapedia.bulbagarden.net/wiki/Mr._Mime_(Pok√©mon) Thus, our URL structure just needed to use processedName to set the correct URL. The only fancy thing we‚Äôre doing here is using replace() to replace any space characters with underscores: `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` More on replace(): String.prototype.replace() ‚Äì JavaScript | MDN The replace() method returns a new string with one, some, or all matches of a pattern replaced by a replacement. The pattern can be a string or a RegExp, and the replacement can be a string or a function called for each match. If pattern is a string, only the first occurrence will be replaced. The original string is left unchanged. developer.mozilla.org Fourth, we define a variable called sprite that holds either the Pok√©mon‚Äôs sprite or its official artwork: const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default The reason we need to do either/or here is because Pok√©mon from Pok√©mon Legends: Arceus and later games don‚Äôt have sprites (their models are 3D). As a result, Pok√©API doesn‚Äôt have a sprite object for them, meaning we need to grab their official artwork instead. Finally, we add our new key:value pairs to the pokeData object definition: sprite, bulbURL, and typesArray. Additionally, we change the value of the name property to be our new processedName variable. const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } If you‚Äôd like to test your code at this point, I‚Äôd recommend commenting out the createNotionPage() function call. Adding // to the beginning of that line will turn it into a comment, preventing it from executing. // createNotionPage() Doing this will allow you to see the log information for your code changes without sending more pages to Notion (which we‚Äôre not yet ready to do). Run node index.js in the terminal once more, and you should see log information like this: Here, our console.table() reports are now showing our nicely-formatted Pok√©mon names. We can also see the URLs for the sprite, official artwork, and Bulbapedia page. Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is commented-out at this point; later, we‚Äôll remove the comment symbols to enable it again. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Get Flavor & Generation Data for Each Pok√©mon In the last step, we added quite a lot of new information to our pokeData object definition. However, we‚Äôre still missing a few vital pieces ‚Äì including each Pok√©mon‚Äôs: Generation (e.g. Gen I, II, III‚Ä¶) Category/Genera (e.g. ‚ÄúFlame Pok√©mon‚Äù or ‚ÄúDancing Pok√©mon‚Äù) Flavor Text The reason we haven‚Äôt gotten these pieces of information up until now is because they‚Äôre accessible via a completely different endpoint of Pok√©API: the pokemon-species endpoint. All of our previous information came from the pokemon endpoint. In fact, Pok√©API has several different endpoints under the ‚ÄúPok√©mon‚Äù umbrella: My guess as to why they‚Äôve designed their API this way is to simply cut down on the amount of information that is returned from a single request. In any case, we need to query the pokemon-species endpoint in order to get these piece of information. To do so, add the following lines to your code, just above your createNotionPage() function call within the getPokemon() function: pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } //createNotionPage(); } This code sets up a for...of loop, just as we did when we created our createNotionPage() function (click here to jump back to that section if you need a refresher). Within that loop, we‚Äôre using Axios to call the pokemon-species endpoint. Note how we use the pokemon.number property to define the specific URL: await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) Since we‚Äôre iterating over each element of pokeArray, we‚Äôre just taking the number obtained from our previous call to the normal pokemon endpoint. Once we get the response, we do three things: Declare the flavorText, category, and generation variables, setting their values by accessing the relevant information from the API response and formatting it. Add new properties to our pokeData object, setting their values using the variables we just declared. Log the event in the console. Note that we could easily combine steps #1 and #2 here; we don‚Äôt need the interim variables (e.g. flavorText). I‚Äôve only split these steps up to make things clearer. There‚Äôs actually a lot going on here, and the steps we have to take to access and format the data in step #1 here are quite technical. Therefore, I‚Äôll put each of them in a toggle that you can read through if you want. Flavor Text and Category To fetch and format the flavor text, we use this line of code: const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") We do nearly the exact same thing to get the category, just without the replace() call at the end: const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus Here I‚Äôll break down the flavorText variable assignment, but it applies to category as well. Once again we‚Äôre method-chaining here, using these methods: Array.prototype.find() String.prototype.replace() Here‚Äôs the problem we need to solve with flavor text: the pokemon-species endpoint‚Äôs response contains an array called flavor_text_entries ‚Äì which may contain many flavor text objects in different languages. Additionally, the english flavor text is not always at the same index in the array ‚Äì so we can‚Äôt just target a particular index. Instead, we need to search through each object, find the one where the value of flavor_text_entries[X].language.name equals \"en\", and then get the flavor_text property from it. Chespin‚Äôs record stores the English flavor text at array element #6. To do this, we use the find() method, which will search through an array and return the first element that satisfies the condition we specify in a testing function. To make this clearer, let‚Äôs look at a simple embed that just uses find() to return the flavor_text entry from the array element that contains the English text: In our test function, we‚Äôre doing something called nested object destructuring. This will make sense more readily if you understand destructuring in general: Destructuring assignment javascript.info Once you understand destructuring, you can dig into nested object destructuring: Nested Destructuring Learn how to use nested destructuring on nested objects with JavaScript. davidwalsh.name The gist, though, is that instead of setting the entire object we‚Äôre currently iterating over as the argument in our test function, we‚Äôre ‚Äúdigging into‚Äù that object and setting only the nested name property as the argument instead. From there, find() iterates over each element in the flavor_text_entries array until it finds the one where that nested name property‚Äôs value is \"en\". Since the matched array element is the return value, we can simply access its flavor_text property (end of this line): const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text Unfortunately, this flavor text often contains lots of newline characters that make the text look very wonky. To deal with that, we finish our method chain with a replace() call: replace(/\\n|\\f|\\r/g, \" \") Here, I‚Äôm using a regular expression to replace every instance of a newline character (typically these will be \\n, but they can also be \\f or \\r) with a space character. Here‚Äôs how that works: The / characters define the beginning and end of the regular expression to be matched \\n, \\f, and \\r are all the possible ‚Äúnewline‚Äù characters that will cause a line break in a string The | character means ‚Äúor‚Äù Finally, the g flag means ‚Äúmatch every instance of this expression, not just the first one Regular expressions are a whole subject unto themselves, but if you want to learn them, start here: RegexOne ‚Äì Learn Regular Expressions ‚Äì Lesson 1: An Introduction, and the ABCs RegexOne provides a set of interactive lessons and exercises to help you learn regular expressions regexone.com You can find more regular expression resources at the Regex guide in my Notion Formula Reference: Regular Expressions in Notion Formulas ‚Äì Notion Formula Reference Learn how to use regular expressions in Notion‚Äôs test(), replace(), and replaceAll() functions. learn.thomasjfrank.com Generation Getting and formatting the generation is easier than getting the flavor text and category. We use this code: const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() Here we‚Äôre fetching the generation, which Pok√©API formats like so: generation-vi. We want a simple Roman numeral, like VI. We also want it capitalized. To do that, we go through this process: split() to split the string into array elements, using the - character as our separator pop() to remove the last element of the returned array and (more importantly) return it toUpperCase() to fully capitalize that returned element Once we have those variables set, we simply create new properties in the current pokemon object (defined earlier by the pokeData definition, then represented as pokemon via the for...of loop definition): pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation As you can see, all we have to do is create the new property with either dot notation or bracket notation, depending on the characters in its name. Read more on this here: How to Add Property to an object in JavaScript? ‚Äì Scaler Topics In this article by Scaler Topics, we will look at different ways of adding a property to an object in JavaScript using different methods and examples. www.scaler.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"No\": { \"number\": pokemon.number }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } } } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Add New Data to the Notion API Call We‚Äôre at the last code step! All we need to do now is modify the data object definition within our createNotionPage() function, adding the new pieces of information that we‚Äôve fetched (generation, types, flavor text, art, etc.). Add the highlighted code to your data object definition: async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } In addition to the additions and changes highlighted above, be sure to add commas after the closing } symbols where needed. For example: \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, When defining JavaScript objects or writing JSON, sequential properties must be separated by commas as shown above. If you run into errors when trying to run your code, be sure to check for missing commas. I‚Äôve missed plenty of them in my code before. In this step, we add the following information: Page Icon (Using the sprite) Page Cover (Using the official artwork) Properties: Category (rich text) Type (multi-select) Generation (select) Sprite (file) Child blocks (i.e. page content) Flavor text (quote block) A blank space (text block ‚Äì for formatting/aesthetics) ‚ÄúView This Pok√©mon‚Äôs Entry on Bulbapedia:‚Äù (text block) Bulbapedia URL (bookmark block) We‚Äôve already covered objects quite heavily in this guide, so I won‚Äôt spend too much time explaining each addition here. Instead, I‚Äôll point you to the relevant pages in the Notion API reference that explain them. To learn how to set the page icon and page cover, refer to the example code shown on the Create a Page reference: Create a page Connect Notion pages and databases to the tools you use every day, creating powerful workflows. developers.notion.com Note that images cannot be uploaded to Notion via the API at this time, so you must link to an image hosted externally (as we‚Äôre doing here). For the properties, you can currently see how to format your objects when creating and updating pages here: Property values A property value defines the identifier, type, and value of a page property in a page object. It‚Äôs used when retrieving and updating pages, ex: Create and Update pages. All property values Each page property value object contains the following keys. In addition, it contains a key corresponding with ‚Ä¶ developers.notion.com In the near future, all of this information will be consolidated into the Page Property Values page, which is linked in the reference‚Äôs sidebar. To add child blocks/page content, refer to the example code in the Create a Page reference linked above. You can also use the Append Block Children reference to learn how to add new blocks to existing pages and blocks (remember, pages are blocks themselves!): Append block children Creates and appends new children blocks to the parent block_id specified. Returns a paginated list of newly created first level children block objects. Errors Returns a 404 HTTP response if the block specified by id doesn‚Äôt exist, or if the integration doesn‚Äôt have access to the block. Returns a 400‚Ä¶ developers.notion.com Code Checkpoint At this stage, your code should look just like this. Note how createNotionPage() is still commented out. In the next step, we‚Äôre remove the // symbols and re-enable that function call. const axios = require('axios') const { Client } = require('@notionhq/client') const notion = new Client({auth: process.env.NOTION_KEY}) const pokeArray = [] async function getPokemon() { const start = 1 const end = 10 for (let i = start; i <= end; i++) { const poke = await axios.get(`https://pokeapi.co/api/v2/pokemon/${i}`) .then((poke) => { const typesRaw = poke.data.types const typesArray = [] for (let type of typesRaw) { const typeObj = { \"name\": type.type.name } typesArray.push(typeObj) } const processedName = poke.data.species.name.split(/-/).map((name) => { return name[0].toUpperCase() + name.substring(1); }).join(\" \") .replace(/^Mr M/,\"Mr. M\") .replace(/^Mime Jr/,\"Mime Jr.\") .replace(/^Mr R/,\"Mr. R\") .replace(/mo O/,\"mo-o\") .replace(/Porygon Z/,\"Porygon-Z\") .replace(/Type Null/, \"Type: Null\") .replace(/Ho Oh/,\"Ho-Oh\") .replace(/Nidoran F/,\"Nidoran‚ôÄ\") .replace(/Nidoran M/,\"Nidoran‚ôÇ\") .replace(/Flabebe/,\"Flab√©b√©\") const bulbURL = `https://bulbapedia.bulbagarden.net/wiki/${processedName.replace(' ', '_')}_(Pok√©mon)` const sprite = (!poke.data.sprites.front_default) ? poke.data.sprites.other['official-artwork'].front_default : poke.data.sprites.front_default const pokeData = { \"name\": processedName, \"number\": poke.data.id, \"types\": typesArray, \"height\": poke.data.height, \"weight\": poke.data.weight, \"hp\": poke.data.stats[0].base_stat, \"attack\": poke.data.stats[1].base_stat, \"defense\": poke.data.stats[2].base_stat, \"special-attack\": poke.data.stats[3].base_stat, \"special-defense\": poke.data.stats[4].base_stat, \"speed\": poke.data.stats[5].base_stat, \"sprite\": sprite, \"artwork\": poke.data.sprites.other['official-artwork'].front_default, \"bulbURL\": bulbURL } console.log(`Fetched ${pokeData.name}.`) console.table(pokeData) pokeArray.push(pokeData) }) .catch((error) => { console.log(error) }) } for (let pokemon of pokeArray) { const flavor = await axios.get(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.number}`) .then((flavor) => { const flavorText = flavor.data.flavor_text_entries.find(({language: { name }}) => name === \"en\").flavor_text.replace(/\\n|\\f|\\r/g, \" \") const category = flavor.data.genera.find(({language: { name }}) => name === \"en\").genus const generation = flavor.data.generation.name.split(/-/).pop().toUpperCase() pokemon['flavor-text'] = flavorText pokemon.category = category pokemon.generation = generation console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } // createNotionPage() } getPokemon() const sleep = (milliseconds) => { return new Promise(resolve => setTimeout(resolve, milliseconds)) }; async function createNotionPage() { for (let pokemon of pokeArray) { const data = { \"parent\": { \"type\": \"database_id\", \"database_id\": process.env.NOTION_DATABASE_ID }, \"icon\": { \"type\": \"external\", \"external\": { \"url\": pokemon.sprite } }, \"cover\": { \"type\": \"external\", \"external\": { \"url\": pokemon.artwork } }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": pokemon.name } } ] }, \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category } } ] }, \"No\": { \"number\": pokemon.number }, \"Type\": { \"multi_select\": pokemon.types }, \"Generation\": { \"select\": { \"name\": pokemon.generation } }, \"Sprite\": { \"files\": [ { \"type\": \"external\", \"name\": \"Pokemon Sprite\", \"external\": { \"url\": pokemon.sprite } } ] }, \"Height\": { \"number\": pokemon.height }, \"Weight\": { \"number\": pokemon.weight }, \"HP\": { \"number\": pokemon.hp }, \"Attack\": { \"number\": pokemon.attack }, \"Defense\": { \"number\": pokemon.defense }, \"Sp. Attack\": { \"number\": pokemon['special-attack'] }, \"Sp. Defense\": { \"number\": pokemon['special-defense'] }, \"Speed\": { \"number\": pokemon.speed } }, \"children\": [ { \"object\": \"block\", \"type\": \"quote\", \"quote\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon['flavor-text'] } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"\" } } ] } }, { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"View This Pok√©mon's Entry on Bulbapedia:\" } } ] } }, { \"object\": \"block\", \"type\": \"bookmark\", \"bookmark\": { \"url\": pokemon.bulbURL } } ] } await sleep(300) console.log(`Sending ${pokemon.name} to Notion`) const response = await notion.pages.create( data ) console.log(response) } console.log(`Operation complete.`) } Run Your Final Test It‚Äôs time to actually run your script! Before you do, go into your code and ‚Äúun-comment‚Äù the createNotionPage() function call at the end of your getPokemon() function: console.log(`Fetched flavor info for ${pokemon.name}.`) }) .catch((error) => { console.log(error) }) } createNotionPage() } getPokemon() This will ensure the createNotionPage() function is actually called, and that your pages get created in your Notion database. Now it‚Äôs time for the moment of truth. Run node index.js in your terminal one more time; if all goes well, you should see these full-featured entries flooding into your Pok√©dex: Since we also set up the Generation information, you‚Äôll also get them neatly grouped under the I group! If you click into each page, you should also see the flavor text and Bulbapedia link: If everything looks good, then you can modify your start and end variables in order to fetch more Pok√©mon. You already have #1-#10, so now you can set: start = 11 end = 905 Adding Pok√©mon #906-#1008 As of this writing, Pok√©API has not yet added flavor text, category, or generation information for Pok√©mon #906-#1,008 (those releases with Scarlet and Violet). Therefore, this script will work flawlessly for all Pok√©mon up to #905. If you‚Äôd like to add the newer Pok√©mon, you can see ‚Äúdefault‚Äù values in the data object definition, as shown below. I found that I needed to do this for Category, Flavor Text, and Generation. \"Category\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": pokemon.category || \"No Category Information\" } } ] } There are more elegant ways to handle this, but I‚Äôll leave them as an exercise for you to tackle if you‚Äôre so inclined! Once you‚Äôre modified those variables and ran the script again, you‚Äôll be the proud owner of a full Pok√©dex in your Notion workspace. Conclusion If you‚Äôve followed this tutorial, you hopefully now have a strong grasp on how to work with the Notion API using JavaScript. What you‚Äôll quickly learn if you start working with other APIs is‚Ä¶ you also know how to work with them as well! As I‚Äôve learned, working with one API greatly prepares you for working with almost any other API. From here, you can use your newly-developed programming and API skills to do nearly anything you want. One resource I‚Äôll recommend now is Pipedream, which is a platform that lets you connect APIs and write actual code (unlike no-code tools, such as Make.com). I love Pipedream because it handles all of the server setup and API authentication for you, letting you just worry about your code. They also have an incredibly generous free tier; I can‚Äôt imagine ever having to pay for Pipedream. As a result, you‚Äôll see Pipedream-focused tutorials on this site in the future. This tutorial took months to produce; if you enjoyed it, you can support my work by grabbing one of my Notion templates (there are both free and paid options here): The Best Free Notion Templates for Tasks, Projects, Notes, and More If you want to improve your Notion workspace, these advanced, battle-tested templates will help you do it. Made by YouTuber Thomas Frank. thomasjfrank.com You can also join my Notion Tips newsletter below for free; once you‚Äôre on it, I‚Äôll send you tons of Notion cheat sheets and goodies. You‚Äôll also be the first to know when I publish new tutorials and templates.","metadata":{"source":"https://thomasjfrank.com/notion-api-crash-course","title":"The Complete Notion API Crash Course for Beginners","date":"2023-02-10T20:53:27+00:00","contentLength":24879}}]